# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the Ethernet Segments.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__esi_type','__esi','__redundancy_mode','__es_import_route_target','__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=True)
    self.__esi_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=True)
    self.__esi = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=True)
    self.__redundancy_mode = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=True)
    self.__es_import_route_target = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=True)
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/config/name (string)

    YANG Description: Ethernet Segment name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Ethernet Segment name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=True)


  def _get_esi_type(self):
    """
    Getter method for esi_type, mapped from YANG variable /ethernet_segments/ethernet_segment/config/esi_type (oc-evpn-types:esi-type)

    YANG Description: ESI Type is a 1-octet field (most significant octet) that
specifies the format of the remaining 9 octets (ESI Value).
    """
    return self.__esi_type
      
  def _set_esi_type(self, v, load=False):
    """
    Setter method for esi_type, mapped from YANG variable /ethernet_segments/ethernet_segment/config/esi_type (oc-evpn-types:esi-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi_type() directly.

    YANG Description: ESI Type is a 1-octet field (most significant octet) that
specifies the format of the remaining 9 octets (ESI Value).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi_type must be of a type compatible with oc-evpn-types:esi-type""",
          'defined-type': "oc-evpn-types:esi-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=True)""",
        })

    self.__esi_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi_type(self):
    self.__esi_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=True)


  def _get_esi(self):
    """
    Getter method for esi, mapped from YANG variable /ethernet_segments/ethernet_segment/config/esi (union)

    YANG Description: Ethernet Segment Identifier (ESI) value.
For ESI Type 0: The esi leaf value is directly configured by the operator.
For ESI Type 1: The AUTO enum must be used.
For ESI Type 2: The AUTO enum must be used.
For ESI Type 3: The directly configured or AUTO enum must be used.
For ESI Type 4: The directly configured or AUTO enum must be used.
For ESI Type 5: The directly configured or AUTO enum must be used.
    """
    return self.__esi
      
  def _set_esi(self, v, load=False):
    """
    Setter method for esi, mapped from YANG variable /ethernet_segments/ethernet_segment/config/esi (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi() directly.

    YANG Description: Ethernet Segment Identifier (ESI) value.
For ESI Type 0: The esi leaf value is directly configured by the operator.
For ESI Type 1: The AUTO enum must be used.
For ESI Type 2: The AUTO enum must be used.
For ESI Type 3: The directly configured or AUTO enum must be used.
For ESI Type 4: The directly configured or AUTO enum must be used.
For ESI Type 5: The directly configured or AUTO enum must be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi must be of a type compatible with union""",
          'defined-type': "openconfig-ethernet-segments:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=True)""",
        })

    self.__esi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi(self):
    self.__esi = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=True)


  def _get_redundancy_mode(self):
    """
    Getter method for redundancy_mode, mapped from YANG variable /ethernet_segments/ethernet_segment/config/redundancy_mode (identityref)

    YANG Description: Multihoming options for load balancing of
traffic in the Ethernet Segment.
    """
    return self.__redundancy_mode
      
  def _set_redundancy_mode(self, v, load=False):
    """
    Setter method for redundancy_mode, mapped from YANG variable /ethernet_segments/ethernet_segment/config/redundancy_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redundancy_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redundancy_mode() directly.

    YANG Description: Multihoming options for load balancing of
traffic in the Ethernet Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redundancy_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-ethernet-segments:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=True)""",
        })

    self.__redundancy_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redundancy_mode(self):
    self.__redundancy_mode = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=True)


  def _get_es_import_route_target(self):
    """
    Getter method for es_import_route_target, mapped from YANG variable /ethernet_segments/ethernet_segment/config/es_import_route_target (oc-yang-types:mac-address)

    YANG Description: Received ES routes with an ES-Import extended community set to this value
are imported into this ethernet segment.  When configured by a user, the
es-import-route-target will be used, otherwise the system automatically
derives the value used by following the procedures in RFC 7432 Section 7.6.
    """
    return self.__es_import_route_target
      
  def _set_es_import_route_target(self, v, load=False):
    """
    Setter method for es_import_route_target, mapped from YANG variable /ethernet_segments/ethernet_segment/config/es_import_route_target (oc-yang-types:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_es_import_route_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_es_import_route_target() directly.

    YANG Description: Received ES routes with an ES-Import extended community set to this value
are imported into this ethernet segment.  When configured by a user, the
es-import-route-target will be used, otherwise the system automatically
derives the value used by following the procedures in RFC 7432 Section 7.6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """es_import_route_target must be of a type compatible with oc-yang-types:mac-address""",
          'defined-type': "oc-yang-types:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=True)""",
        })

    self.__es_import_route_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_es_import_route_target(self):
    self.__es_import_route_target = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /ethernet_segments/ethernet_segment/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /ethernet_segments/ethernet_segment/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /ethernet_segments/ethernet_segment/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is required, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /ethernet_segments/ethernet_segment/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is required, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  esi_type = __builtin__.property(_get_esi_type, _set_esi_type)
  esi = __builtin__.property(_get_esi, _set_esi)
  redundancy_mode = __builtin__.property(_get_redundancy_mode, _set_redundancy_mode)
  es_import_route_target = __builtin__.property(_get_es_import_route_target, _set_es_import_route_target)
  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('name', name), ('esi_type', esi_type), ('esi', esi), ('redundancy_mode', redundancy_mode), ('es_import_route_target', es_import_route_target), ('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the Ethernet Segments.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__esi_type','__esi','__redundancy_mode','__es_import_route_target','__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=False)
    self.__esi_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=False)
    self.__esi = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=False)
    self.__redundancy_mode = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=False)
    self.__es_import_route_target = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=False)
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/state/name (string)

    YANG Description: Ethernet Segment name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Ethernet Segment name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='string', is_config=False)


  def _get_esi_type(self):
    """
    Getter method for esi_type, mapped from YANG variable /ethernet_segments/ethernet_segment/state/esi_type (oc-evpn-types:esi-type)

    YANG Description: ESI Type is a 1-octet field (most significant octet) that
specifies the format of the remaining 9 octets (ESI Value).
    """
    return self.__esi_type
      
  def _set_esi_type(self, v, load=False):
    """
    Setter method for esi_type, mapped from YANG variable /ethernet_segments/ethernet_segment/state/esi_type (oc-evpn-types:esi-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi_type() directly.

    YANG Description: ESI Type is a 1-octet field (most significant octet) that
specifies the format of the remaining 9 octets (ESI Value).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi_type must be of a type compatible with oc-evpn-types:esi-type""",
          'defined-type': "oc-evpn-types:esi-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=False)""",
        })

    self.__esi_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi_type(self):
    self.__esi_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'TYPE_0_OPERATOR_CONFIGURED': {'value': 0}, 'TYPE_1_LACP_BASED': {'value': 1}, 'TYPE_2_BRIDGE_PROTOCOL_BASED': {'value': 2}, 'TYPE_3_MAC_BASED': {'value': 3}, 'TYPE_4_ROUTER_ID_BASED': {'value': 4}, 'TYPE_5_AS_BASED': {'value': 5}},), default=str("TYPE_0_OPERATOR_CONFIGURED"), is_leaf=True, yang_name="esi-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-evpn-types:esi-type', is_config=False)


  def _get_esi(self):
    """
    Getter method for esi, mapped from YANG variable /ethernet_segments/ethernet_segment/state/esi (union)

    YANG Description: Ethernet Segment Identifier (ESI) value.
For ESI Type 0: The esi leaf value is directly configured by the operator.
For ESI Type 1: The AUTO enum must be used.
For ESI Type 2: The AUTO enum must be used.
For ESI Type 3: The directly configured or AUTO enum must be used.
For ESI Type 4: The directly configured or AUTO enum must be used.
For ESI Type 5: The directly configured or AUTO enum must be used.
    """
    return self.__esi
      
  def _set_esi(self, v, load=False):
    """
    Setter method for esi, mapped from YANG variable /ethernet_segments/ethernet_segment/state/esi (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esi() directly.

    YANG Description: Ethernet Segment Identifier (ESI) value.
For ESI Type 0: The esi leaf value is directly configured by the operator.
For ESI Type 1: The AUTO enum must be used.
For ESI Type 2: The AUTO enum must be used.
For ESI Type 3: The directly configured or AUTO enum must be used.
For ESI Type 4: The directly configured or AUTO enum must be used.
For ESI Type 5: The directly configured or AUTO enum must be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esi must be of a type compatible with union""",
          'defined-type': "openconfig-ethernet-segments:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=False)""",
        })

    self.__esi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esi(self):
    self.__esi = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]*'}), restriction_dict={'length': ['20']}),RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'AUTO': {}},),], is_leaf=True, yang_name="esi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='union', is_config=False)


  def _get_redundancy_mode(self):
    """
    Getter method for redundancy_mode, mapped from YANG variable /ethernet_segments/ethernet_segment/state/redundancy_mode (identityref)

    YANG Description: Multihoming options for load balancing of
traffic in the Ethernet Segment.
    """
    return self.__redundancy_mode
      
  def _set_redundancy_mode(self, v, load=False):
    """
    Setter method for redundancy_mode, mapped from YANG variable /ethernet_segments/ethernet_segment/state/redundancy_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redundancy_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redundancy_mode() directly.

    YANG Description: Multihoming options for load balancing of
traffic in the Ethernet Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redundancy_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-ethernet-segments:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=False)""",
        })

    self.__redundancy_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redundancy_mode(self):
    self.__redundancy_mode = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:SINGLE_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'openconfig-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}, 'oc-evpn-types:ALL_ACTIVE': {'@module': 'openconfig-evpn-types', '@namespace': 'http://openconfig.net/yang/evpn-types'}},), is_leaf=True, yang_name="redundancy-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='identityref', is_config=False)


  def _get_es_import_route_target(self):
    """
    Getter method for es_import_route_target, mapped from YANG variable /ethernet_segments/ethernet_segment/state/es_import_route_target (oc-yang-types:mac-address)

    YANG Description: Received ES routes with an ES-Import extended community set to this value
are imported into this ethernet segment.  When configured by a user, the
es-import-route-target will be used, otherwise the system automatically
derives the value used by following the procedures in RFC 7432 Section 7.6.
    """
    return self.__es_import_route_target
      
  def _set_es_import_route_target(self, v, load=False):
    """
    Setter method for es_import_route_target, mapped from YANG variable /ethernet_segments/ethernet_segment/state/es_import_route_target (oc-yang-types:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_es_import_route_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_es_import_route_target() directly.

    YANG Description: Received ES routes with an ES-Import extended community set to this value
are imported into this ethernet segment.  When configured by a user, the
es-import-route-target will be used, otherwise the system automatically
derives the value used by following the procedures in RFC 7432 Section 7.6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """es_import_route_target must be of a type compatible with oc-yang-types:mac-address""",
          'defined-type': "oc-yang-types:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=False)""",
        })

    self.__es_import_route_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_es_import_route_target(self):
    self.__es_import_route_target = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="es-import-route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='oc-yang-types:mac-address', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /ethernet_segments/ethernet_segment/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /ethernet_segments/ethernet_segment/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /ethernet_segments/ethernet_segment/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is required, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /ethernet_segments/ethernet_segment/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is required, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=str, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)
  esi_type = __builtin__.property(_get_esi_type)
  esi = __builtin__.property(_get_esi)
  redundancy_mode = __builtin__.property(_get_redundancy_mode)
  es_import_route_target = __builtin__.property(_get_es_import_route_target)
  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('name', name), ('esi_type', esi_type), ('esi', esi), ('redundancy_mode', redundancy_mode), ('es_import_route_target', es_import_route_target), ('interface', interface), ('subinterface', subinterface), ])


class yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/df-election/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the Designated forwarding Election
  """
  __slots__ = ('_path_helper', '_extmethods', '__df_election_method','__preference','__revertive','__election_wait_time',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'df-election', 'config']

  def _get_df_election_method(self):
    """
    Getter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    return self.__df_election_method
      
  def _set_df_election_method(self, v, load=False):
    """
    Setter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_election_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_election_method() directly.

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_election_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ethernet-segments:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)""",
        })

    self.__df_election_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_election_method(self):
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)


  def _get_preference(self):
    """
    Getter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    return self.__preference
      
  def _set_preference(self, v, load=False):
    """
    Setter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preference() directly.

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preference must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)""",
        })

    self.__preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preference(self):
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)


  def _get_election_wait_time(self):
    """
    Getter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    return self.__election_wait_time
      
  def _set_election_wait_time(self, v, load=False):
    """
    Setter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_election_wait_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_election_wait_time() directly.

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """election_wait_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)""",
        })

    self.__election_wait_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_election_wait_time(self):
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

  df_election_method = __builtin__.property(_get_df_election_method, _set_df_election_method)
  preference = __builtin__.property(_get_preference, _set_preference)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  election_wait_time = __builtin__.property(_get_election_wait_time, _set_election_wait_time)


  _pyangbind_elements = OrderedDict([('df_election_method', df_election_method), ('preference', preference), ('revertive', revertive), ('election_wait_time', election_wait_time), ])


class yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/df-election/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the Designated forwarding Election
  """
  __slots__ = ('_path_helper', '_extmethods', '__df_election_method','__preference','__revertive','__election_wait_time',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=False)
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=False)
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=False)
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'df-election', 'state']

  def _get_df_election_method(self):
    """
    Getter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/df_election_method (enumeration)

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    return self.__df_election_method
      
  def _set_df_election_method(self, v, load=False):
    """
    Setter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/df_election_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_election_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_election_method() directly.

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_election_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ethernet-segments:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=False)""",
        })

    self.__df_election_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_election_method(self):
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=False)


  def _get_preference(self):
    """
    Getter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/preference (uint16)

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    return self.__preference
      
  def _set_preference(self, v, load=False):
    """
    Setter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/preference (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preference() directly.

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preference must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=False)""",
        })

    self.__preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preference(self):
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=False)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/revertive (boolean)

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=False)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=False)


  def _get_election_wait_time(self):
    """
    Getter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/election_wait_time (uint32)

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    return self.__election_wait_time
      
  def _set_election_wait_time(self, v, load=False):
    """
    Setter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state/election_wait_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_election_wait_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_election_wait_time() directly.

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """election_wait_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=False)""",
        })

    self.__election_wait_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_election_wait_time(self):
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=False)

  df_election_method = __builtin__.property(_get_df_election_method)
  preference = __builtin__.property(_get_preference)
  revertive = __builtin__.property(_get_revertive)
  election_wait_time = __builtin__.property(_get_election_wait_time)


  _pyangbind_elements = OrderedDict([('df_election_method', df_election_method), ('preference', preference), ('revertive', revertive), ('election_wait_time', election_wait_time), ])


class yc_df_election_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/df-election. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top container for the configuration and state parameters
for the Designated forwarding Election
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'df-election'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'df-election']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config (container)

    YANG Description: Configuration parameters for the Designated forwarding Election
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for the Designated forwarding Election
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state (container)

    YANG Description: Configuration parameters for the Designated forwarding Election
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Configuration parameters for the Designated forwarding Election
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_ethernet_segment_openconfig_ethernet_segments__ethernet_segments_ethernet_segment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Ethernet Segments.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__df_election',)

  _yang_name = 'ethernet-segment'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)
    self.__df_election = YANGDynClass(base=yc_df_election_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election, is_container='container', yang_name="df-election", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/name (leafref)

    YANG Description: Ethernet Segment Name 
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ethernet_segments/ethernet_segment/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Ethernet Segment Name 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ethernet_segments/ethernet_segment/config (container)

    YANG Description: Configuration data for the Ethernet Segments.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ethernet_segments/ethernet_segment/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the Ethernet Segments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ethernet_segments/ethernet_segment/state (container)

    YANG Description: Operational state data for the Ethernet Segments.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ethernet_segments/ethernet_segment/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the Ethernet Segments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=False)


  def _get_df_election(self):
    """
    Getter method for df_election, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election (container)

    YANG Description: Top container for the configuration and state parameters
for the Designated forwarding Election
    """
    return self.__df_election
      
  def _set_df_election(self, v, load=False):
    """
    Setter method for df_election, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_election is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_election() directly.

    YANG Description: Top container for the configuration and state parameters
for the Designated forwarding Election
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_df_election_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election, is_container='container', yang_name="df-election", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_election must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_df_election_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election, is_container='container', yang_name="df-election", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__df_election = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_election(self):
    self.__df_election = YANGDynClass(base=yc_df_election_openconfig_ethernet_segments__ethernet_segments_ethernet_segment_df_election, is_container='container', yang_name="df-election", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  df_election = __builtin__.property(_get_df_election, _set_df_election)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('df_election', df_election), ])


class yc_ethernet_segments_openconfig_ethernet_segments__ethernet_segments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
  """
  __slots__ = ('_path_helper', '_extmethods', '__ethernet_segment',)

  _yang_name = 'ethernet-segments'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ethernet_segment = YANGDynClass(base=YANGListType("name",yc_ethernet_segment_openconfig_ethernet_segments__ethernet_segments_ethernet_segment, yang_name="ethernet-segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments']

  def _get_ethernet_segment(self):
    """
    Getter method for ethernet_segment, mapped from YANG variable /ethernet_segments/ethernet_segment (list)

    YANG Description: List of Ethernet Segments.
    """
    return self.__ethernet_segment
      
  def _set_ethernet_segment(self, v, load=False):
    """
    Setter method for ethernet_segment, mapped from YANG variable /ethernet_segments/ethernet_segment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_segment() directly.

    YANG Description: List of Ethernet Segments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_ethernet_segment_openconfig_ethernet_segments__ethernet_segments_ethernet_segment, yang_name="ethernet-segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_segment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_ethernet_segment_openconfig_ethernet_segments__ethernet_segments_ethernet_segment, yang_name="ethernet-segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='list', is_config=True)""",
        })

    self.__ethernet_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_segment(self):
    self.__ethernet_segment = YANGDynClass(base=YANGListType("name",yc_ethernet_segment_openconfig_ethernet_segments__ethernet_segments_ethernet_segment, yang_name="ethernet-segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='list', is_config=True)

  ethernet_segment = __builtin__.property(_get_ethernet_segment, _set_ethernet_segment)


  _pyangbind_elements = OrderedDict([('ethernet_segment', ethernet_segment), ])


class openconfig_ethernet_segments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /openconfig-ethernet-segments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains definitions of ethernet segements.
The ethernet segments are used in EVPN services are
defined for the whole device
  """
  __slots__ = ('_path_helper', '_extmethods', '__ethernet_segments',)

  _yang_name = 'openconfig-ethernet-segments'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ethernet_segments = YANGDynClass(base=yc_ethernet_segments_openconfig_ethernet_segments__ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ethernet_segments(self):
    """
    Getter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    return self.__ethernet_segments
      
  def _set_ethernet_segments(self, v, load=False):
    """
    Setter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_segments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_segments() directly.

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_segments_openconfig_ethernet_segments__ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_segments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_segments_openconfig_ethernet_segments__ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__ethernet_segments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_segments(self):
    self.__ethernet_segments = YANGDynClass(base=yc_ethernet_segments_openconfig_ethernet_segments__ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

  ethernet_segments = __builtin__.property(_get_ethernet_segments, _set_ethernet_segments)


  _pyangbind_elements = OrderedDict([('ethernet_segments', ethernet_segments), ])


