# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /joined-aps/joined-ap/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for Joined APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__hostname','__opstate','__uptime','__enabled','__serial','__model','__software_version','__ipv4','__ipv6','__power_source',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.)', 'length': ['1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    self.__opstate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)
    self.__serial = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    self.__model = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__power_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AT': {}, 'AF': {}, 'PLUG': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['joined-aps', 'joined-ap', 'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /joined_aps/joined_ap/state/mac (oc-yang:mac-address)

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /joined_aps/joined_ap/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /joined_aps/joined_ap/state/hostname (oc-inet:domain-name)

    YANG Description: Hostname of the Access Point.
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /joined_aps/joined_ap/state/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.)', 'length': ['1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.)', 'length': ['1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.)', 'length': ['1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)


  def _get_opstate(self):
    """
    Getter method for opstate, mapped from YANG variable /joined_aps/joined_ap/state/opstate (identityref)

    YANG Description: The current operational state of the AP.
    """
    return self.__opstate
      
  def _set_opstate(self, v, load=False):
    """
    Setter method for opstate, mapped from YANG variable /joined_aps/joined_ap/state/opstate (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opstate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opstate() directly.

    YANG Description: The current operational state of the AP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opstate must be of a type compatible with identityref""",
          'defined-type': "openconfig-ap-manager:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)""",
        })

    self.__opstate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opstate(self):
    self.__opstate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UP': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:DOWN': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi-types:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}, 'oc-wifi:UPGRADING': {'@module': 'openconfig-wifi-types', '@namespace': 'http://openconfig.net/yang/wifi/wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)


  def _get_uptime(self):
    """
    Getter method for uptime, mapped from YANG variable /joined_aps/joined_ap/state/uptime (uint32)

    YANG Description: Seconds this AP has been in the op-state of 'UP'.
    """
    return self.__uptime
      
  def _set_uptime(self, v, load=False):
    """
    Setter method for uptime, mapped from YANG variable /joined_aps/joined_ap/state/uptime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uptime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uptime() directly.

    YANG Description: Seconds this AP has been in the op-state of 'UP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uptime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)""",
        })

    self.__uptime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uptime(self):
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /joined_aps/joined_ap/state/enabled (boolean)

    YANG Description: Wheather the AP is enabled or disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /joined_aps/joined_ap/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Wheather the AP is enabled or disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)


  def _get_serial(self):
    """
    Getter method for serial, mapped from YANG variable /joined_aps/joined_ap/state/serial (string)

    YANG Description: Serial number of the Access Point.
    """
    return self.__serial
      
  def _set_serial(self, v, load=False):
    """
    Setter method for serial, mapped from YANG variable /joined_aps/joined_ap/state/serial (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial() directly.

    YANG Description: Serial number of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__serial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial(self):
    self.__serial = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_model(self):
    """
    Getter method for model, mapped from YANG variable /joined_aps/joined_ap/state/model (string)

    YANG Description: Model number of the Access Point.
    """
    return self.__model
      
  def _set_model(self, v, load=False):
    """
    Setter method for model, mapped from YANG variable /joined_aps/joined_ap/state/model (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_model() directly.

    YANG Description: Model number of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """model must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_model(self):
    self.__model = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /joined_aps/joined_ap/state/software_version (string)

    YANG Description: Software version of the Access Point.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /joined_aps/joined_ap/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: Software version of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /joined_aps/joined_ap/state/ipv4 (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the Access Point.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /joined_aps/joined_ap/state/ipv4 (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: The IPv4 address of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /joined_aps/joined_ap/state/ipv6 (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the Access Point.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /joined_aps/joined_ap/state/ipv6 (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: The IPv6 address of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_power_source(self):
    """
    Getter method for power_source, mapped from YANG variable /joined_aps/joined_ap/state/power_source (enumeration)

    YANG Description: Enumerate how the AP is being powered.
    """
    return self.__power_source
      
  def _set_power_source(self, v, load=False):
    """
    Setter method for power_source, mapped from YANG variable /joined_aps/joined_ap/state/power_source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_source() directly.

    YANG Description: Enumerate how the AP is being powered.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AT': {}, 'AF': {}, 'PLUG': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_source must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ap-manager:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AT': {}, 'AF': {}, 'PLUG': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)""",
        })

    self.__power_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_source(self):
    self.__power_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AT': {}, 'AF': {}, 'PLUG': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)

  mac = __builtin__.property(_get_mac)
  hostname = __builtin__.property(_get_hostname)
  opstate = __builtin__.property(_get_opstate)
  uptime = __builtin__.property(_get_uptime)
  enabled = __builtin__.property(_get_enabled)
  serial = __builtin__.property(_get_serial)
  model = __builtin__.property(_get_model)
  software_version = __builtin__.property(_get_software_version)
  ipv4 = __builtin__.property(_get_ipv4)
  ipv6 = __builtin__.property(_get_ipv6)
  power_source = __builtin__.property(_get_power_source)


  _pyangbind_elements = OrderedDict([('mac', mac), ('hostname', hostname), ('opstate', opstate), ('uptime', uptime), ('enabled', enabled), ('serial', serial), ('model', model), ('software_version', software_version), ('ipv4', ipv4), ('ipv6', ipv6), ('power_source', power_source), ])


