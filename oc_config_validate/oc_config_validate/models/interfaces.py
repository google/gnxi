# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class openconfig_if_8021x(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-8021x - based on the path /openconfig-if-8021x. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing 8021X. Augments the OpenConfig models for
wired interfaces and wireless SSIDs for configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip-ext - based on the path /openconfig-if-ip-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base IP configuration and
operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-tunnel - based on the path /openconfig-if-tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model adds extensions to the OpenConfig interfaces
model to configure tunnel interfaces on a network
device.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet - based on the path /openconfig-if-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing Ethernet interfaces -- augments the OpenConfig
model for interface configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip - based on the path /openconfig-if-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines data for managing configuration and
operational state on IP (IPv4 and IPv6) interfaces.

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7277 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7277.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_if_sdn_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-sdn-ext - based on the path /openconfig-if-sdn-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides extensions to the OpenConfig interfaces
module for network elements that support external 'SDN' control
of their interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_aggregate(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-aggregate - based on the path /openconfig-if-aggregate. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing aggregated (aka bundle, LAG) interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet-ext - based on the path /openconfig-if-ethernet-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base ethernet configuration
and operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_poe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-poe - based on the path /openconfig-if-poe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state data for
Power over Ethernet (PoE) based on the IEEE 802.3af
standard.
  """
  _pyangbind_elements = {}

  

class yc_config_openconfig_interfaces__interfaces_interface_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable items at the global, physical interface
level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__mtu','__loopback_mode','__description','__enabled','__tpid','__forwarding_viable',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=True)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)
    self.__forwarding_viable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/config/name (string)

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.  The 'config false'
list interfaces/interface[name]/state contains the currently
existing interfaces on the device.

If a client tries to create configuration for a
system-controlled interface that is not present in the
corresponding state list, the server MAY reject
the request if the implementation does not support
pre-provisioning of interfaces or if the name refers to
an interface that can never exist in the system.  A
NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.

The IETF model in RFC 7223 provides YANG features for the
following (i.e., pre-provisioning and arbitrary-names),
however they are omitted here:

 If the device supports pre-provisioning of interface
 configuration, the 'pre-provisioning' feature is
 advertised.

 If the device allows arbitrarily named user-controlled
 interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
/interfaces/interface[name]/state list.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.  The 'config false'
list interfaces/interface[name]/state contains the currently
existing interfaces on the device.

If a client tries to create configuration for a
system-controlled interface that is not present in the
corresponding state list, the server MAY reject
the request if the implementation does not support
pre-provisioning of interfaces or if the name refers to
an interface that can never exist in the system.  A
NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.

The IETF model in RFC 7223 provides YANG features for the
following (i.e., pre-provisioning and arbitrary-names),
however they are omitted here:

 If the device supports pre-provisioning of interface
 configuration, the 'pre-provisioning' feature is
 advertised.

 If the device allows arbitrarily named user-controlled
 interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
/interfaces/interface[name]/state list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/config/type (identityref)

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/config/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/config/mtu (uint16)

    YANG Description: Set the max transmission unit size in octets
for the physical interface.  If this is not set, the mtu is
set to the operational default -- e.g., 1514 bytes on an
Ethernet interface.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/config/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Set the max transmission unit size in octets
for the physical interface.  If this is not set, the mtu is
set to the operational default -- e.g., 1514 bytes on an
Ethernet interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=True)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /interfaces/interface/config/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the interface. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /interfaces/interface/config/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the interface. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=True)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/config/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/config/tpid (identityref)

    YANG Description: Optionally set the tag protocol identifier field (TPID) that
is accepted on the VLAN
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/config/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally set the tag protocol identifier field (TPID) that
is accepted on the VLAN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)


  def _get_forwarding_viable(self):
    """
    Getter method for forwarding_viable, mapped from YANG variable /interfaces/interface/config/forwarding_viable (boolean)

    YANG Description: This value indicates whether the interface may be used
to route traffic or not.  If set to false, the
interface is not used for forwarding traffic, but as long as
it is up, the interface still maintains its layer-2
adjacencies and runs its configured layer-2 functions
(e.g., LLDP, etc.).
This is used by an external programming entity to disable an interface
(usually part of an aggregate) for the purposes of forwarding
traffic. This allows a logical aggregate to continue to be
used with partial capacity, for example.  Note that setting
`forwarding-viable = false` is not equivalent to
administratively disabling the interface -- in particular, the
interface is expected to participate in L2 protocols such as
LLDP or LACP even if it blocked from forwarding traffic.
    """
    return self.__forwarding_viable
      
  def _set_forwarding_viable(self, v, load=False):
    """
    Setter method for forwarding_viable, mapped from YANG variable /interfaces/interface/config/forwarding_viable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_viable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_viable() directly.

    YANG Description: This value indicates whether the interface may be used
to route traffic or not.  If set to false, the
interface is not used for forwarding traffic, but as long as
it is up, the interface still maintains its layer-2
adjacencies and runs its configured layer-2 functions
(e.g., LLDP, etc.).
This is used by an external programming entity to disable an interface
(usually part of an aggregate) for the purposes of forwarding
traffic. This allows a logical aggregate to continue to be
used with partial capacity, for example.  Note that setting
`forwarding-viable = false` is not equivalent to
administratively disabling the interface -- in particular, the
interface is expected to participate in L2 protocols such as
LLDP or LACP even if it blocked from forwarding traffic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_viable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=True)""",
        })

    self.__forwarding_viable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_viable(self):
    self.__forwarding_viable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  loopback_mode = __builtin__.property(_get_loopback_mode, _set_loopback_mode)
  description = __builtin__.property(_get_description, _set_description)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  tpid = __builtin__.property(_get_tpid, _set_tpid)
  forwarding_viable = __builtin__.property(_get_forwarding_viable, _set_forwarding_viable)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('mtu', mtu), ('loopback_mode', loopback_mode), ('description', description), ('enabled', enabled), ('tpid', tpid), ('forwarding_viable', forwarding_viable), ])


class yc_counters_openconfig_interfaces__interfaces_interface_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_octets','__in_pkts','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__in_fcs_errors','__out_octets','__out_pkts','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors','__carrier_transitions','__last_clear',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fcs_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__carrier_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'state', 'counters']

  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of packets received on the interface,
including all unicast, multicast, broadcast and bad packets
etc.
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of packets received on the interface,
including all unicast, multicast, broadcast and bad packets
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_unicast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_unicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_broadcast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_broadcast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_multicast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/in_multicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces/interface/state/counters/in_discards (oc-yang:counter64)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces/interface/state/counters/in_discards (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces/interface/state/counters/in_errors (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces/interface/state/counters/in_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/state/counters/in_unknown_protos (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/state/counters/in_unknown_protos (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fcs_errors(self):
    """
    Getter method for in_fcs_errors, mapped from YANG variable /interfaces/interface/state/counters/in_fcs_errors (oc-yang:counter64)

    YANG Description: Number of received packets which had errors in the
frame check sequence (FCS), i.e., framing errors.

Discontinuities in the value of this counter can occur
when the device is re-initialization as indicated by the
value of 'last-clear'.
    """
    return self.__in_fcs_errors
      
  def _set_in_fcs_errors(self, v, load=False):
    """
    Setter method for in_fcs_errors, mapped from YANG variable /interfaces/interface/state/counters/in_fcs_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fcs_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fcs_errors() directly.

    YANG Description: Number of received packets which had errors in the
frame check sequence (FCS), i.e., framing errors.

Discontinuities in the value of this counter can occur
when the device is re-initialization as indicated by the
value of 'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fcs_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fcs_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fcs_errors(self):
    self.__in_fcs_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of packets transmitted out of the
interface, including all unicast, multicast, broadcast,
and bad packets etc.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of packets transmitted out of the
interface, including all unicast, multicast, broadcast,
and bad packets etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_unicast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_unicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_broadcast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_broadcast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_multicast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/state/counters/out_multicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces/interface/state/counters/out_discards (oc-yang:counter64)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces/interface/state/counters/out_discards (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces/interface/state/counters/out_errors (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces/interface/state/counters/out_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_carrier_transitions(self):
    """
    Getter method for carrier_transitions, mapped from YANG variable /interfaces/interface/state/counters/carrier_transitions (oc-yang:counter64)

    YANG Description: Number of times the interface state has transitioned
between up and down since the time the device restarted
or the last-clear time, whichever is most recent.
    """
    return self.__carrier_transitions
      
  def _set_carrier_transitions(self, v, load=False):
    """
    Setter method for carrier_transitions, mapped from YANG variable /interfaces/interface/state/counters/carrier_transitions (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_transitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_transitions() directly.

    YANG Description: Number of times the interface state has transitioned
between up and down since the time the device restarted
or the last-clear time, whichever is most recent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_transitions must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__carrier_transitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_transitions(self):
    self.__carrier_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_last_clear(self):
    """
    Getter method for last_clear, mapped from YANG variable /interfaces/interface/state/counters/last_clear (oc-types:timeticks64)

    YANG Description: Timestamp of the last time the interface counters were
cleared.

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_clear
      
  def _set_last_clear(self, v, load=False):
    """
    Setter method for last_clear, mapped from YANG variable /interfaces/interface/state/counters/last_clear (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_clear() directly.

    YANG Description: Timestamp of the last time the interface counters were
cleared.

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_clear must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__last_clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_clear(self):
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)

  in_octets = __builtin__.property(_get_in_octets)
  in_pkts = __builtin__.property(_get_in_pkts)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  in_fcs_errors = __builtin__.property(_get_in_fcs_errors)
  out_octets = __builtin__.property(_get_out_octets)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)
  carrier_transitions = __builtin__.property(_get_carrier_transitions)
  last_clear = __builtin__.property(_get_last_clear)


  _pyangbind_elements = OrderedDict([('in_octets', in_octets), ('in_pkts', in_pkts), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('in_fcs_errors', in_fcs_errors), ('out_octets', out_octets), ('out_pkts', out_pkts), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ('carrier_transitions', carrier_transitions), ('last_clear', last_clear), ])


class yc_state_openconfig_interfaces__interfaces_interface_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data at the global interface level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__mtu','__loopback_mode','__description','__enabled','__ifindex','__admin_status','__oper_status','__last_change','__logical','__management','__cpu','__counters','__tpid','__forwarding_viable',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=False)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    self.__logical = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__management = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__cpu = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)
    self.__forwarding_viable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/state/name (string)

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.  The 'config false'
list interfaces/interface[name]/state contains the currently
existing interfaces on the device.

If a client tries to create configuration for a
system-controlled interface that is not present in the
corresponding state list, the server MAY reject
the request if the implementation does not support
pre-provisioning of interfaces or if the name refers to
an interface that can never exist in the system.  A
NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.

The IETF model in RFC 7223 provides YANG features for the
following (i.e., pre-provisioning and arbitrary-names),
however they are omitted here:

 If the device supports pre-provisioning of interface
 configuration, the 'pre-provisioning' feature is
 advertised.

 If the device allows arbitrarily named user-controlled
 interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
/interfaces/interface[name]/state list.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the interface.

A device MAY restrict the allowed values for this leaf,
possibly depending on the type of the interface.
For system-controlled interfaces, this leaf is the
device-specific name of the interface.  The 'config false'
list interfaces/interface[name]/state contains the currently
existing interfaces on the device.

If a client tries to create configuration for a
system-controlled interface that is not present in the
corresponding state list, the server MAY reject
the request if the implementation does not support
pre-provisioning of interfaces or if the name refers to
an interface that can never exist in the system.  A
NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.

The IETF model in RFC 7223 provides YANG features for the
following (i.e., pre-provisioning and arbitrary-names),
however they are omitted here:

 If the device supports pre-provisioning of interface
 configuration, the 'pre-provisioning' feature is
 advertised.

 If the device allows arbitrarily named user-controlled
 interfaces, the 'arbitrary-names' feature is advertised.

When a configured user-controlled interface is created by
the system, it is instantiated with the same name in the
/interfaces/interface[name]/state list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/state/type (identityref)

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/state/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the interface.

When an interface entry is created, a server MAY
initialize the type leaf with a valid value, e.g., if it
is possible to derive the type from the name of the
interface.

If a client tries to set the type of an interface to a
value that can never be used by the system, e.g., if the
type is not supported or if the type does not match the
name of the interface, the server MUST reject the request.
A NETCONF server MUST reply with an rpc-error with the
error-tag 'invalid-value' in this case.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-interfaces:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iana-interface-type': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:other': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:regular1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdh1822': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ddnX25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc877x25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernetCsmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88023Csmacd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88024TokenBus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025TokenRing': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88026Man': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:starLan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon10Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:proteon80Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hyperchannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fddi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:e1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:basicISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:primaryISDN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propPointToPointSerial': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ppp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:softwareLoopback': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ethernet3Mbit': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nsip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:slip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ultra': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds3': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rs232': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:para': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arcnetPlus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:miox25': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25ple': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88022llc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:localTalk': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayService': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v35': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hssi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:modem': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal5': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetPath': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetVT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:smdsIcip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propMultiplexor': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80212': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fibreChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hippiInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayInterconnect': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8023': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aflane8025': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cctEmul': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v11': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v36': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at64k': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g703at2mb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qllc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastEtherFX': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:channel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80211': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ibm370parChan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:escon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dlsw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdns': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isdnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapd': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rsrb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmLogical': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds0Bundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bsc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:async': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cnr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Dtr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:eplrs': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:arap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propCnls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hostPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:termPad': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frameRelayMPI': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x213': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025CRFPInt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:myrinet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEM': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXO': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFXS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEncap': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmDxi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmFuni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmIma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pppMultilinkBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverCdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverClaw': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:stackToStack': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualIpAddress': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:iso88025Fiber': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gigabitEthernet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lapf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:v37': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25mlp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x25huntGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:transpHdlc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:interleave': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:a12MppSwitch': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:coffee': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ces': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmSubInterface': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l2vlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:l3ipxvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalPowerline': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mediaMailOverIp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dcn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ipForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:msdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee1394': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:if-gsn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRccUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVirtual': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mplsTunnel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:srp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverFrameRelay': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:idsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:compositeLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ss7SigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propWirelessP2P': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frForward': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rfc1483': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:usb': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee8023adLag': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bgppolicyaccounting': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frf16MfrBundle': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Gatekeeper': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:h323Proxy': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpls': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mfSigLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:shdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ds1FDL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pos': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiIn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbAsiOut': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:plc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:nfas': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:tr008': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303RDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gr303IDT': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:isup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessMaclayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propDocsWirelessUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:hiperlan2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propBWAp2Mp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sonetOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:digitalWrapperOverheadChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aal2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:radioMAC': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:imt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mvl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:reachDSL': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:frDlciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmVciEndPt': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:propAtm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceOverCable': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:infiniband': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:teLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:q2931': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:virtualTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipTg': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sipSig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamChannel': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:econet': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon155': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pon622': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bridge': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:linegroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEMFGD': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDEANA': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceDID': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mpegTransport': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sixToFour': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gtp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pdnEtherLoop2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:opticalChannelGroup': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:homepna': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ciscoISLvlan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:actelisMetaLOOP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fcipLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:rpr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:qam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:lmp': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cblVectaStar': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableMCmtsDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecControlledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:macSecUncontrolledIF': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aviciOpticalEther': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:atmbond': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceFGDOS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:mocaVersion1': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee80216WMAN': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:adsl2plus': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsMacLayer': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbTdm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:dvbRcsTdma': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:x86Laps': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:wwanPP2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:voiceEBS': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifPwType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ilan': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:pip': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluELP': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vdsl2': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Profile': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapDot11Bss': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:capwapWtpVirtualRadio': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:bits': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableUpstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:cableDownstreamRfPort': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareVirtualNic': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ieee802154': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOdu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ifVfiType': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9981': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9982': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:g9983': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEpon': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluEponLogicalLink': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponOnu': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:aluGponPhysicalUni': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:vmwareNicTeam': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmDownstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsOfdmaUpstream': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:gfast': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:sdci': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:xboxWireless': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:fastdsl': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1FwdOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d1RetOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2DsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableScte55d2UsOob': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdf': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:docsCableNdr': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ptm': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:ghn': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsi': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtuc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOduc': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:otnOtsig': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveCarrierTermination': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}, 'ianaift:microwaveRadioLinkTerminal': {'@module': 'iana-if-type', '@namespace': 'urn:ietf:params:xml:ns:yang:iana-if-type'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='identityref', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/state/mtu (uint16)

    YANG Description: Set the max transmission unit size in octets
for the physical interface.  If this is not set, the mtu is
set to the operational default -- e.g., 1514 bytes on an
Ethernet interface.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/state/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Set the max transmission unit size in octets
for the physical interface.  If this is not set, the mtu is
set to the operational default -- e.g., 1514 bytes on an
Ethernet interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint16', is_config=False)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /interfaces/interface/state/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the interface. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /interfaces/interface/state/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the interface. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=False)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-opt-types:loopback-mode-type', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/state/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_ifindex(self):
    """
    Getter method for ifindex, mapped from YANG variable /interfaces/interface/state/ifindex (uint32)

    YANG Description: System assigned number for each interface.  Corresponds to
ifIndex object in SNMP Interface MIB
    """
    return self.__ifindex
      
  def _set_ifindex(self, v, load=False):
    """
    Setter method for ifindex, mapped from YANG variable /interfaces/interface/state/ifindex (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifindex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifindex() directly.

    YANG Description: System assigned number for each interface.  Corresponds to
ifIndex object in SNMP Interface MIB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifindex must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)""",
        })

    self.__ifindex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifindex(self):
    self.__ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces/interface/state/admin_status (enumeration)

    YANG Description: The desired state of the interface.  In RFC 7223 this leaf
has the same read semantics as ifAdminStatus.  Here, it
reflects the administrative state as set by enabling or
disabling the interface.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces/interface/state/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.  In RFC 7223 this leaf
has the same read semantics as ifAdminStatus.  Here, it
reflects the administrative state as set by enabling or
disabling the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces/interface/state/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces/interface/state/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces/interface/state/last_change (oc-types:timeticks64)

    YANG Description: This timestamp indicates the absolute time of the last
state change of the interface (e.g., up-to-down transition).
This is different than the SNMP ifLastChange object in the
standard interface MIB in that it is not relative to the
system boot time (i.e,. sysUpTime).

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces/interface/state/last_change (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: This timestamp indicates the absolute time of the last
state change of the interface (e.g., up-to-down transition).
This is different than the SNMP ifLastChange object in the
standard interface MIB in that it is not relative to the
system boot time (i.e,. sysUpTime).

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)


  def _get_logical(self):
    """
    Getter method for logical, mapped from YANG variable /interfaces/interface/state/logical (boolean)

    YANG Description: When set to true, the interface is a logical interface
which does not have an associated physical port or
channel on the system.
    """
    return self.__logical
      
  def _set_logical(self, v, load=False):
    """
    Setter method for logical, mapped from YANG variable /interfaces/interface/state/logical (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical() directly.

    YANG Description: When set to true, the interface is a logical interface
which does not have an associated physical port or
channel on the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__logical = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical(self):
    self.__logical = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_management(self):
    """
    Getter method for management, mapped from YANG variable /interfaces/interface/state/management (boolean)

    YANG Description: When set to true, the interface is a dedicated
management interface that is not connected to dataplane
interfaces.  It may be used to connect the system to an
out-of-band management network, for example.
    """
    return self.__management
      
  def _set_management(self, v, load=False):
    """
    Setter method for management, mapped from YANG variable /interfaces/interface/state/management (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management() directly.

    YANG Description: When set to true, the interface is a dedicated
management interface that is not connected to dataplane
interfaces.  It may be used to connect the system to an
out-of-band management network, for example.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__management = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management(self):
    self.__management = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /interfaces/interface/state/cpu (boolean)

    YANG Description: When set to true, the interface is for traffic
that is handled by the system CPU, sometimes also called the
control plane interface.  On systems that represent the CPU
interface as an Ethernet interface, for example, this leaf
should be used to distinguish the CPU interface from dataplane
interfaces.
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /interfaces/interface/state/cpu (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: When set to true, the interface is for traffic
that is handled by the system CPU, sometimes also called the
control plane interface.  On systems that represent the CPU
interface as an Ethernet interface, for example, this leaf
should be used to distinguish the CPU interface from dataplane
interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/state/counters (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/state/tpid (identityref)

    YANG Description: Optionally set the tag protocol identifier field (TPID) that
is accepted on the VLAN
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/state/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally set the tag protocol identifier field (TPID) that
is accepted on the VLAN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), default=six.text_type("oc-vlan-types:TPID_0X8100"), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)


  def _get_forwarding_viable(self):
    """
    Getter method for forwarding_viable, mapped from YANG variable /interfaces/interface/state/forwarding_viable (boolean)

    YANG Description: This value indicates whether the interface may be used
to route traffic or not.  If set to false, the
interface is not used for forwarding traffic, but as long as
it is up, the interface still maintains its layer-2
adjacencies and runs its configured layer-2 functions
(e.g., LLDP, etc.).
This is used by an external programming entity to disable an interface
(usually part of an aggregate) for the purposes of forwarding
traffic. This allows a logical aggregate to continue to be
used with partial capacity, for example.  Note that setting
`forwarding-viable = false` is not equivalent to
administratively disabling the interface -- in particular, the
interface is expected to participate in L2 protocols such as
LLDP or LACP even if it blocked from forwarding traffic.
    """
    return self.__forwarding_viable
      
  def _set_forwarding_viable(self, v, load=False):
    """
    Setter method for forwarding_viable, mapped from YANG variable /interfaces/interface/state/forwarding_viable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_viable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_viable() directly.

    YANG Description: This value indicates whether the interface may be used
to route traffic or not.  If set to false, the
interface is not used for forwarding traffic, but as long as
it is up, the interface still maintains its layer-2
adjacencies and runs its configured layer-2 functions
(e.g., LLDP, etc.).
This is used by an external programming entity to disable an interface
(usually part of an aggregate) for the purposes of forwarding
traffic. This allows a logical aggregate to continue to be
used with partial capacity, for example.  Note that setting
`forwarding-viable = false` is not equivalent to
administratively disabling the interface -- in particular, the
interface is expected to participate in L2 protocols such as
LLDP or LACP even if it blocked from forwarding traffic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_viable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=False)""",
        })

    self.__forwarding_viable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_viable(self):
    self.__forwarding_viable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="forwarding-viable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/interfaces/sdn-ext', defining_module='openconfig-if-sdn-ext', yang_type='boolean', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  mtu = __builtin__.property(_get_mtu)
  loopback_mode = __builtin__.property(_get_loopback_mode)
  description = __builtin__.property(_get_description)
  enabled = __builtin__.property(_get_enabled)
  ifindex = __builtin__.property(_get_ifindex)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  logical = __builtin__.property(_get_logical)
  management = __builtin__.property(_get_management)
  cpu = __builtin__.property(_get_cpu)
  counters = __builtin__.property(_get_counters)
  tpid = __builtin__.property(_get_tpid)
  forwarding_viable = __builtin__.property(_get_forwarding_viable)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('mtu', mtu), ('loopback_mode', loopback_mode), ('description', description), ('enabled', enabled), ('ifindex', ifindex), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('logical', logical), ('management', management), ('cpu', cpu), ('counters', counters), ('tpid', tpid), ('forwarding_viable', forwarding_viable), ])


class yc_config_openconfig_interfaces__interfaces_interface_hold_time_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/hold-time/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for interface hold-time settings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__up','__down',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)
    self.__down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'hold-time', 'config']

  def _get_up(self):
    """
    Getter method for up, mapped from YANG variable /interfaces/interface/hold_time/config/up (uint32)

    YANG Description: Dampens advertisement when the interface
transitions from down to up.  A zero value means dampening
is turned off, i.e., immediate notification.
    """
    return self.__up
      
  def _set_up(self, v, load=False):
    """
    Setter method for up, mapped from YANG variable /interfaces/interface/hold_time/config/up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up() directly.

    YANG Description: Dampens advertisement when the interface
transitions from down to up.  A zero value means dampening
is turned off, i.e., immediate notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)""",
        })

    self.__up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up(self):
    self.__up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)


  def _get_down(self):
    """
    Getter method for down, mapped from YANG variable /interfaces/interface/hold_time/config/down (uint32)

    YANG Description: Dampens advertisement when the interface transitions from
up to down.  A zero value means dampening is turned off,
i.e., immediate notification.
    """
    return self.__down
      
  def _set_down(self, v, load=False):
    """
    Setter method for down, mapped from YANG variable /interfaces/interface/hold_time/config/down (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down() directly.

    YANG Description: Dampens advertisement when the interface transitions from
up to down.  A zero value means dampening is turned off,
i.e., immediate notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)""",
        })

    self.__down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down(self):
    self.__down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)

  up = __builtin__.property(_get_up, _set_up)
  down = __builtin__.property(_get_down, _set_down)


  _pyangbind_elements = OrderedDict([('up', up), ('down', down), ])


class yc_state_openconfig_interfaces__interfaces_interface_hold_time_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/hold-time/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for interface hold-time.
  """
  __slots__ = ('_path_helper', '_extmethods', '__up','__down',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    self.__down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'hold-time', 'state']

  def _get_up(self):
    """
    Getter method for up, mapped from YANG variable /interfaces/interface/hold_time/state/up (uint32)

    YANG Description: Dampens advertisement when the interface
transitions from down to up.  A zero value means dampening
is turned off, i.e., immediate notification.
    """
    return self.__up
      
  def _set_up(self, v, load=False):
    """
    Setter method for up, mapped from YANG variable /interfaces/interface/hold_time/state/up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up() directly.

    YANG Description: Dampens advertisement when the interface
transitions from down to up.  A zero value means dampening
is turned off, i.e., immediate notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)""",
        })

    self.__up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up(self):
    self.__up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="up", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)


  def _get_down(self):
    """
    Getter method for down, mapped from YANG variable /interfaces/interface/hold_time/state/down (uint32)

    YANG Description: Dampens advertisement when the interface transitions from
up to down.  A zero value means dampening is turned off,
i.e., immediate notification.
    """
    return self.__down
      
  def _set_down(self, v, load=False):
    """
    Setter method for down, mapped from YANG variable /interfaces/interface/hold_time/state/down (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down() directly.

    YANG Description: Dampens advertisement when the interface transitions from
up to down.  A zero value means dampening is turned off,
i.e., immediate notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)""",
        })

    self.__down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down(self):
    self.__down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)

  up = __builtin__.property(_get_up)
  down = __builtin__.property(_get_down)


  _pyangbind_elements = OrderedDict([('up', up), ('down', down), ])


class yc_hold_time_openconfig_interfaces__interfaces_interface_hold_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/hold-time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for hold-time settings to enable
dampening advertisements of interface transitions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'hold-time'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_hold_time_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_hold_time_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'hold-time']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/hold_time/config (container)

    YANG Description: Configuration data for interface hold-time settings.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/hold_time/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for interface hold-time settings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_hold_time_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_hold_time_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_hold_time_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/hold_time/state (container)

    YANG Description: Operational state data for interface hold-time.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/hold_time/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for interface hold-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_hold_time_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_hold_time_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_hold_time_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable items at the subinterface level
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/index (uint32)

    YANG Description: The index of the subinterface, or logical interface number.
On systems with no support for subinterfaces, or not using
subinterfaces, this value should default to 0, i.e., the
default subinterface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: The index of the subinterface, or logical interface number.
On systems with no support for subinterfaces, or not using
subinterfaces, this value should default to 0, i.e., the
default subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('enabled', enabled), ])


class yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of interface-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_octets','__in_pkts','__in_unicast_pkts','__in_broadcast_pkts','__in_multicast_pkts','__in_discards','__in_errors','__in_unknown_protos','__in_fcs_errors','__out_octets','__out_pkts','__out_unicast_pkts','__out_broadcast_pkts','__out_multicast_pkts','__out_discards','__out_errors','__carrier_transitions','__last_clear',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fcs_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__carrier_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'state', 'counters']

  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received on the interface,
including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of packets received on the interface,
including all unicast, multicast, broadcast and bad packets
etc.
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of packets received on the interface,
including all unicast, multicast, broadcast and bad packets
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_unicast_pkts(self):
    """
    Getter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_unicast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_unicast_pkts
      
  def _set_in_unicast_pkts(self, v, load=False):
    """
    Setter method for in_unicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_unicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were not addressed to a
multicast or broadcast address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unicast_pkts(self):
    self.__in_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_broadcast_pkts(self):
    """
    Getter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_broadcast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_broadcast_pkts
      
  def _set_in_broadcast_pkts(self, v, load=False):
    """
    Setter method for in_broadcast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_broadcast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_broadcast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_broadcast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_broadcast_pkts(self):
    self.__in_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_multicast_pkts(self):
    """
    Getter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_multicast_pkts (oc-yang:counter64)

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_multicast_pkts
      
  def _set_in_multicast_pkts(self, v, load=False):
    """
    Setter method for in_multicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_multicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_multicast_pkts() directly.

    YANG Description: The number of packets, delivered by this sub-layer to a
higher (sub-)layer, that were addressed to a multicast
address at this sub-layer.  For a MAC-layer protocol,
this includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_multicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_multicast_pkts(self):
    self.__in_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discards(self):
    """
    Getter method for in_discards, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_discards (oc-yang:counter64)

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_discards
      
  def _set_in_discards(self, v, load=False):
    """
    Setter method for in_discards, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_discards (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discards() directly.

    YANG Description: The number of inbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being deliverable to a higher-layer
protocol.  One possible reason for discarding such a
packet could be to free up buffer space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discards must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discards(self):
    self.__in_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_errors(self):
    """
    Getter method for in_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_errors (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_errors
      
  def _set_in_errors(self, v, load=False):
    """
    Setter method for in_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of inbound
packets that contained errors preventing them from being
deliverable to a higher-layer protocol.  For character-
oriented or fixed-length interfaces, the number of
inbound transmission units that contained errors
preventing them from being deliverable to a higher-layer
protocol.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_errors(self):
    self.__in_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_unknown_protos(self):
    """
    Getter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_unknown_protos (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__in_unknown_protos
      
  def _set_in_unknown_protos(self, v, load=False):
    """
    Setter method for in_unknown_protos, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_unknown_protos (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_unknown_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_unknown_protos() directly.

    YANG Description: For packet-oriented interfaces, the number of packets
received via the interface that were discarded because
of an unknown or unsupported protocol.  For
character-oriented or fixed-length interfaces that
support protocol multiplexing, the number of
transmission units received via the interface that were
discarded because of an unknown or unsupported protocol.
For any interface that does not support protocol
multiplexing, this counter is not present.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_unknown_protos must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_unknown_protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_unknown_protos(self):
    self.__in_unknown_protos = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-unknown-protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fcs_errors(self):
    """
    Getter method for in_fcs_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_fcs_errors (oc-yang:counter64)

    YANG Description: Number of received packets which had errors in the
frame check sequence (FCS), i.e., framing errors.

Discontinuities in the value of this counter can occur
when the device is re-initialization as indicated by the
value of 'last-clear'.
    """
    return self.__in_fcs_errors
      
  def _set_in_fcs_errors(self, v, load=False):
    """
    Setter method for in_fcs_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/in_fcs_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fcs_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fcs_errors() directly.

    YANG Description: Number of received packets which had errors in the
frame check sequence (FCS), i.e., framing errors.

Discontinuities in the value of this counter can occur
when the device is re-initialization as indicated by the
value of 'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fcs_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fcs_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fcs_errors(self):
    self.__in_fcs_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fcs-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets transmitted out of the
interface, including framing characters.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of packets transmitted out of the
interface, including all unicast, multicast, broadcast,
and bad packets etc.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of packets transmitted out of the
interface, including all unicast, multicast, broadcast,
and bad packets etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_unicast_pkts(self):
    """
    Getter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_unicast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_unicast_pkts
      
  def _set_out_unicast_pkts(self, v, load=False):
    """
    Setter method for out_unicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_unicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_unicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_unicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were not addressed
to a multicast or broadcast address at this sub-layer,
including those that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_unicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_unicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_unicast_pkts(self):
    self.__out_unicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-unicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_broadcast_pkts(self):
    """
    Getter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_broadcast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_broadcast_pkts
      
  def _set_out_broadcast_pkts(self, v, load=False):
    """
    Setter method for out_broadcast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_broadcast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_broadcast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_broadcast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
broadcast address at this sub-layer, including those
that were discarded or not sent.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_broadcast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_broadcast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_broadcast_pkts(self):
    self.__out_broadcast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-broadcast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_multicast_pkts(self):
    """
    Getter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_multicast_pkts (oc-yang:counter64)

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_multicast_pkts
      
  def _set_out_multicast_pkts(self, v, load=False):
    """
    Setter method for out_multicast_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_multicast_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_multicast_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_multicast_pkts() directly.

    YANG Description: The total number of packets that higher-level protocols
requested be transmitted, and that were addressed to a
multicast address at this sub-layer, including those
that were discarded or not sent.  For a MAC-layer
protocol, this includes both Group and Functional
addresses.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_multicast_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_multicast_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_multicast_pkts(self):
    self.__out_multicast_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-multicast-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discards(self):
    """
    Getter method for out_discards, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_discards (oc-yang:counter64)

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_discards
      
  def _set_out_discards(self, v, load=False):
    """
    Setter method for out_discards, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_discards (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discards() directly.

    YANG Description: The number of outbound packets that were chosen to be
discarded even though no errors had been detected to
prevent their being transmitted.  One possible reason
for discarding such a packet could be to free up buffer
space.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discards must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discards(self):
    self.__out_discards = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_errors(self):
    """
    Getter method for out_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_errors (oc-yang:counter64)

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    return self.__out_errors
      
  def _set_out_errors(self, v, load=False):
    """
    Setter method for out_errors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/out_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_errors() directly.

    YANG Description: For packet-oriented interfaces, the number of outbound
packets that could not be transmitted because of errors.
For character-oriented or fixed-length interfaces, the
number of outbound transmission units that could not be
transmitted because of errors.

Discontinuities in the value of this counter can occur
at re-initialization of the management system, and at
other times as indicated by the value of
'last-clear'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_errors(self):
    self.__out_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_carrier_transitions(self):
    """
    Getter method for carrier_transitions, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/carrier_transitions (oc-yang:counter64)

    YANG Description: Number of times the interface state has transitioned
between up and down since the time the device restarted
or the last-clear time, whichever is most recent.
    """
    return self.__carrier_transitions
      
  def _set_carrier_transitions(self, v, load=False):
    """
    Setter method for carrier_transitions, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/carrier_transitions (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_transitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_transitions() directly.

    YANG Description: Number of times the interface state has transitioned
between up and down since the time the device restarted
or the last-clear time, whichever is most recent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_transitions must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__carrier_transitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_transitions(self):
    self.__carrier_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="carrier-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-yang:counter64', is_config=False)


  def _get_last_clear(self):
    """
    Getter method for last_clear, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/last_clear (oc-types:timeticks64)

    YANG Description: Timestamp of the last time the interface counters were
cleared.

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_clear
      
  def _set_last_clear(self, v, load=False):
    """
    Setter method for last_clear, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters/last_clear (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_clear() directly.

    YANG Description: Timestamp of the last time the interface counters were
cleared.

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_clear must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__last_clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_clear(self):
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)

  in_octets = __builtin__.property(_get_in_octets)
  in_pkts = __builtin__.property(_get_in_pkts)
  in_unicast_pkts = __builtin__.property(_get_in_unicast_pkts)
  in_broadcast_pkts = __builtin__.property(_get_in_broadcast_pkts)
  in_multicast_pkts = __builtin__.property(_get_in_multicast_pkts)
  in_discards = __builtin__.property(_get_in_discards)
  in_errors = __builtin__.property(_get_in_errors)
  in_unknown_protos = __builtin__.property(_get_in_unknown_protos)
  in_fcs_errors = __builtin__.property(_get_in_fcs_errors)
  out_octets = __builtin__.property(_get_out_octets)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_unicast_pkts = __builtin__.property(_get_out_unicast_pkts)
  out_broadcast_pkts = __builtin__.property(_get_out_broadcast_pkts)
  out_multicast_pkts = __builtin__.property(_get_out_multicast_pkts)
  out_discards = __builtin__.property(_get_out_discards)
  out_errors = __builtin__.property(_get_out_errors)
  carrier_transitions = __builtin__.property(_get_carrier_transitions)
  last_clear = __builtin__.property(_get_last_clear)


  _pyangbind_elements = OrderedDict([('in_octets', in_octets), ('in_pkts', in_pkts), ('in_unicast_pkts', in_unicast_pkts), ('in_broadcast_pkts', in_broadcast_pkts), ('in_multicast_pkts', in_multicast_pkts), ('in_discards', in_discards), ('in_errors', in_errors), ('in_unknown_protos', in_unknown_protos), ('in_fcs_errors', in_fcs_errors), ('out_octets', out_octets), ('out_pkts', out_pkts), ('out_unicast_pkts', out_unicast_pkts), ('out_broadcast_pkts', out_broadcast_pkts), ('out_multicast_pkts', out_multicast_pkts), ('out_discards', out_discards), ('out_errors', out_errors), ('carrier_transitions', carrier_transitions), ('last_clear', last_clear), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for logical interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__enabled','__name','__ifindex','__admin_status','__oper_status','__last_change','__logical','__management','__cpu','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    self.__ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    self.__logical = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__management = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__cpu = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/index (uint32)

    YANG Description: The index of the subinterface, or logical interface number.
On systems with no support for subinterfaces, or not using
subinterfaces, this value should default to 0, i.e., the
default subinterface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: The index of the subinterface, or logical interface number.
On systems with no support for subinterfaces, or not using
subinterfaces, this value should default to 0, i.e., the
default subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/description (string)

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A textual description of the interface.

A server implementation MAY map this leaf to the ifAlias
MIB object.  Such an implementation needs to use some
mechanism to handle the differences in size and characters
allowed between this leaf and ifAlias.  The definition of
such a mechanism is outside the scope of this document.

Since ifAlias is defined to be stored in non-volatile
storage, the MIB implementation MUST map ifAlias to the
value of 'description' in the persistently stored
datastore.

Specifically, if the device supports ':startup', when
ifAlias is read the device MUST return the value of
'description' in the 'startup' datastore, and when it is
written, it MUST be written to the 'running' and 'startup'
datastores.  Note that it is up to the implementation to

decide whether to modify this single leaf in 'startup' or
perform an implicit copy-config from 'running' to
'startup'.

If the device does not support ':startup', ifAlias MUST
be mapped to the 'description' leaf in the 'running'
datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
interface.

Systems that implement the IF-MIB use the value of this
leaf in the 'running' datastore to set
IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
has been initialized, as described in RFC 2863.

Changes in this leaf in the 'running' datastore are
reflected in ifAdminStatus, but if ifAdminStatus is
changed over SNMP, this leaf is not affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/name (string)

    YANG Description: The system-assigned name for the sub-interface.  This MAY
be a combination of the base interface name and the
subinterface index, or some other convention used by the
system.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The system-assigned name for the sub-interface.  This MAY
be a combination of the base interface name and the
subinterface index, or some other convention used by the
system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='string', is_config=False)


  def _get_ifindex(self):
    """
    Getter method for ifindex, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/ifindex (uint32)

    YANG Description: System assigned number for each interface.  Corresponds to
ifIndex object in SNMP Interface MIB
    """
    return self.__ifindex
      
  def _set_ifindex(self, v, load=False):
    """
    Setter method for ifindex, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/ifindex (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifindex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifindex() directly.

    YANG Description: System assigned number for each interface.  Corresponds to
ifIndex object in SNMP Interface MIB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifindex must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)""",
        })

    self.__ifindex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifindex(self):
    self.__ifindex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ifindex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='uint32', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/admin_status (enumeration)

    YANG Description: The desired state of the interface.  In RFC 7223 this leaf
has the same read semantics as ifAdminStatus.  Here, it
reflects the administrative state as set by enabling or
disabling the interface.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/admin_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: The desired state of the interface.  In RFC 7223 this leaf
has the same read semantics as ifAdminStatus.  Here, it
reflects the administrative state as set by enabling or
disabling the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/oper_status (enumeration)

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: The current operational state of the interface.

This leaf has the same semantics as ifOperStatus.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-interfaces:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {'value': 1}, 'DOWN': {'value': 2}, 'TESTING': {'value': 3}, 'UNKNOWN': {'value': 4}, 'DORMANT': {'value': 5}, 'NOT_PRESENT': {'value': 6}, 'LOWER_LAYER_DOWN': {'value': 7}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='enumeration', is_config=False)


  def _get_last_change(self):
    """
    Getter method for last_change, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/last_change (oc-types:timeticks64)

    YANG Description: This timestamp indicates the absolute time of the last
state change of the interface (e.g., up-to-down transition).
This is different than the SNMP ifLastChange object in the
standard interface MIB in that it is not relative to the
system boot time (i.e,. sysUpTime).

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_change
      
  def _set_last_change(self, v, load=False):
    """
    Setter method for last_change, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/last_change (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_change is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_change() directly.

    YANG Description: This timestamp indicates the absolute time of the last
state change of the interface (e.g., up-to-down transition).
This is different than the SNMP ifLastChange object in the
standard interface MIB in that it is not relative to the
system boot time (i.e,. sysUpTime).

The value is the timestamp in nanoseconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_change must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__last_change = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_change(self):
    self.__last_change = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-change", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='oc-types:timeticks64', is_config=False)


  def _get_logical(self):
    """
    Getter method for logical, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/logical (boolean)

    YANG Description: When set to true, the interface is a logical interface
which does not have an associated physical port or
channel on the system.
    """
    return self.__logical
      
  def _set_logical(self, v, load=False):
    """
    Setter method for logical, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/logical (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical() directly.

    YANG Description: When set to true, the interface is a logical interface
which does not have an associated physical port or
channel on the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__logical = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical(self):
    self.__logical = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="logical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_management(self):
    """
    Getter method for management, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/management (boolean)

    YANG Description: When set to true, the interface is a dedicated
management interface that is not connected to dataplane
interfaces.  It may be used to connect the system to an
out-of-band management network, for example.
    """
    return self.__management
      
  def _set_management(self, v, load=False):
    """
    Setter method for management, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/management (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management() directly.

    YANG Description: When set to true, the interface is a dedicated
management interface that is not connected to dataplane
interfaces.  It may be used to connect the system to an
out-of-band management network, for example.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__management = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management(self):
    self.__management = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="management", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/cpu (boolean)

    YANG Description: When set to true, the interface is for traffic
that is handled by the system CPU, sometimes also called the
control plane interface.  On systems that represent the CPU
interface as an Ethernet interface, for example, this leaf
should be used to distinguish the CPU interface from dataplane
interfaces.
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/cpu (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: When set to true, the interface is for traffic
that is handled by the system CPU, sometimes also called the
control plane interface.  On systems that represent the CPU
interface as an Ethernet interface, for example, this leaf
should be used to distinguish the CPU interface from dataplane
interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters (container)

    YANG Description: A collection of interface-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of interface-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  enabled = __builtin__.property(_get_enabled)
  name = __builtin__.property(_get_name)
  ifindex = __builtin__.property(_get_ifindex)
  admin_status = __builtin__.property(_get_admin_status)
  oper_status = __builtin__.property(_get_oper_status)
  last_change = __builtin__.property(_get_last_change)
  logical = __builtin__.property(_get_logical)
  management = __builtin__.property(_get_management)
  cpu = __builtin__.property(_get_cpu)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('enabled', enabled), ('name', name), ('ifindex', ifindex), ('admin_status', admin_status), ('oper_status', oper_status), ('last_change', last_change), ('logical', logical), ('management', management), ('cpu', cpu), ('counters', counters), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'config']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/config/vlan_id (union)

    YANG Description: VLAN id for the subinterface -- specified inline for the
case of a local VLAN.  The id is scoped to the
subinterface, and could be repeated on different
subinterfaces.
Deprecation note: See adjacent elements in the 'vlan' container for
making more expressive VLAN matches.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/config/vlan_id (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: VLAN id for the subinterface -- specified inline for the
case of a local VLAN.  The id is scoped to the
subinterface, and could be repeated on different
subinterfaces.
Deprecation note: See adjacent elements in the 'vlan' container for
making more expressive VLAN matches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State variables for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'state']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/state/vlan_id (union)

    YANG Description: VLAN id for the subinterface -- specified inline for the
case of a local VLAN.  The id is scoped to the
subinterface, and could be repeated on different
subinterfaces.
Deprecation note: See adjacent elements in the 'vlan' container for
making more expressive VLAN matches.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/state/vlan_id (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: VLAN id for the subinterface -- specified inline for the
case of a local VLAN.  The id is scoped to the
subinterface, and could be repeated on different
subinterfaces.
Deprecation note: See adjacent elements in the 'vlan' container for
making more expressive VLAN matches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.((409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])|\\*)'}),], is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

  vlan_id = __builtin__.property(_get_vlan_id)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching single-tagged packets with an exact
VLAN identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged', 'config']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/config/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: VLAN identifier for single-tagged packets.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/config/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: VLAN identifier for single-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching single-tagged packets with an exact VLAN
identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged', 'state']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/state/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: VLAN identifier for single-tagged packets.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/state/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: VLAN identifier for single-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  vlan_id = __builtin__.property(_get_vlan_id)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ])


class yc_single_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match single-tagged packets with an exact VLAN identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'single-tagged'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/config (container)

    YANG Description: Configuration for matching single-tagged packets with an exact
VLAN identifier.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching single-tagged packets with an exact
VLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/state (container)

    YANG Description: State for matching single-tagged packets with an exact VLAN
identifier.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching single-tagged packets with an exact VLAN
identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching single-tagged packets with a list of
VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_ids',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-list', 'config']

  def _get_vlan_ids(self):
    """
    Getter method for vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/config/vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: VLAN identifiers for single-tagged packets.
    """
    return self.__vlan_ids
      
  def _set_vlan_ids(self, v, load=False):
    """
    Setter method for vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/config/vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_ids() directly.

    YANG Description: VLAN identifiers for single-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_ids(self):
    self.__vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  vlan_ids = __builtin__.property(_get_vlan_ids, _set_vlan_ids)


  _pyangbind_elements = OrderedDict([('vlan_ids', vlan_ids), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching single-tagged packets with a list of VLAN
identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_ids',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-list', 'state']

  def _get_vlan_ids(self):
    """
    Getter method for vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/state/vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: VLAN identifiers for single-tagged packets.
    """
    return self.__vlan_ids
      
  def _set_vlan_ids(self, v, load=False):
    """
    Setter method for vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/state/vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_ids() directly.

    YANG Description: VLAN identifiers for single-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_ids(self):
    self.__vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  vlan_ids = __builtin__.property(_get_vlan_ids)


  _pyangbind_elements = OrderedDict([('vlan_ids', vlan_ids), ])


class yc_single_tagged_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match single-tagged packets with a list of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'single-tagged-list'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-list']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/config (container)

    YANG Description: Configuration for matching single-tagged packets with a list of
VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching single-tagged packets with a list of
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/state (container)

    YANG Description: State for matching single-tagged packets with a list of VLAN
identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching single-tagged packets with a list of VLAN
identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching single-tagged packets with a range of
VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__low_vlan_id','__high_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-range', 'config']

  def _get_low_vlan_id(self):
    """
    Getter method for low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config/low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    return self.__low_vlan_id
      
  def _set_low_vlan_id(self, v, load=False):
    """
    Setter method for low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config/low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_low_vlan_id() directly.

    YANG Description: The low-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_low_vlan_id(self):
    self.__low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_high_vlan_id(self):
    """
    Getter method for high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config/high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    return self.__high_vlan_id
      
  def _set_high_vlan_id(self, v, load=False):
    """
    Setter method for high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config/high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_high_vlan_id() directly.

    YANG Description: The high-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_high_vlan_id(self):
    self.__high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  low_vlan_id = __builtin__.property(_get_low_vlan_id, _set_low_vlan_id)
  high_vlan_id = __builtin__.property(_get_high_vlan_id, _set_high_vlan_id)


  _pyangbind_elements = OrderedDict([('low_vlan_id', low_vlan_id), ('high_vlan_id', high_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching single-tagged packets with a range of VLAN
identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__low_vlan_id','__high_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-range', 'state']

  def _get_low_vlan_id(self):
    """
    Getter method for low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state/low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    return self.__low_vlan_id
      
  def _set_low_vlan_id(self, v, load=False):
    """
    Setter method for low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state/low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_low_vlan_id() directly.

    YANG Description: The low-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_low_vlan_id(self):
    self.__low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_high_vlan_id(self):
    """
    Getter method for high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state/high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    return self.__high_vlan_id
      
  def _set_high_vlan_id(self, v, load=False):
    """
    Setter method for high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state/high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_high_vlan_id() directly.

    YANG Description: The high-value VLAN identifier in a range for single-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_high_vlan_id(self):
    self.__high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  low_vlan_id = __builtin__.property(_get_low_vlan_id)
  high_vlan_id = __builtin__.property(_get_high_vlan_id)


  _pyangbind_elements = OrderedDict([('low_vlan_id', low_vlan_id), ('high_vlan_id', high_vlan_id), ])


class yc_single_tagged_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match single-tagged packets with a range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'single-tagged-range'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'single-tagged-range']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config (container)

    YANG Description: Configuration for matching single-tagged packets with a range of
VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching single-tagged packets with a range of
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state (container)

    YANG Description: State for matching single-tagged packets with a range of VLAN
identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching single-tagged packets with a range of VLAN
identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against inner
exact and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged', 'config']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id, _set_inner_vlan_id)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id, _set_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_vlan_id', outer_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against inner exact
and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged', 'state']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_vlan_id', outer_vlan_id), ])


class yc_double_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against inner exact and outer exact
VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config (container)

    YANG Description: Configuration for matching double-tagged packets against inner
exact and outer exact VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against inner
exact and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state (container)

    YANG Description: State for matching double-tagged packets against inner exact
and outer exact VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against inner exact
and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against an
inner list and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_ids','__outer_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-list', 'config']

  def _get_inner_vlan_ids(self):
    """
    Getter method for inner_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config/inner_vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifiers for double-tagged packets.
    """
    return self.__inner_vlan_ids
      
  def _set_inner_vlan_ids(self, v, load=False):
    """
    Setter method for inner_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config/inner_vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_ids() directly.

    YANG Description: Inner VLAN identifiers for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_ids(self):
    self.__inner_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_vlan_ids = __builtin__.property(_get_inner_vlan_ids, _set_inner_vlan_ids)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id, _set_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_ids', inner_vlan_ids), ('outer_vlan_id', outer_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against an inner list
and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_ids','__outer_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-list', 'state']

  def _get_inner_vlan_ids(self):
    """
    Getter method for inner_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state/inner_vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifiers for double-tagged packets.
    """
    return self.__inner_vlan_ids
      
  def _set_inner_vlan_ids(self, v, load=False):
    """
    Setter method for inner_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state/inner_vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_ids() directly.

    YANG Description: Inner VLAN identifiers for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_ids(self):
    self.__inner_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="inner-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_vlan_ids = __builtin__.property(_get_inner_vlan_ids)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_ids', inner_vlan_ids), ('outer_vlan_id', outer_vlan_id), ])


class yc_double_tagged_inner_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against an inner list and outer exact
VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged-inner-list'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-list']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config (container)

    YANG Description: Configuration for matching double-tagged packets against an
inner list and outer exact VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against an
inner list and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state (container)

    YANG Description: State for matching double-tagged packets against an inner list
and outer exact VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against an inner list
and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against an
inner exact and outer list of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_vlan_ids',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-list', 'config']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_vlan_ids(self):
    """
    Getter method for outer_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config/outer_vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifiers for double-tagged packets.
    """
    return self.__outer_vlan_ids
      
  def _set_outer_vlan_ids(self, v, load=False):
    """
    Setter method for outer_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config/outer_vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_ids() directly.

    YANG Description: Outer VLAN identifiers for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_ids(self):
    self.__outer_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id, _set_inner_vlan_id)
  outer_vlan_ids = __builtin__.property(_get_outer_vlan_ids, _set_outer_vlan_ids)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_vlan_ids', outer_vlan_ids), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against an inner
exact and outer list of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_vlan_ids',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-list', 'state']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_vlan_ids(self):
    """
    Getter method for outer_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state/outer_vlan_ids (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifiers for double-tagged packets.
    """
    return self.__outer_vlan_ids
      
  def _set_outer_vlan_ids(self, v, load=False):
    """
    Setter method for outer_vlan_ids, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state/outer_vlan_ids (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_ids() directly.

    YANG Description: Outer VLAN identifiers for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_ids must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_vlan_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_ids(self):
    self.__outer_vlan_ids = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id)
  outer_vlan_ids = __builtin__.property(_get_outer_vlan_ids)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_vlan_ids', outer_vlan_ids), ])


class yc_double_tagged_outer_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against an inner exact and outer list
of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged-outer-list'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-list']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config (container)

    YANG Description: Configuration for matching double-tagged packets against an
inner exact and outer list of VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against an
inner exact and outer list of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state (container)

    YANG Description: State for matching double-tagged packets against an inner
exact and outer list of VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against an inner
exact and outer list of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against an
inner range and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_low_vlan_id','__inner_high_vlan_id','__outer_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_vlan_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-range', 'config']

  def _get_inner_low_vlan_id(self):
    """
    Getter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/inner_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_low_vlan_id
      
  def _set_inner_low_vlan_id(self, v, load=False):
    """
    Setter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/inner_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_low_vlan_id() directly.

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_low_vlan_id(self):
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_inner_high_vlan_id(self):
    """
    Getter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/inner_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_high_vlan_id
      
  def _set_inner_high_vlan_id(self, v, load=False):
    """
    Setter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/inner_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_high_vlan_id() directly.

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_high_vlan_id(self):
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier of double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier of double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_low_vlan_id = __builtin__.property(_get_inner_low_vlan_id, _set_inner_low_vlan_id)
  inner_high_vlan_id = __builtin__.property(_get_inner_high_vlan_id, _set_inner_high_vlan_id)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id, _set_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_low_vlan_id', inner_low_vlan_id), ('inner_high_vlan_id', inner_high_vlan_id), ('outer_vlan_id', outer_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against an inner
range and outer exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_low_vlan_id','__inner_high_vlan_id','__outer_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_vlan_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-range', 'state']

  def _get_inner_low_vlan_id(self):
    """
    Getter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/inner_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_low_vlan_id
      
  def _set_inner_low_vlan_id(self, v, load=False):
    """
    Setter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/inner_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_low_vlan_id() directly.

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_low_vlan_id(self):
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_inner_high_vlan_id(self):
    """
    Getter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/inner_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_high_vlan_id
      
  def _set_inner_high_vlan_id(self, v, load=False):
    """
    Setter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/inner_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_high_vlan_id() directly.

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_high_vlan_id(self):
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_vlan_id(self):
    """
    Getter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/outer_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Outer VLAN identifier of double-tagged packets.
    """
    return self.__outer_vlan_id
      
  def _set_outer_vlan_id(self, v, load=False):
    """
    Setter method for outer_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state/outer_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_vlan_id() directly.

    YANG Description: Outer VLAN identifier of double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_vlan_id(self):
    self.__outer_vlan_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']})), is_leaf=False, yang_name="outer-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_low_vlan_id = __builtin__.property(_get_inner_low_vlan_id)
  inner_high_vlan_id = __builtin__.property(_get_inner_high_vlan_id)
  outer_vlan_id = __builtin__.property(_get_outer_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_low_vlan_id', inner_low_vlan_id), ('inner_high_vlan_id', inner_high_vlan_id), ('outer_vlan_id', outer_vlan_id), ])


class yc_double_tagged_inner_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against an inner range and outer
exact VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged-inner-range'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-range']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config (container)

    YANG Description: Configuration for matching double-tagged packets against an
inner range and outer exact VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against an
inner range and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state (container)

    YANG Description: State for matching double-tagged packets against an inner
range and outer exact VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against an inner
range and outer exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against an
inner exact and an outer range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_low_vlan_id','__outer_high_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-range', 'config']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_low_vlan_id(self):
    """
    Getter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/outer_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_low_vlan_id
      
  def _set_outer_low_vlan_id(self, v, load=False):
    """
    Setter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/outer_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_low_vlan_id() directly.

    YANG Description: The low-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_low_vlan_id(self):
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_high_vlan_id(self):
    """
    Getter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/outer_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_high_vlan_id
      
  def _set_outer_high_vlan_id(self, v, load=False):
    """
    Setter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config/outer_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_high_vlan_id() directly.

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_high_vlan_id(self):
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id, _set_inner_vlan_id)
  outer_low_vlan_id = __builtin__.property(_get_outer_low_vlan_id, _set_outer_low_vlan_id)
  outer_high_vlan_id = __builtin__.property(_get_outer_high_vlan_id, _set_outer_high_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_low_vlan_id', outer_low_vlan_id), ('outer_high_vlan_id', outer_high_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against an inner
exact and an outer range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_vlan_id','__outer_low_vlan_id','__outer_high_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-range', 'state']

  def _get_inner_vlan_id(self):
    """
    Getter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/inner_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    return self.__inner_vlan_id
      
  def _set_inner_vlan_id(self, v, load=False):
    """
    Setter method for inner_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/inner_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan_id() directly.

    YANG Description: Inner VLAN identifier for double-tagged packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan_id(self):
    self.__inner_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_low_vlan_id(self):
    """
    Getter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/outer_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_low_vlan_id
      
  def _set_outer_low_vlan_id(self, v, load=False):
    """
    Setter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/outer_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_low_vlan_id() directly.

    YANG Description: The low-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_low_vlan_id(self):
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_high_vlan_id(self):
    """
    Getter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/outer_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_high_vlan_id
      
  def _set_outer_high_vlan_id(self, v, load=False):
    """
    Setter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state/outer_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_high_vlan_id() directly.

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_high_vlan_id(self):
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_vlan_id = __builtin__.property(_get_inner_vlan_id)
  outer_low_vlan_id = __builtin__.property(_get_outer_low_vlan_id)
  outer_high_vlan_id = __builtin__.property(_get_outer_high_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_vlan_id', inner_vlan_id), ('outer_low_vlan_id', outer_low_vlan_id), ('outer_high_vlan_id', outer_high_vlan_id), ])


class yc_double_tagged_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against an inner exact and an outer
range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged-outer-range'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-outer-range']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config (container)

    YANG Description: Configuration for matching double-tagged packets against an
inner exact and an outer range of VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against an
inner exact and an outer range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state (container)

    YANG Description: State for matching double-tagged packets against an inner
exact and an outer range of VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against an inner
exact and an outer range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for matching double-tagged packets against an
inner range and an outer range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_low_vlan_id','__inner_high_vlan_id','__outer_low_vlan_id','__outer_high_vlan_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-outer-range', 'config']

  def _get_inner_low_vlan_id(self):
    """
    Getter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/inner_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_low_vlan_id
      
  def _set_inner_low_vlan_id(self, v, load=False):
    """
    Setter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/inner_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_low_vlan_id() directly.

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_low_vlan_id(self):
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_inner_high_vlan_id(self):
    """
    Getter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/inner_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_high_vlan_id
      
  def _set_inner_high_vlan_id(self, v, load=False):
    """
    Setter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/inner_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_high_vlan_id() directly.

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__inner_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_high_vlan_id(self):
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_low_vlan_id(self):
    """
    Getter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/outer_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value outer VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__outer_low_vlan_id
      
  def _set_outer_low_vlan_id(self, v, load=False):
    """
    Setter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/outer_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_low_vlan_id() directly.

    YANG Description: The low-value outer VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_low_vlan_id(self):
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_outer_high_vlan_id(self):
    """
    Getter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/outer_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_high_vlan_id
      
  def _set_outer_high_vlan_id(self, v, load=False):
    """
    Setter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config/outer_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_high_vlan_id() directly.

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__outer_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_high_vlan_id(self):
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)

  inner_low_vlan_id = __builtin__.property(_get_inner_low_vlan_id, _set_inner_low_vlan_id)
  inner_high_vlan_id = __builtin__.property(_get_inner_high_vlan_id, _set_inner_high_vlan_id)
  outer_low_vlan_id = __builtin__.property(_get_outer_low_vlan_id, _set_outer_low_vlan_id)
  outer_high_vlan_id = __builtin__.property(_get_outer_high_vlan_id, _set_outer_high_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_low_vlan_id', inner_low_vlan_id), ('inner_high_vlan_id', inner_high_vlan_id), ('outer_low_vlan_id', outer_low_vlan_id), ('outer_high_vlan_id', outer_high_vlan_id), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for matching double-tagged packets against an inner
range and an outer range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__inner_low_vlan_id','__inner_high_vlan_id','__outer_low_vlan_id','__outer_high_vlan_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-outer-range', 'state']

  def _get_inner_low_vlan_id(self):
    """
    Getter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/inner_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_low_vlan_id
      
  def _set_inner_low_vlan_id(self, v, load=False):
    """
    Setter method for inner_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/inner_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_low_vlan_id() directly.

    YANG Description: The low-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_low_vlan_id(self):
    self.__inner_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_inner_high_vlan_id(self):
    """
    Getter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/inner_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__inner_high_vlan_id
      
  def _set_inner_high_vlan_id(self, v, load=False):
    """
    Setter method for inner_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/inner_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_high_vlan_id() directly.

    YANG Description: The high-value inner VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__inner_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_high_vlan_id(self):
    self.__inner_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="inner-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_low_vlan_id(self):
    """
    Getter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/outer_low_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The low-value outer VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    return self.__outer_low_vlan_id
      
  def _set_outer_low_vlan_id(self, v, load=False):
    """
    Setter method for outer_low_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/outer_low_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_low_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_low_vlan_id() directly.

    YANG Description: The low-value outer VLAN identifier in a range for double-tagged
packets. The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_low_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_low_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_low_vlan_id(self):
    self.__outer_low_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-low-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_outer_high_vlan_id(self):
    """
    Getter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/outer_high_vlan_id (oc-vlan-types:vlan-id)

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    return self.__outer_high_vlan_id
      
  def _set_outer_high_vlan_id(self, v, load=False):
    """
    Setter method for outer_high_vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state/outer_high_vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_high_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_high_vlan_id() directly.

    YANG Description: The high-value outer VLAN identifier for double-tagged packets.
The range is matched inclusively.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_high_vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__outer_high_vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_high_vlan_id(self):
    self.__outer_high_vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="outer-high-vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)

  inner_low_vlan_id = __builtin__.property(_get_inner_low_vlan_id)
  inner_high_vlan_id = __builtin__.property(_get_inner_high_vlan_id)
  outer_low_vlan_id = __builtin__.property(_get_outer_low_vlan_id)
  outer_high_vlan_id = __builtin__.property(_get_outer_high_vlan_id)


  _pyangbind_elements = OrderedDict([('inner_low_vlan_id', inner_low_vlan_id), ('inner_high_vlan_id', inner_high_vlan_id), ('outer_low_vlan_id', outer_low_vlan_id), ('outer_high_vlan_id', outer_high_vlan_id), ])


class yc_double_tagged_inner_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Match double-tagged packets against an inner range and an outer
range of VLAN identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'double-tagged-inner-outer-range'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match', 'double-tagged-inner-outer-range']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config (container)

    YANG Description: Configuration for matching double-tagged packets against an
inner range and an outer range of VLAN identifiers.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for matching double-tagged packets against an
inner range and an outer range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state (container)

    YANG Description: State for matching double-tagged packets against an inner
range and an outer range of VLAN identifiers.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for matching double-tagged packets against an inner
range and an outer range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_match_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for various VLAN tag matching schemes,
including single-tagged 802.1q packets and double-tagged
802.1ad 'Q-in-Q' packets. Typically only one of the subordinate
containers should be specified.

Wildcards may be matched by specifying range values of 2-4094.
If implementations have a more efficient way to match Wildcards
then they should recognize this pattern and translate accordingly.

Implementations are expected to return errors for combinations
that they do not support, or provide deviations to the same effect.

For simple VLAN configurations without an 'egress-mapping' then
using the 'single-tagged' and 'double-tagged' VLAN matches that
resolve to specific values, these specify the VLAN identifiers
applied to packets on egress.
  """
  __slots__ = ('_path_helper', '_extmethods', '__single_tagged','__single_tagged_list','__single_tagged_range','__double_tagged','__double_tagged_inner_list','__double_tagged_outer_list','__double_tagged_inner_range','__double_tagged_outer_range','__double_tagged_inner_outer_range',)

  _yang_name = 'match'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__single_tagged = YANGDynClass(base=yc_single_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__single_tagged_list = YANGDynClass(base=yc_single_tagged_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__single_tagged_range = YANGDynClass(base=yc_single_tagged_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged = YANGDynClass(base=yc_double_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_list = YANGDynClass(base=yc_double_tagged_inner_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_outer_list = YANGDynClass(base=yc_double_tagged_outer_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_range = YANGDynClass(base=yc_double_tagged_inner_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_outer_range = YANGDynClass(base=yc_double_tagged_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_outer_range = YANGDynClass(base=yc_double_tagged_inner_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match']

  def _get_single_tagged(self):
    """
    Getter method for single_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged (container)

    YANG Description: Match single-tagged packets with an exact VLAN identifier.
    """
    return self.__single_tagged
      
  def _set_single_tagged(self, v, load=False):
    """
    Setter method for single_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged() directly.

    YANG Description: Match single-tagged packets with an exact VLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_single_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_single_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged(self):
    self.__single_tagged = YANGDynClass(base=yc_single_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_single_tagged_list(self):
    """
    Getter method for single_tagged_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list (container)

    YANG Description: Match single-tagged packets with a list of VLAN identifiers.
    """
    return self.__single_tagged_list
      
  def _set_single_tagged_list(self, v, load=False):
    """
    Setter method for single_tagged_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged_list() directly.

    YANG Description: Match single-tagged packets with a list of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_single_tagged_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_single_tagged_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged_list(self):
    self.__single_tagged_list = YANGDynClass(base=yc_single_tagged_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_single_tagged_range(self):
    """
    Getter method for single_tagged_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range (container)

    YANG Description: Match single-tagged packets with a range of VLAN identifiers.
    """
    return self.__single_tagged_range
      
  def _set_single_tagged_range(self, v, load=False):
    """
    Setter method for single_tagged_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged_range() directly.

    YANG Description: Match single-tagged packets with a range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_single_tagged_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_single_tagged_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged_range(self):
    self.__single_tagged_range = YANGDynClass(base=yc_single_tagged_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged(self):
    """
    Getter method for double_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged (container)

    YANG Description: Match double-tagged packets against inner exact and outer exact
VLAN identifiers.
    """
    return self.__double_tagged
      
  def _set_double_tagged(self, v, load=False):
    """
    Setter method for double_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged() directly.

    YANG Description: Match double-tagged packets against inner exact and outer exact
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged(self):
    self.__double_tagged = YANGDynClass(base=yc_double_tagged_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_list(self):
    """
    Getter method for double_tagged_inner_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list (container)

    YANG Description: Match double-tagged packets against an inner list and outer exact
VLAN identifiers.
    """
    return self.__double_tagged_inner_list
      
  def _set_double_tagged_inner_list(self, v, load=False):
    """
    Setter method for double_tagged_inner_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_list() directly.

    YANG Description: Match double-tagged packets against an inner list and outer exact
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_inner_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_inner_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_list(self):
    self.__double_tagged_inner_list = YANGDynClass(base=yc_double_tagged_inner_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_outer_list(self):
    """
    Getter method for double_tagged_outer_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list (container)

    YANG Description: Match double-tagged packets against an inner exact and outer list
of VLAN identifiers.
    """
    return self.__double_tagged_outer_list
      
  def _set_double_tagged_outer_list(self, v, load=False):
    """
    Setter method for double_tagged_outer_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_outer_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_outer_list() directly.

    YANG Description: Match double-tagged packets against an inner exact and outer list
of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_outer_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_outer_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_outer_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_outer_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_outer_list(self):
    self.__double_tagged_outer_list = YANGDynClass(base=yc_double_tagged_outer_list_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_range(self):
    """
    Getter method for double_tagged_inner_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range (container)

    YANG Description: Match double-tagged packets against an inner range and outer
exact VLAN identifiers.
    """
    return self.__double_tagged_inner_range
      
  def _set_double_tagged_inner_range(self, v, load=False):
    """
    Setter method for double_tagged_inner_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_range() directly.

    YANG Description: Match double-tagged packets against an inner range and outer
exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_inner_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_inner_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_range(self):
    self.__double_tagged_inner_range = YANGDynClass(base=yc_double_tagged_inner_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_outer_range(self):
    """
    Getter method for double_tagged_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range (container)

    YANG Description: Match double-tagged packets against an inner exact and an outer
range of VLAN identifiers.
    """
    return self.__double_tagged_outer_range
      
  def _set_double_tagged_outer_range(self, v, load=False):
    """
    Setter method for double_tagged_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_outer_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_outer_range() directly.

    YANG Description: Match double-tagged packets against an inner exact and an outer
range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_outer_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_outer_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_outer_range(self):
    self.__double_tagged_outer_range = YANGDynClass(base=yc_double_tagged_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_outer_range(self):
    """
    Getter method for double_tagged_inner_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range (container)

    YANG Description: Match double-tagged packets against an inner range and an outer
range of VLAN identifiers.
    """
    return self.__double_tagged_inner_outer_range
      
  def _set_double_tagged_inner_outer_range(self, v, load=False):
    """
    Setter method for double_tagged_inner_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_outer_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_outer_range() directly.

    YANG Description: Match double-tagged packets against an inner range and an outer
range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_double_tagged_inner_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_outer_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_double_tagged_inner_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_outer_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_outer_range(self):
    self.__double_tagged_inner_outer_range = YANGDynClass(base=yc_double_tagged_inner_outer_range_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match_double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  single_tagged = __builtin__.property(_get_single_tagged, _set_single_tagged)
  single_tagged_list = __builtin__.property(_get_single_tagged_list, _set_single_tagged_list)
  single_tagged_range = __builtin__.property(_get_single_tagged_range, _set_single_tagged_range)
  double_tagged = __builtin__.property(_get_double_tagged, _set_double_tagged)
  double_tagged_inner_list = __builtin__.property(_get_double_tagged_inner_list, _set_double_tagged_inner_list)
  double_tagged_outer_list = __builtin__.property(_get_double_tagged_outer_list, _set_double_tagged_outer_list)
  double_tagged_inner_range = __builtin__.property(_get_double_tagged_inner_range, _set_double_tagged_inner_range)
  double_tagged_outer_range = __builtin__.property(_get_double_tagged_outer_range, _set_double_tagged_outer_range)
  double_tagged_inner_outer_range = __builtin__.property(_get_double_tagged_inner_outer_range, _set_double_tagged_inner_outer_range)


  _pyangbind_elements = OrderedDict([('single_tagged', single_tagged), ('single_tagged_list', single_tagged_list), ('single_tagged_range', single_tagged_range), ('double_tagged', double_tagged), ('double_tagged_inner_list', double_tagged_inner_list), ('double_tagged_outer_list', double_tagged_outer_list), ('double_tagged_inner_range', double_tagged_inner_range), ('double_tagged_outer_range', double_tagged_outer_range), ('double_tagged_inner_outer_range', double_tagged_inner_outer_range), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for ingress VLAN and label behaviors for
packets that arrive on this subinterface after their VLAN
identifier(s) have been matched.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_stack_action','__vlan_id','__tpid',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'ingress-mapping', 'config']

  def _get_vlan_stack_action(self):
    """
    Getter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/vlan_stack_action (oc-vlan-types:vlan-stack-action)

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    return self.__vlan_stack_action
      
  def _set_vlan_stack_action(self, v, load=False):
    """
    Setter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/vlan_stack_action (oc-vlan-types:vlan-stack-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_stack_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_stack_action() directly.

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_stack_action must be of a type compatible with oc-vlan-types:vlan-stack-action""",
          'defined-type': "oc-vlan-types:vlan-stack-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)""",
        })

    self.__vlan_stack_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_stack_action(self):
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'PUSH' then this VLAN identifier is added to the the stack.
This value must be non-zero if the 'vlan-stack-action' is one of
'PUSH' or 'SWAP'.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'PUSH' then this VLAN identifier is added to the the stack.
This value must be non-zero if the 'vlan-stack-action' is one of
'PUSH' or 'SWAP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/tpid (identityref)

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)

  vlan_stack_action = __builtin__.property(_get_vlan_stack_action, _set_vlan_stack_action)
  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)
  tpid = __builtin__.property(_get_tpid, _set_tpid)


  _pyangbind_elements = OrderedDict([('vlan_stack_action', vlan_stack_action), ('vlan_id', vlan_id), ('tpid', tpid), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for ingress VLAN and label behaviors for packets
that arrive on this subinterface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_stack_action','__vlan_id','__tpid',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'ingress-mapping', 'state']

  def _get_vlan_stack_action(self):
    """
    Getter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/vlan_stack_action (oc-vlan-types:vlan-stack-action)

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    return self.__vlan_stack_action
      
  def _set_vlan_stack_action(self, v, load=False):
    """
    Setter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/vlan_stack_action (oc-vlan-types:vlan-stack-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_stack_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_stack_action() directly.

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_stack_action must be of a type compatible with oc-vlan-types:vlan-stack-action""",
          'defined-type': "oc-vlan-types:vlan-stack-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)""",
        })

    self.__vlan_stack_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_stack_action(self):
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'PUSH' then this VLAN identifier is added to the the stack.
This value must be non-zero if the 'vlan-stack-action' is one of
'PUSH' or 'SWAP'.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'PUSH' then this VLAN identifier is added to the the stack.
This value must be non-zero if the 'vlan-stack-action' is one of
'PUSH' or 'SWAP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/tpid (identityref)

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)

  vlan_stack_action = __builtin__.property(_get_vlan_stack_action)
  vlan_id = __builtin__.property(_get_vlan_id)
  tpid = __builtin__.property(_get_tpid)


  _pyangbind_elements = OrderedDict([('vlan_stack_action', vlan_stack_action), ('vlan_id', vlan_id), ('tpid', tpid), ])


class yc_ingress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Ingress VLAN stack behaviors for packets that arrive on
this subinterface after their VLAN idenitifer(s) have been
matched.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'ingress-mapping'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'ingress-mapping']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config (container)

    YANG Description: Configuration for ingress VLAN and label behaviors for
packets that arrive on this subinterface after their VLAN
identifier(s) have been matched.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for ingress VLAN and label behaviors for
packets that arrive on this subinterface after their VLAN
identifier(s) have been matched.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state (container)

    YANG Description: State for ingress VLAN and label behaviors for packets
that arrive on this subinterface.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for ingress VLAN and label behaviors for packets
that arrive on this subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for egress VLAN stack behaviors for
packets that are destined for output via this subinterface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_stack_action','__vlan_id','__tpid',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'egress-mapping', 'config']

  def _get_vlan_stack_action(self):
    """
    Getter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/vlan_stack_action (oc-vlan-types:vlan-stack-action)

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    return self.__vlan_stack_action
      
  def _set_vlan_stack_action(self, v, load=False):
    """
    Setter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/vlan_stack_action (oc-vlan-types:vlan-stack-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_stack_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_stack_action() directly.

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_stack_action must be of a type compatible with oc-vlan-types:vlan-stack-action""",
          'defined-type': "oc-vlan-types:vlan-stack-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)""",
        })

    self.__vlan_stack_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_stack_action(self):
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=True)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'POP' then a VLAN identifier is removed from the stack but the
value of this leaf is used instead. This value must be non-zero if
the 'vlan-stack-action' is one of 'PUSH' or 'SWAP'.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'POP' then a VLAN identifier is removed from the stack but the
value of this leaf is used instead. This value must be non-zero if
the 'vlan-stack-action' is one of 'PUSH' or 'SWAP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/tpid (identityref)

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=True)

  vlan_stack_action = __builtin__.property(_get_vlan_stack_action, _set_vlan_stack_action)
  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)
  tpid = __builtin__.property(_get_tpid, _set_tpid)


  _pyangbind_elements = OrderedDict([('vlan_stack_action', vlan_stack_action), ('vlan_id', vlan_id), ('tpid', tpid), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State for engress VLAN stack behaviors for packets
that are destined for output via this subinterface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_stack_action','__vlan_id','__tpid',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'egress-mapping', 'state']

  def _get_vlan_stack_action(self):
    """
    Getter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/vlan_stack_action (oc-vlan-types:vlan-stack-action)

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    return self.__vlan_stack_action
      
  def _set_vlan_stack_action(self, v, load=False):
    """
    Setter method for vlan_stack_action, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/vlan_stack_action (oc-vlan-types:vlan-stack-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_stack_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_stack_action() directly.

    YANG Description: The action to take on the VLAN stack of a packet. This is
optionally used in conjunction with adjacent leaves to override
the values of the action.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_stack_action must be of a type compatible with oc-vlan-types:vlan-stack-action""",
          'defined-type': "oc-vlan-types:vlan-stack-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)""",
        })

    self.__vlan_stack_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_stack_action(self):
    self.__vlan_stack_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PUSH': {}, 'POP': {}, 'SWAP': {}},), is_leaf=True, yang_name="vlan-stack-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-stack-action', is_config=False)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'POP' then a VLAN identifier is removed from the stack but the
value of this leaf is used instead. This value must be non-zero if
the 'vlan-stack-action' is one of 'PUSH' or 'SWAP'.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optionally specifies a fixed VLAN identifier that is used by the
action configured in 'vlan-stack-action'. For example, if the action
is 'POP' then a VLAN identifier is removed from the stack but the
value of this leaf is used instead. This value must be non-zero if
the 'vlan-stack-action' is one of 'PUSH' or 'SWAP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_tpid(self):
    """
    Getter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/tpid (identityref)

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    return self.__tpid
      
  def _set_tpid(self, v, load=False):
    """
    Setter method for tpid, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state/tpid (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tpid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tpid() directly.

    YANG Description: Optionally override the tag protocol identifier field (TPID) that
is used by the action configured by 'vlan-stack-action' when
modifying the VLAN stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tpid must be of a type compatible with identityref""",
          'defined-type': "openconfig-vlan:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)""",
        })

    self.__tpid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tpid(self):
    self.__tpid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X8100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X88A8': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9100': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_0X9200': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}, 'oc-vlan-types:TPID_ANY': {'@module': 'openconfig-vlan-types', '@namespace': 'http://openconfig.net/yang/vlan-types'}},), is_leaf=True, yang_name="tpid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='identityref', is_config=False)

  vlan_stack_action = __builtin__.property(_get_vlan_stack_action)
  vlan_id = __builtin__.property(_get_vlan_id)
  tpid = __builtin__.property(_get_tpid)


  _pyangbind_elements = OrderedDict([('vlan_stack_action', vlan_stack_action), ('vlan_id', vlan_id), ('tpid', tpid), ])


class yc_egress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Egress VLAN and label behaviors for packets that are
destined for output via this subinterface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'egress-mapping'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'egress-mapping']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config (container)

    YANG Description: Configuration for egress VLAN stack behaviors for
packets that are destined for output via this subinterface.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration for egress VLAN stack behaviors for
packets that are destined for output via this subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state (container)

    YANG Description: State for engress VLAN stack behaviors for packets
that are destined for output via this subinterface.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State for engress VLAN stack behaviors for packets
that are destined for output via this subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_vlan_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VLAN interface-specific
data on subinterfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__match','__ingress_mapping','__egress_mapping',)

  _yang_name = 'vlan'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__match = YANGDynClass(base=yc_match_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__ingress_mapping = YANGDynClass(base=yc_ingress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping, is_container='container', yang_name="ingress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__egress_mapping = YANGDynClass(base=yc_egress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping, is_container='container', yang_name="egress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/config (container)

    YANG Description: Configuration parameters for VLANs
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/state (container)

    YANG Description: State variables for VLANs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State variables for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_match(self):
    """
    Getter method for match, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match (container)

    YANG Description: Configuration for various VLAN tag matching schemes,
including single-tagged 802.1q packets and double-tagged
802.1ad 'Q-in-Q' packets. Typically only one of the subordinate
containers should be specified.

Wildcards may be matched by specifying range values of 2-4094.
If implementations have a more efficient way to match Wildcards
then they should recognize this pattern and translate accordingly.

Implementations are expected to return errors for combinations
that they do not support, or provide deviations to the same effect.

For simple VLAN configurations without an 'egress-mapping' then
using the 'single-tagged' and 'double-tagged' VLAN matches that
resolve to specific values, these specify the VLAN identifiers
applied to packets on egress.
    """
    return self.__match
      
  def _set_match(self, v, load=False):
    """
    Setter method for match, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match() directly.

    YANG Description: Configuration for various VLAN tag matching schemes,
including single-tagged 802.1q packets and double-tagged
802.1ad 'Q-in-Q' packets. Typically only one of the subordinate
containers should be specified.

Wildcards may be matched by specifying range values of 2-4094.
If implementations have a more efficient way to match Wildcards
then they should recognize this pattern and translate accordingly.

Implementations are expected to return errors for combinations
that they do not support, or provide deviations to the same effect.

For simple VLAN configurations without an 'egress-mapping' then
using the 'single-tagged' and 'double-tagged' VLAN matches that
resolve to specific values, these specify the VLAN identifiers
applied to packets on egress.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_match_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_match_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match(self):
    self.__match = YANGDynClass(base=yc_match_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_ingress_mapping(self):
    """
    Getter method for ingress_mapping, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping (container)

    YANG Description: Ingress VLAN stack behaviors for packets that arrive on
this subinterface after their VLAN idenitifer(s) have been
matched.
    """
    return self.__ingress_mapping
      
  def _set_ingress_mapping(self, v, load=False):
    """
    Setter method for ingress_mapping, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/ingress_mapping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_mapping() directly.

    YANG Description: Ingress VLAN stack behaviors for packets that arrive on
this subinterface after their VLAN idenitifer(s) have been
matched.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ingress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping, is_container='container', yang_name="ingress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_mapping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ingress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping, is_container='container', yang_name="ingress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__ingress_mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_mapping(self):
    self.__ingress_mapping = YANGDynClass(base=yc_ingress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_ingress_mapping, is_container='container', yang_name="ingress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_egress_mapping(self):
    """
    Getter method for egress_mapping, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping (container)

    YANG Description: Egress VLAN and label behaviors for packets that are
destined for output via this subinterface.
    """
    return self.__egress_mapping
      
  def _set_egress_mapping(self, v, load=False):
    """
    Setter method for egress_mapping, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/egress_mapping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_mapping() directly.

    YANG Description: Egress VLAN and label behaviors for packets that are
destined for output via this subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_egress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping, is_container='container', yang_name="egress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_mapping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_egress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping, is_container='container', yang_name="egress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__egress_mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_mapping(self):
    self.__egress_mapping = YANGDynClass(base=yc_egress_mapping_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan_egress_mapping, is_container='container', yang_name="egress-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  match = __builtin__.property(_get_match, _set_match)
  ingress_mapping = __builtin__.property(_get_ingress_mapping, _set_ingress_mapping)
  egress_mapping = __builtin__.property(_get_egress_mapping, _set_egress_mapping)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('match', match), ('ingress_mapping', ingress_mapping), ('egress_mapping', egress_mapping), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-ip:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-ip:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'config']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address, _set_virtual_address)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay, _set_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode, _set_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__current_priority',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'state']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_current_priority(self):
    """
    Getter method for current_priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    return self.__current_priority
      
  def _set_current_priority(self, v, load=False):
    """
    Setter method for current_priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_priority() directly.

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__current_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_priority(self):
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  virtual_router_id = __builtin__.property(_get_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address)
  priority = __builtin__.property(_get_priority)
  preempt = __builtin__.property(_get_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval)
  current_priority = __builtin__.property(_get_current_priority)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('current_priority', current_priority), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'config']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

  track_interface = __builtin__.property(_get_track_interface, _set_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement, _set_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'state']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  track_interface = __builtin__.property(_get_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-tracking'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)

    YANG Description: Configuration data for VRRP interface tracking
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)

    YANG Description: Operational state data for VRRP interface tracking
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VRRP groups, keyed by virtual router id
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__config','__state','__interface_tracking',)

  _yang_name = 'vrrp-group'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config (container)

    YANG Description: Configuration data for the VRRP group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state (container)

    YANG Description: Operational state data for the VRRP group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_tracking(self):
    """
    Getter method for interface_tracking, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking (container)

    YANG Description: Top-level container for VRRP interface tracking
    """
    return self.__interface_tracking
      
  def _set_interface_tracking(self, v, load=False):
    """
    Setter method for interface_tracking, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_tracking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_tracking() directly.

    YANG Description: Top-level container for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_tracking must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_tracking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_tracking(self):
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_tracking = __builtin__.property(_get_interface_tracking, _set_interface_tracking)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('config', config), ('state', state), ('interface_tracking', interface_tracking), ])


class yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VRRP groups handled by this
IP interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrrp_group',)

  _yang_name = 'vrrp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address', 'vrrp']

  def _get_vrrp_group(self):
    """
    Getter method for vrrp_group, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group (list)

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    return self.__vrrp_group
      
  def _set_vrrp_group(self, v, load=False):
    """
    Setter method for vrrp_group, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_group() directly.

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__vrrp_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_group(self):
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  vrrp_group = __builtin__.property(_get_vrrp_group, _set_vrrp_group)


  _pyangbind_elements = OrderedDict([('vrrp_group', vrrp_group), ])


class yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv4 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state','__vrrp',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp (container)

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ('vrrp', vrrp), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address (list)

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'proxy-arp', 'config']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/config/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/config/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'proxy-arp', 'state']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/state/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/state/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  mode = __builtin__.property(_get_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_proxy_arp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'proxy-arp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'proxy-arp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/config (container)

    YANG Description: Configuration parameters for proxy ARP
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/state (container)

    YANG Description: Operational state parameters for proxy ARP
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for neighbor list
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor (list)

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level IPv4 configuration data for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level IPv4 operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_ipv4_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv4 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__proxy_arp','__neighbors','__unnumbered','__config','__state',)

  _yang_name = 'ipv4'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv4']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_proxy_arp(self):
    """
    Getter method for proxy_arp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp (container)

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    return self.__proxy_arp
      
  def _set_proxy_arp(self, v, load=False):
    """
    Setter method for proxy_arp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/proxy_arp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy_arp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy_arp() directly.

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy_arp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__proxy_arp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy_arp(self):
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors (container)

    YANG Description: Enclosing container for neighbor list
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for neighbor list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config (container)

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state (container)

    YANG Description: Top level IPv4 operational state data
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level IPv4 operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  proxy_arp = __builtin__.property(_get_proxy_arp, _set_proxy_arp)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('proxy_arp', proxy_arp), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin','__status',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/status (enumeration)

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ('status', status), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__virtual_link_local',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'config']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_virtual_link_local(self):
    """
    Getter method for virtual_link_local, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_link_local (oc-inet:ip-address)

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    return self.__virtual_link_local
      
  def _set_virtual_link_local(self, v, load=False):
    """
    Setter method for virtual_link_local, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_link_local (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_local() directly.

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_link_local must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_link_local(self):
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address, _set_virtual_address)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay, _set_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode, _set_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)
  virtual_link_local = __builtin__.property(_get_virtual_link_local, _set_virtual_link_local)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('virtual_link_local', virtual_link_local), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__current_priority','__virtual_link_local',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'state']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_current_priority(self):
    """
    Getter method for current_priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    return self.__current_priority
      
  def _set_current_priority(self, v, load=False):
    """
    Setter method for current_priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_priority() directly.

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__current_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_priority(self):
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_link_local(self):
    """
    Getter method for virtual_link_local, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_link_local (oc-inet:ip-address)

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    return self.__virtual_link_local
      
  def _set_virtual_link_local(self, v, load=False):
    """
    Setter method for virtual_link_local, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_link_local (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_local() directly.

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_link_local must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_link_local(self):
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)

  virtual_router_id = __builtin__.property(_get_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address)
  priority = __builtin__.property(_get_priority)
  preempt = __builtin__.property(_get_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval)
  current_priority = __builtin__.property(_get_current_priority)
  virtual_link_local = __builtin__.property(_get_virtual_link_local)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('current_priority', current_priority), ('virtual_link_local', virtual_link_local), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'config']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

  track_interface = __builtin__.property(_get_track_interface, _set_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement, _set_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'state']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  track_interface = __builtin__.property(_get_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-tracking'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)

    YANG Description: Configuration data for VRRP interface tracking
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)

    YANG Description: Operational state data for VRRP interface tracking
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VRRP groups, keyed by virtual router id
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__config','__state','__interface_tracking',)

  _yang_name = 'vrrp-group'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config (container)

    YANG Description: Configuration data for the VRRP group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state (container)

    YANG Description: Operational state data for the VRRP group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_tracking(self):
    """
    Getter method for interface_tracking, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking (container)

    YANG Description: Top-level container for VRRP interface tracking
    """
    return self.__interface_tracking
      
  def _set_interface_tracking(self, v, load=False):
    """
    Setter method for interface_tracking, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_tracking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_tracking() directly.

    YANG Description: Top-level container for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_tracking must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_tracking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_tracking(self):
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_tracking = __builtin__.property(_get_interface_tracking, _set_interface_tracking)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('config', config), ('state', state), ('interface_tracking', interface_tracking), ])


class yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VRRP groups handled by this
IP interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrrp_group',)

  _yang_name = 'vrrp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address', 'vrrp']

  def _get_vrrp_group(self):
    """
    Getter method for vrrp_group, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group (list)

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    return self.__vrrp_group
      
  def _set_vrrp_group(self, v, load=False):
    """
    Setter method for vrrp_group, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_group() directly.

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__vrrp_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_group(self):
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  vrrp_group = __builtin__.property(_get_vrrp_group, _set_vrrp_group)


  _pyangbind_elements = OrderedDict([('vrrp_group', vrrp_group), ])


class yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv6 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state','__vrrp',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp (container)

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ('vrrp', vrrp), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address (list)

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to router advertisements
for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'config']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  lifetime = __builtin__.property(_get_lifetime, _set_lifetime)
  suppress = __builtin__.property(_get_suppress, _set_suppress)
  managed = __builtin__.property(_get_managed, _set_managed)
  other_config = __builtin__.property(_get_other_config, _set_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to router
advertisements for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'state']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  interval = __builtin__.property(_get_interval)
  lifetime = __builtin__.property(_get_lifetime)
  suppress = __builtin__.property(_get_suppress)
  managed = __builtin__.property(_get_managed)
  other_config = __builtin__.property(_get_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes/prefix/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'config']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime, _set_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime, _set_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement, _set_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration, _set_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink, _set_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes/prefix/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'state']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_prefix_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes/prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__config','__state',)

  _yang_name = 'prefix'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'prefixes', 'prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config (container)

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state (container)

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('config', config), ('state', state), ])


class yc_prefixes_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix',)

  _yang_name = 'prefixes'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'prefixes']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix (list)

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes/prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ])


class yc_router_advertisement_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters relating to
router advertisements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__prefixes',)

  _yang_name = 'router-advertisement'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config (container)

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state (container)

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_prefixes(self):
    """
    Getter method for prefixes, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes (container)

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    return self.__prefixes
      
  def _set_prefixes(self, v, load=False):
    """
    Setter method for prefixes, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/prefixes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixes() directly.

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefixes_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixes(self):
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  prefixes = __builtin__.property(_get_prefixes, _set_prefixes)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('prefixes', prefixes), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin','__is_router','__neighbor_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)


  def _get_is_router(self):
    """
    Getter method for is_router, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/is_router (boolean)

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    return self.__is_router
      
  def _set_is_router(self, v, load=False):
    """
    Setter method for is_router, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/is_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_router() directly.

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_router(self):
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_neighbor_state(self):
    """
    Getter method for neighbor_state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    return self.__neighbor_state
      
  def _set_neighbor_state(self, v, load=False):
    """
    Setter method for neighbor_state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_state() directly.

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__neighbor_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_state(self):
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)
  is_router = __builtin__.property(_get_is_router)
  neighbor_state = __builtin__.property(_get_neighbor_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ('is_router', is_router), ('neighbor_state', neighbor_state), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP neighbor address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP neighbor address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor (list)

    YANG Description: List of IPv6 neighbors
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level config data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits, _set_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level operational state data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: [adapted from IETF IP model RFC 7277]

Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
  """
  __slots__ = ('_path_helper', '_extmethods', '__create_global_addresses','__create_temporary_addresses','__temporary_valid_lifetime','__temporary_preferred_lifetime',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'autoconf', 'config']

  def _get_create_global_addresses(self):
    """
    Getter method for create_global_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/create_global_addresses (boolean)

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates global addresses as
described in RFC 4862.
    """
    return self.__create_global_addresses
      
  def _set_create_global_addresses(self, v, load=False):
    """
    Setter method for create_global_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/create_global_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_global_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_global_addresses() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates global addresses as
described in RFC 4862.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_global_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)""",
        })

    self.__create_global_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_global_addresses(self):
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)


  def _get_create_temporary_addresses(self):
    """
    Getter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/create_temporary_addresses (boolean)

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    return self.__create_temporary_addresses
      
  def _set_create_temporary_addresses(self, v, load=False):
    """
    Setter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/create_temporary_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_temporary_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_temporary_addresses() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_temporary_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)""",
        })

    self.__create_temporary_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_temporary_addresses(self):
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=True)


  def _get_temporary_valid_lifetime(self):
    """
    Getter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/temporary_valid_lifetime (uint32)

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address
is valid.
    """
    return self.__temporary_valid_lifetime
      
  def _set_temporary_valid_lifetime(self, v, load=False):
    """
    Setter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/temporary_valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_valid_lifetime() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address
is valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)""",
        })

    self.__temporary_valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_valid_lifetime(self):
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)


  def _get_temporary_preferred_lifetime(self):
    """
    Getter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/temporary_preferred_lifetime (uint32)

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address is
preferred.
    """
    return self.__temporary_preferred_lifetime
      
  def _set_temporary_preferred_lifetime(self, v, load=False):
    """
    Setter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config/temporary_preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_preferred_lifetime() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address is
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)""",
        })

    self.__temporary_preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_preferred_lifetime(self):
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=True)

  create_global_addresses = __builtin__.property(_get_create_global_addresses, _set_create_global_addresses)
  create_temporary_addresses = __builtin__.property(_get_create_temporary_addresses, _set_create_temporary_addresses)
  temporary_valid_lifetime = __builtin__.property(_get_temporary_valid_lifetime, _set_temporary_valid_lifetime)
  temporary_preferred_lifetime = __builtin__.property(_get_temporary_preferred_lifetime, _set_temporary_preferred_lifetime)


  _pyangbind_elements = OrderedDict([('create_global_addresses', create_global_addresses), ('create_temporary_addresses', create_temporary_addresses), ('temporary_valid_lifetime', temporary_valid_lifetime), ('temporary_preferred_lifetime', temporary_preferred_lifetime), ])


class yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__create_global_addresses','__create_temporary_addresses','__temporary_valid_lifetime','__temporary_preferred_lifetime',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'autoconf', 'state']

  def _get_create_global_addresses(self):
    """
    Getter method for create_global_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/create_global_addresses (boolean)

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates global addresses as
described in RFC 4862.
    """
    return self.__create_global_addresses
      
  def _set_create_global_addresses(self, v, load=False):
    """
    Setter method for create_global_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/create_global_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_global_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_global_addresses() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates global addresses as
described in RFC 4862.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_global_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)""",
        })

    self.__create_global_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_global_addresses(self):
    self.__create_global_addresses = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="create-global-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)


  def _get_create_temporary_addresses(self):
    """
    Getter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/create_temporary_addresses (boolean)

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    return self.__create_temporary_addresses
      
  def _set_create_temporary_addresses(self, v, load=False):
    """
    Setter method for create_temporary_addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/create_temporary_addresses (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_temporary_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_temporary_addresses() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

If enabled, the host creates temporary addresses as
described in RFC 4941.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_temporary_addresses must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)""",
        })

    self.__create_temporary_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_temporary_addresses(self):
    self.__create_temporary_addresses = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="create-temporary-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='boolean', is_config=False)


  def _get_temporary_valid_lifetime(self):
    """
    Getter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/temporary_valid_lifetime (uint32)

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address
is valid.
    """
    return self.__temporary_valid_lifetime
      
  def _set_temporary_valid_lifetime(self, v, load=False):
    """
    Setter method for temporary_valid_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/temporary_valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_valid_lifetime() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address
is valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)""",
        })

    self.__temporary_valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_valid_lifetime(self):
    self.__temporary_valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(604800), is_leaf=True, yang_name="temporary-valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)


  def _get_temporary_preferred_lifetime(self):
    """
    Getter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/temporary_preferred_lifetime (uint32)

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address is
preferred.
    """
    return self.__temporary_preferred_lifetime
      
  def _set_temporary_preferred_lifetime(self, v, load=False):
    """
    Setter method for temporary_preferred_lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state/temporary_preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temporary_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temporary_preferred_lifetime() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

The time period during which the temporary address is
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temporary_preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)""",
        })

    self.__temporary_preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temporary_preferred_lifetime(self):
    self.__temporary_preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(86400), is_leaf=True, yang_name="temporary-preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='uint32', is_config=False)

  create_global_addresses = __builtin__.property(_get_create_global_addresses)
  create_temporary_addresses = __builtin__.property(_get_create_temporary_addresses)
  temporary_valid_lifetime = __builtin__.property(_get_temporary_valid_lifetime)
  temporary_preferred_lifetime = __builtin__.property(_get_temporary_preferred_lifetime)


  _pyangbind_elements = OrderedDict([('create_global_addresses', create_global_addresses), ('create_temporary_addresses', create_temporary_addresses), ('temporary_valid_lifetime', temporary_valid_lifetime), ('temporary_preferred_lifetime', temporary_preferred_lifetime), ])


class yc_autoconf_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for IPv6 autoconf
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'autoconf'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'autoconf']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config (container)

    YANG Description: [adapted from IETF IP model RFC 7277]

Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: [adapted from IETF IP model RFC 7277]

Parameters to control the autoconfiguration of IPv6
addresses, as described in RFC 4862.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_ipv6_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv6 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__router_advertisement','__neighbors','__unnumbered','__config','__state','__autoconf',)

  _yang_name = 'ipv6'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__autoconf = YANGDynClass(base=yc_autoconf_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_router_advertisement(self):
    """
    Getter method for router_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement (container)

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    return self.__router_advertisement
      
  def _set_router_advertisement(self, v, load=False):
    """
    Setter method for router_advertisement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_advertisement() directly.

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__router_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_advertisement(self):
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors (container)

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config (container)

    YANG Description: Top-level config data for the IPv6 interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level config data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state (container)

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_autoconf(self):
    """
    Getter method for autoconf, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf (container)

    YANG Description: Top-level container for IPv6 autoconf
    """
    return self.__autoconf
      
  def _set_autoconf(self, v, load=False):
    """
    Setter method for autoconf, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/autoconf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoconf() directly.

    YANG Description: Top-level container for IPv6 autoconf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_autoconf_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoconf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_autoconf_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)""",
        })

    self.__autoconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoconf(self):
    self.__autoconf = YANGDynClass(base=yc_autoconf_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6_autoconf, is_container='container', yang_name="autoconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip-ext', defining_module='openconfig-if-ip-ext', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  router_advertisement = __builtin__.property(_get_router_advertisement, _set_router_advertisement)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  autoconf = __builtin__.property(_get_autoconf, _set_autoconf)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('router_advertisement', router_advertisement), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ('autoconf', autoconf), ])


class yc_subinterface_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of subinterfaces (logical interfaces) associated
with a physical interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state','__vlan','__ipv4','__ipv6',)

  _yang_name = 'subinterface'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__vlan = YANGDynClass(base=yc_vlan_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan, is_container='container', yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/index (leafref)

    YANG Description: The index number of the subinterface -- used to address
the logical interface
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: The index number of the subinterface -- used to address
the logical interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config (container)

    YANG Description: Configurable items at the subinterface level
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configurable items at the subinterface level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state (container)

    YANG Description: Operational state data for logical interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for logical interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan (container)

    YANG Description: Enclosing container for VLAN interface-specific
data on subinterfaces
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: Enclosing container for VLAN interface-specific
data on subinterfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vlan_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan, is_container='container', yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vlan_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan, is_container='container', yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=yc_vlan_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_vlan, is_container='container', yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4 (container)

    YANG Description: Parameters for the IPv4 address family.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Parameters for the IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6 (container)

    YANG Description: Parameters for the IPv6 address family.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Parameters for the IPv6 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  vlan = __builtin__.property(_get_vlan, _set_vlan)
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ('vlan', vlan), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_subinterfaces_openconfig_interfaces__interfaces_interface_subinterfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of subinterfaces associated
with a physical interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__subinterface',)

  _yang_name = 'subinterfaces'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subinterface = YANGDynClass(base=YANGListType("index",yc_subinterface_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface, yang_name="subinterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces']

  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface (list)

    YANG Description: The list of subinterfaces (logical interfaces) associated
with a physical interface
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: The list of subinterfaces (logical interfaces) associated
with a physical interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_subinterface_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface, yang_name="subinterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_subinterface_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface, yang_name="subinterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=YANGListType("index",yc_subinterface_openconfig_interfaces__interfaces_interface_subinterfaces_subinterface, yang_name="subinterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)

  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('subinterface', subinterface), ])


class yc_config_openconfig_interfaces__interfaces_interface_ethernet_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for ethernet interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac_address','__auto_negotiate','__standalone_link_training','__duplex_mode','__port_speed','__enable_flow_control','__fec_mode','__aggregate_id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=True)
    self.__auto_negotiate = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    self.__standalone_link_training = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    self.__duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=True)
    self.__port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)
    self.__enable_flow_control = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)
    self.__aggregate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'config']

  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /interfaces/interface/ethernet/config/mac_address (oc-yang:mac-address)

    YANG Description: Assigns a MAC address to the Ethernet interface.  If not
specified, the corresponding operational state leaf is
expected to show the system-assigned MAC address.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /interfaces/interface/ethernet/config/mac_address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Assigns a MAC address to the Ethernet interface.  If not
specified, the corresponding operational state leaf is
expected to show the system-assigned MAC address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=True)


  def _get_auto_negotiate(self):
    """
    Getter method for auto_negotiate, mapped from YANG variable /interfaces/interface/ethernet/config/auto_negotiate (boolean)

    YANG Description: Set to TRUE to request the interface to auto-negotiate
transmission parameters with its peer interface.  When
set to FALSE, the transmission parameters are specified
manually.
    """
    return self.__auto_negotiate
      
  def _set_auto_negotiate(self, v, load=False):
    """
    Setter method for auto_negotiate, mapped from YANG variable /interfaces/interface/ethernet/config/auto_negotiate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_negotiate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_negotiate() directly.

    YANG Description: Set to TRUE to request the interface to auto-negotiate
transmission parameters with its peer interface.  When
set to FALSE, the transmission parameters are specified
manually.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_negotiate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)""",
        })

    self.__auto_negotiate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_negotiate(self):
    self.__auto_negotiate = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)


  def _get_standalone_link_training(self):
    """
    Getter method for standalone_link_training, mapped from YANG variable /interfaces/interface/ethernet/config/standalone_link_training (boolean)

    YANG Description: Link training is automatic tuning of the SerDes transmit and
receive parameters to ensure an optimal connection over copper
links. It is normally run as part of the auto negotiation
sequence as specified in IEEE 802.3 Clause 73.

Standalone link training is used when full auto negotiation is
not desired on an Ethernet link but link training is needed.
It is configured by setting the standalone-link-training leaf
to TRUE and augo-negotiate leaf to FALSE.

Note: If auto-negotiate is true, then the value of standalone
link training leaf will be ignored.
    """
    return self.__standalone_link_training
      
  def _set_standalone_link_training(self, v, load=False):
    """
    Setter method for standalone_link_training, mapped from YANG variable /interfaces/interface/ethernet/config/standalone_link_training (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_standalone_link_training is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_standalone_link_training() directly.

    YANG Description: Link training is automatic tuning of the SerDes transmit and
receive parameters to ensure an optimal connection over copper
links. It is normally run as part of the auto negotiation
sequence as specified in IEEE 802.3 Clause 73.

Standalone link training is used when full auto negotiation is
not desired on an Ethernet link but link training is needed.
It is configured by setting the standalone-link-training leaf
to TRUE and augo-negotiate leaf to FALSE.

Note: If auto-negotiate is true, then the value of standalone
link training leaf will be ignored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """standalone_link_training must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)""",
        })

    self.__standalone_link_training = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_standalone_link_training(self):
    self.__standalone_link_training = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)


  def _get_duplex_mode(self):
    """
    Getter method for duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/config/duplex_mode (enumeration)

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
duplex mode that will be advertised to the peer.  If
unspecified, the interface should negotiate the duplex mode
directly (typically full-duplex).  When auto-negotiate is
FALSE, this sets the duplex mode on the interface directly.
    """
    return self.__duplex_mode
      
  def _set_duplex_mode(self, v, load=False):
    """
    Setter method for duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/config/duplex_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duplex_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duplex_mode() directly.

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
duplex mode that will be advertised to the peer.  If
unspecified, the interface should negotiate the duplex mode
directly (typically full-duplex).  When auto-negotiate is
FALSE, this sets the duplex mode on the interface directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duplex_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ethernet:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=True)""",
        })

    self.__duplex_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duplex_mode(self):
    self.__duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=True)


  def _get_port_speed(self):
    """
    Getter method for port_speed, mapped from YANG variable /interfaces/interface/ethernet/config/port_speed (identityref)

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
port-speed mode that will be advertised to the peer for
negotiation.  If unspecified, it is expected that the
interface will select the highest speed available based on
negotiation.  When auto-negotiate is set to FALSE, sets the
link speed to a fixed value -- supported values are defined
by ETHERNET_SPEED identities
    """
    return self.__port_speed
      
  def _set_port_speed(self, v, load=False):
    """
    Setter method for port_speed, mapped from YANG variable /interfaces/interface/ethernet/config/port_speed (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_speed() directly.

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
port-speed mode that will be advertised to the peer for
negotiation.  If unspecified, it is expected that the
interface will select the highest speed available based on
negotiation.  When auto-negotiate is set to FALSE, sets the
link speed to a fixed value -- supported values are defined
by ETHERNET_SPEED identities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_speed must be of a type compatible with identityref""",
          'defined-type': "openconfig-if-ethernet:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)""",
        })

    self.__port_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_speed(self):
    self.__port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)


  def _get_enable_flow_control(self):
    """
    Getter method for enable_flow_control, mapped from YANG variable /interfaces/interface/ethernet/config/enable_flow_control (boolean)

    YANG Description: Enable or disable flow control for this interface.
Ethernet flow control is a mechanism by which a receiver
may send PAUSE frames to a sender to stop transmission for
a specified time.

This setting should override auto-negotiated flow control
settings.  If left unspecified, and auto-negotiate is TRUE,
flow control mode is negotiated with the peer interface.
    """
    return self.__enable_flow_control
      
  def _set_enable_flow_control(self, v, load=False):
    """
    Setter method for enable_flow_control, mapped from YANG variable /interfaces/interface/ethernet/config/enable_flow_control (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_flow_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_flow_control() directly.

    YANG Description: Enable or disable flow control for this interface.
Ethernet flow control is a mechanism by which a receiver
may send PAUSE frames to a sender to stop transmission for
a specified time.

This setting should override auto-negotiated flow control
settings.  If left unspecified, and auto-negotiate is TRUE,
flow control mode is negotiated with the peer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_flow_control must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)""",
        })

    self.__enable_flow_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_flow_control(self):
    self.__enable_flow_control = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=True)


  def _get_fec_mode(self):
    """
    Getter method for fec_mode, mapped from YANG variable /interfaces/interface/ethernet/config/fec_mode (identityref)

    YANG Description: The FEC mode applied to the physical channels associated with
the interface.
    """
    return self.__fec_mode
      
  def _set_fec_mode(self, v, load=False):
    """
    Setter method for fec_mode, mapped from YANG variable /interfaces/interface/ethernet/config/fec_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_mode() directly.

    YANG Description: The FEC mode applied to the physical channels associated with
the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-if-ethernet:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)""",
        })

    self.__fec_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_mode(self):
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=True)


  def _get_aggregate_id(self):
    """
    Getter method for aggregate_id, mapped from YANG variable /interfaces/interface/ethernet/config/aggregate_id (leafref)

    YANG Description: Specify the logical aggregate interface to which
this interface belongs
    """
    return self.__aggregate_id
      
  def _set_aggregate_id(self, v, load=False):
    """
    Setter method for aggregate_id, mapped from YANG variable /interfaces/interface/ethernet/config/aggregate_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregate_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregate_id() directly.

    YANG Description: Specify the logical aggregate interface to which
this interface belongs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregate_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=True)""",
        })

    self.__aggregate_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregate_id(self):
    self.__aggregate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=True)

  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  auto_negotiate = __builtin__.property(_get_auto_negotiate, _set_auto_negotiate)
  standalone_link_training = __builtin__.property(_get_standalone_link_training, _set_standalone_link_training)
  duplex_mode = __builtin__.property(_get_duplex_mode, _set_duplex_mode)
  port_speed = __builtin__.property(_get_port_speed, _set_port_speed)
  enable_flow_control = __builtin__.property(_get_enable_flow_control, _set_enable_flow_control)
  fec_mode = __builtin__.property(_get_fec_mode, _set_fec_mode)
  aggregate_id = __builtin__.property(_get_aggregate_id, _set_aggregate_id)


  _pyangbind_elements = OrderedDict([('mac_address', mac_address), ('auto_negotiate', auto_negotiate), ('standalone_link_training', standalone_link_training), ('duplex_mode', duplex_mode), ('port_speed', port_speed), ('enable_flow_control', enable_flow_control), ('fec_mode', fec_mode), ('aggregate_id', aggregate_id), ])


class yc_in_distribution_openconfig_interfaces__interfaces_interface_ethernet_state_counters_in_distribution(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/state/counters/in-distribution. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The size distribution of the received frames.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_frames_64_octets','__in_frames_65_127_octets','__in_frames_128_255_octets','__in_frames_256_511_octets','__in_frames_512_1023_octets','__in_frames_1024_1518_octets',)

  _yang_name = 'in-distribution'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_frames_64_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-64-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    self.__in_frames_65_127_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-65-127-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    self.__in_frames_128_255_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-128-255-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    self.__in_frames_256_511_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-256-511-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    self.__in_frames_512_1023_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-512-1023-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    self.__in_frames_1024_1518_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-1024-1518-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'state', 'counters', 'in-distribution']

  def _get_in_frames_64_octets(self):
    """
    Getter method for in_frames_64_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_64_octets (oc-yang:counter64)

    YANG Description: Number of packets (including bad packets) received that
were 64 bytes in length (excluding framing bits but
including FCS bytes).
    """
    return self.__in_frames_64_octets
      
  def _set_in_frames_64_octets(self, v, load=False):
    """
    Setter method for in_frames_64_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_64_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_64_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_64_octets() directly.

    YANG Description: Number of packets (including bad packets) received that
were 64 bytes in length (excluding framing bits but
including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-64-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_64_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-64-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_64_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_64_octets(self):
    self.__in_frames_64_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-64-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_frames_65_127_octets(self):
    """
    Getter method for in_frames_65_127_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_65_127_octets (oc-yang:counter64)

    YANG Description: Number of good and bad packets received that were
between 65 and 127 bytes in length (excluding framing bits
but including FCS bytes).
    """
    return self.__in_frames_65_127_octets
      
  def _set_in_frames_65_127_octets(self, v, load=False):
    """
    Setter method for in_frames_65_127_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_65_127_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_65_127_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_65_127_octets() directly.

    YANG Description: Number of good and bad packets received that were
between 65 and 127 bytes in length (excluding framing bits
but including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-65-127-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_65_127_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-65-127-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_65_127_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_65_127_octets(self):
    self.__in_frames_65_127_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-65-127-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_frames_128_255_octets(self):
    """
    Getter method for in_frames_128_255_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_128_255_octets (oc-yang:counter64)

    YANG Description: Number of good and bad packets received that were
between 128 and 255 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    return self.__in_frames_128_255_octets
      
  def _set_in_frames_128_255_octets(self, v, load=False):
    """
    Setter method for in_frames_128_255_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_128_255_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_128_255_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_128_255_octets() directly.

    YANG Description: Number of good and bad packets received that were
between 128 and 255 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-128-255-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_128_255_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-128-255-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_128_255_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_128_255_octets(self):
    self.__in_frames_128_255_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-128-255-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_frames_256_511_octets(self):
    """
    Getter method for in_frames_256_511_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_256_511_octets (oc-yang:counter64)

    YANG Description: Number of good and bad packets received that were
between 256 and 511 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    return self.__in_frames_256_511_octets
      
  def _set_in_frames_256_511_octets(self, v, load=False):
    """
    Setter method for in_frames_256_511_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_256_511_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_256_511_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_256_511_octets() directly.

    YANG Description: Number of good and bad packets received that were
between 256 and 511 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-256-511-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_256_511_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-256-511-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_256_511_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_256_511_octets(self):
    self.__in_frames_256_511_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-256-511-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_frames_512_1023_octets(self):
    """
    Getter method for in_frames_512_1023_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_512_1023_octets (oc-yang:counter64)

    YANG Description: Number of good and bad packets received that were
between 512 and 1023 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    return self.__in_frames_512_1023_octets
      
  def _set_in_frames_512_1023_octets(self, v, load=False):
    """
    Setter method for in_frames_512_1023_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_512_1023_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_512_1023_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_512_1023_octets() directly.

    YANG Description: Number of good and bad packets received that were
between 512 and 1023 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-512-1023-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_512_1023_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-512-1023-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_512_1023_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_512_1023_octets(self):
    self.__in_frames_512_1023_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-512-1023-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_frames_1024_1518_octets(self):
    """
    Getter method for in_frames_1024_1518_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_1024_1518_octets (oc-yang:counter64)

    YANG Description: Number of good and bad packets received that were
between 1024 and 1518 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    return self.__in_frames_1024_1518_octets
      
  def _set_in_frames_1024_1518_octets(self, v, load=False):
    """
    Setter method for in_frames_1024_1518_octets, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution/in_frames_1024_1518_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_frames_1024_1518_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_frames_1024_1518_octets() directly.

    YANG Description: Number of good and bad packets received that were
between 1024 and 1518 bytes in length inclusive
(excluding framing bits but including FCS bytes).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-1024-1518-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_frames_1024_1518_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-1024-1518-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_frames_1024_1518_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_frames_1024_1518_octets(self):
    self.__in_frames_1024_1518_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-frames-1024-1518-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='oc-yang:counter64', is_config=False)

  in_frames_64_octets = __builtin__.property(_get_in_frames_64_octets)
  in_frames_65_127_octets = __builtin__.property(_get_in_frames_65_127_octets)
  in_frames_128_255_octets = __builtin__.property(_get_in_frames_128_255_octets)
  in_frames_256_511_octets = __builtin__.property(_get_in_frames_256_511_octets)
  in_frames_512_1023_octets = __builtin__.property(_get_in_frames_512_1023_octets)
  in_frames_1024_1518_octets = __builtin__.property(_get_in_frames_1024_1518_octets)


  _pyangbind_elements = OrderedDict([('in_frames_64_octets', in_frames_64_octets), ('in_frames_65_127_octets', in_frames_65_127_octets), ('in_frames_128_255_octets', in_frames_128_255_octets), ('in_frames_256_511_octets', in_frames_256_511_octets), ('in_frames_512_1023_octets', in_frames_512_1023_octets), ('in_frames_1024_1518_octets', in_frames_1024_1518_octets), ])


class yc_counters_openconfig_interfaces__interfaces_interface_ethernet_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Ethernet interface counters
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_mac_control_frames','__in_mac_pause_frames','__in_oversize_frames','__in_undersize_frames','__in_jabber_frames','__in_fragment_frames','__in_8021q_frames','__in_crc_errors','__in_block_errors','__in_carrier_errors','__in_interrupted_tx','__in_late_collision','__in_mac_errors_rx','__in_single_collision','__in_symbol_error','__in_maxsize_exceeded','__out_mac_control_frames','__out_mac_pause_frames','__out_8021q_frames','__out_mac_errors_tx','__in_distribution',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_carrier_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_interrupted_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_late_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_errors_rx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_single_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_symbol_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_maxsize_exceeded = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_errors_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    self.__in_distribution = YANGDynClass(base=yc_in_distribution_openconfig_interfaces__interfaces_interface_ethernet_state_counters_in_distribution, is_container='container', yang_name="in-distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'state', 'counters']

  def _get_in_mac_control_frames(self):
    """
    Getter method for in_mac_control_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames received on the interface
    """
    return self.__in_mac_control_frames
      
  def _set_in_mac_control_frames(self, v, load=False):
    """
    Setter method for in_mac_control_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_control_frames() directly.

    YANG Description: MAC layer control frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_control_frames(self):
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_pause_frames(self):
    """
    Getter method for in_mac_pause_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    return self.__in_mac_pause_frames
      
  def _set_in_mac_pause_frames(self, v, load=False):
    """
    Setter method for in_mac_pause_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_pause_frames(self):
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_oversize_frames(self):
    """
    Getter method for in_oversize_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_oversize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    return self.__in_oversize_frames
      
  def _set_in_oversize_frames(self, v, load=False):
    """
    Setter method for in_oversize_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_oversize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_oversize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_oversize_frames() directly.

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_oversize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_oversize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_oversize_frames(self):
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_undersize_frames(self):
    """
    Getter method for in_undersize_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_undersize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    return self.__in_undersize_frames
      
  def _set_in_undersize_frames(self, v, load=False):
    """
    Setter method for in_undersize_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_undersize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_undersize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_undersize_frames() directly.

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_undersize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_undersize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_undersize_frames(self):
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_jabber_frames(self):
    """
    Getter method for in_jabber_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_jabber_frames (oc-yang:counter64)

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    return self.__in_jabber_frames
      
  def _set_in_jabber_frames(self, v, load=False):
    """
    Setter method for in_jabber_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_jabber_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_jabber_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_jabber_frames() directly.

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_jabber_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_jabber_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_jabber_frames(self):
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fragment_frames(self):
    """
    Getter method for in_fragment_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_fragment_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    return self.__in_fragment_frames
      
  def _set_in_fragment_frames(self, v, load=False):
    """
    Setter method for in_fragment_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_fragment_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fragment_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fragment_frames() directly.

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fragment_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fragment_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fragment_frames(self):
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_8021q_frames(self):
    """
    Getter method for in_8021q_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    return self.__in_8021q_frames
      
  def _set_in_8021q_frames(self, v, load=False):
    """
    Setter method for in_8021q_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_8021q_frames(self):
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_crc_errors(self):
    """
    Getter method for in_crc_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_crc_errors (oc-yang:counter64)

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    return self.__in_crc_errors
      
  def _set_in_crc_errors(self, v, load=False):
    """
    Setter method for in_crc_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_crc_errors() directly.

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_crc_errors(self):
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_block_errors(self):
    """
    Getter method for in_block_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_block_errors (oc-yang:counter64)

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    return self.__in_block_errors
      
  def _set_in_block_errors(self, v, load=False):
    """
    Setter method for in_block_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_block_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_block_errors() directly.

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_block_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_block_errors(self):
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_carrier_errors(self):
    """
    Getter method for in_carrier_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_carrier_errors (oc-yang:counter64)

    YANG Description: The number of received errored frames due to a carrier issue.
The value refers to MIB counter for
dot3StatsCarrierSenseErrors
oid=1.3.6.1.2.1.10.7.2.1.11
    """
    return self.__in_carrier_errors
      
  def _set_in_carrier_errors(self, v, load=False):
    """
    Setter method for in_carrier_errors, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_carrier_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_carrier_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_carrier_errors() directly.

    YANG Description: The number of received errored frames due to a carrier issue.
The value refers to MIB counter for
dot3StatsCarrierSenseErrors
oid=1.3.6.1.2.1.10.7.2.1.11
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_carrier_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_carrier_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_carrier_errors(self):
    self.__in_carrier_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_interrupted_tx(self):
    """
    Getter method for in_interrupted_tx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_interrupted_tx (oc-yang:counter64)

    YANG Description: The number of received errored frames due to interrupted
transmission issue. The value refers to MIB counter for
dot3StatsDeferredTransmissions
oid=1.3.6.1.2.1.10.7.2.1.7
    """
    return self.__in_interrupted_tx
      
  def _set_in_interrupted_tx(self, v, load=False):
    """
    Setter method for in_interrupted_tx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_interrupted_tx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_interrupted_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_interrupted_tx() directly.

    YANG Description: The number of received errored frames due to interrupted
transmission issue. The value refers to MIB counter for
dot3StatsDeferredTransmissions
oid=1.3.6.1.2.1.10.7.2.1.7
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_interrupted_tx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_interrupted_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_interrupted_tx(self):
    self.__in_interrupted_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_late_collision(self):
    """
    Getter method for in_late_collision, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_late_collision (oc-yang:counter64)

    YANG Description: The number of received errored frames due to late collision
issue. The value refers to MIB counter for
dot3StatsLateCollisions
oid=1.3.6.1.2.1.10.7.2.1.8
    """
    return self.__in_late_collision
      
  def _set_in_late_collision(self, v, load=False):
    """
    Setter method for in_late_collision, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_late_collision (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_late_collision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_late_collision() directly.

    YANG Description: The number of received errored frames due to late collision
issue. The value refers to MIB counter for
dot3StatsLateCollisions
oid=1.3.6.1.2.1.10.7.2.1.8
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_late_collision must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_late_collision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_late_collision(self):
    self.__in_late_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_errors_rx(self):
    """
    Getter method for in_mac_errors_rx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_errors_rx (oc-yang:counter64)

    YANG Description: The number of received errored frames due to MAC errors
received. The value refers to MIB counter for
dot3StatsInternalMacReceiveErrors
oid=1.3.6.1.2.1.10.7.2.1.16
    """
    return self.__in_mac_errors_rx
      
  def _set_in_mac_errors_rx(self, v, load=False):
    """
    Setter method for in_mac_errors_rx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_mac_errors_rx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_errors_rx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_errors_rx() directly.

    YANG Description: The number of received errored frames due to MAC errors
received. The value refers to MIB counter for
dot3StatsInternalMacReceiveErrors
oid=1.3.6.1.2.1.10.7.2.1.16
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_errors_rx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_errors_rx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_errors_rx(self):
    self.__in_mac_errors_rx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_single_collision(self):
    """
    Getter method for in_single_collision, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_single_collision (oc-yang:counter64)

    YANG Description: The number of received errored frames due to single collision
issue. The value refers to MIB counter for
dot3StatsSingleCollisionFrames
oid=1.3.6.1.2.1.10.7.2.1.4
    """
    return self.__in_single_collision
      
  def _set_in_single_collision(self, v, load=False):
    """
    Setter method for in_single_collision, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_single_collision (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_single_collision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_single_collision() directly.

    YANG Description: The number of received errored frames due to single collision
issue. The value refers to MIB counter for
dot3StatsSingleCollisionFrames
oid=1.3.6.1.2.1.10.7.2.1.4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_single_collision must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_single_collision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_single_collision(self):
    self.__in_single_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_symbol_error(self):
    """
    Getter method for in_symbol_error, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_symbol_error (oc-yang:counter64)

    YANG Description: The number of received errored frames due to symbol error.
The value refers to MIB counter for
in-symbol-error
oid=1.3.6.1.2.1.10.7.2.1.18
    """
    return self.__in_symbol_error
      
  def _set_in_symbol_error(self, v, load=False):
    """
    Setter method for in_symbol_error, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_symbol_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_symbol_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_symbol_error() directly.

    YANG Description: The number of received errored frames due to symbol error.
The value refers to MIB counter for
in-symbol-error
oid=1.3.6.1.2.1.10.7.2.1.18
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_symbol_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_symbol_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_symbol_error(self):
    self.__in_symbol_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_maxsize_exceeded(self):
    """
    Getter method for in_maxsize_exceeded, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_maxsize_exceeded (oc-yang:counter64)

    YANG Description: The total number frames received that are well-formed but
dropped due to exceeding the maximum frame size on the interface
(e.g., MTU or MRU)
    """
    return self.__in_maxsize_exceeded
      
  def _set_in_maxsize_exceeded(self, v, load=False):
    """
    Setter method for in_maxsize_exceeded, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_maxsize_exceeded (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_maxsize_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_maxsize_exceeded() directly.

    YANG Description: The total number frames received that are well-formed but
dropped due to exceeding the maximum frame size on the interface
(e.g., MTU or MRU)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_maxsize_exceeded must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_maxsize_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_maxsize_exceeded(self):
    self.__in_maxsize_exceeded = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_control_frames(self):
    """
    Getter method for out_mac_control_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames sent on the interface
    """
    return self.__out_mac_control_frames
      
  def _set_out_mac_control_frames(self, v, load=False):
    """
    Setter method for out_mac_control_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_control_frames() directly.

    YANG Description: MAC layer control frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_control_frames(self):
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_pause_frames(self):
    """
    Getter method for out_mac_pause_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    return self.__out_mac_pause_frames
      
  def _set_out_mac_pause_frames(self, v, load=False):
    """
    Setter method for out_mac_pause_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_pause_frames(self):
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_8021q_frames(self):
    """
    Getter method for out_8021q_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    return self.__out_8021q_frames
      
  def _set_out_8021q_frames(self, v, load=False):
    """
    Setter method for out_8021q_frames, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_8021q_frames(self):
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_errors_tx(self):
    """
    Getter method for out_mac_errors_tx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_errors_tx (oc-yang:counter64)

    YANG Description: The number of sent errored frames due to MAC errors
transmitted. The value refers to MIB counter for
dot3StatsInternalMacTransmitErrors
oid=1.3.6.1.2.1.10.7.2.1.10
    """
    return self.__out_mac_errors_tx
      
  def _set_out_mac_errors_tx(self, v, load=False):
    """
    Setter method for out_mac_errors_tx, mapped from YANG variable /interfaces/interface/ethernet/state/counters/out_mac_errors_tx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_errors_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_errors_tx() directly.

    YANG Description: The number of sent errored frames due to MAC errors
transmitted. The value refers to MIB counter for
dot3StatsInternalMacTransmitErrors
oid=1.3.6.1.2.1.10.7.2.1.10
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_errors_tx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_errors_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_errors_tx(self):
    self.__out_mac_errors_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_distribution(self):
    """
    Getter method for in_distribution, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution (container)

    YANG Description: The size distribution of the received frames.
    """
    return self.__in_distribution
      
  def _set_in_distribution(self, v, load=False):
    """
    Setter method for in_distribution, mapped from YANG variable /interfaces/interface/ethernet/state/counters/in_distribution (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_distribution is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_distribution() directly.

    YANG Description: The size distribution of the received frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_in_distribution_openconfig_interfaces__interfaces_interface_ethernet_state_counters_in_distribution, is_container='container', yang_name="in-distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_distribution must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_in_distribution_openconfig_interfaces__interfaces_interface_ethernet_state_counters_in_distribution, is_container='container', yang_name="in-distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='container', is_config=False)""",
        })

    self.__in_distribution = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_distribution(self):
    self.__in_distribution = YANGDynClass(base=yc_in_distribution_openconfig_interfaces__interfaces_interface_ethernet_state_counters_in_distribution, is_container='container', yang_name="in-distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet-ext', defining_module='openconfig-if-ethernet-ext', yang_type='container', is_config=False)

  in_mac_control_frames = __builtin__.property(_get_in_mac_control_frames)
  in_mac_pause_frames = __builtin__.property(_get_in_mac_pause_frames)
  in_oversize_frames = __builtin__.property(_get_in_oversize_frames)
  in_undersize_frames = __builtin__.property(_get_in_undersize_frames)
  in_jabber_frames = __builtin__.property(_get_in_jabber_frames)
  in_fragment_frames = __builtin__.property(_get_in_fragment_frames)
  in_8021q_frames = __builtin__.property(_get_in_8021q_frames)
  in_crc_errors = __builtin__.property(_get_in_crc_errors)
  in_block_errors = __builtin__.property(_get_in_block_errors)
  in_carrier_errors = __builtin__.property(_get_in_carrier_errors)
  in_interrupted_tx = __builtin__.property(_get_in_interrupted_tx)
  in_late_collision = __builtin__.property(_get_in_late_collision)
  in_mac_errors_rx = __builtin__.property(_get_in_mac_errors_rx)
  in_single_collision = __builtin__.property(_get_in_single_collision)
  in_symbol_error = __builtin__.property(_get_in_symbol_error)
  in_maxsize_exceeded = __builtin__.property(_get_in_maxsize_exceeded)
  out_mac_control_frames = __builtin__.property(_get_out_mac_control_frames)
  out_mac_pause_frames = __builtin__.property(_get_out_mac_pause_frames)
  out_8021q_frames = __builtin__.property(_get_out_8021q_frames)
  out_mac_errors_tx = __builtin__.property(_get_out_mac_errors_tx)
  in_distribution = __builtin__.property(_get_in_distribution)


  _pyangbind_elements = OrderedDict([('in_mac_control_frames', in_mac_control_frames), ('in_mac_pause_frames', in_mac_pause_frames), ('in_oversize_frames', in_oversize_frames), ('in_undersize_frames', in_undersize_frames), ('in_jabber_frames', in_jabber_frames), ('in_fragment_frames', in_fragment_frames), ('in_8021q_frames', in_8021q_frames), ('in_crc_errors', in_crc_errors), ('in_block_errors', in_block_errors), ('in_carrier_errors', in_carrier_errors), ('in_interrupted_tx', in_interrupted_tx), ('in_late_collision', in_late_collision), ('in_mac_errors_rx', in_mac_errors_rx), ('in_single_collision', in_single_collision), ('in_symbol_error', in_symbol_error), ('in_maxsize_exceeded', in_maxsize_exceeded), ('out_mac_control_frames', out_mac_control_frames), ('out_mac_pause_frames', out_mac_pause_frames), ('out_8021q_frames', out_8021q_frames), ('out_mac_errors_tx', out_mac_errors_tx), ('in_distribution', in_distribution), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State variables for Ethernet interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac_address','__auto_negotiate','__standalone_link_training','__duplex_mode','__port_speed','__enable_flow_control','__fec_mode','__hw_mac_address','__negotiated_duplex_mode','__negotiated_port_speed','__counters','__aggregate_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)
    self.__auto_negotiate = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    self.__standalone_link_training = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    self.__duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)
    self.__port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    self.__enable_flow_control = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    self.__hw_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="hw-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)
    self.__negotiated_duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="negotiated-duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)
    self.__negotiated_port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="negotiated-port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_ethernet_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=False)
    self.__aggregate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'state']

  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /interfaces/interface/ethernet/state/mac_address (oc-yang:mac-address)

    YANG Description: Assigns a MAC address to the Ethernet interface.  If not
specified, the corresponding operational state leaf is
expected to show the system-assigned MAC address.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /interfaces/interface/ethernet/state/mac_address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Assigns a MAC address to the Ethernet interface.  If not
specified, the corresponding operational state leaf is
expected to show the system-assigned MAC address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)


  def _get_auto_negotiate(self):
    """
    Getter method for auto_negotiate, mapped from YANG variable /interfaces/interface/ethernet/state/auto_negotiate (boolean)

    YANG Description: Set to TRUE to request the interface to auto-negotiate
transmission parameters with its peer interface.  When
set to FALSE, the transmission parameters are specified
manually.
    """
    return self.__auto_negotiate
      
  def _set_auto_negotiate(self, v, load=False):
    """
    Setter method for auto_negotiate, mapped from YANG variable /interfaces/interface/ethernet/state/auto_negotiate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_negotiate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_negotiate() directly.

    YANG Description: Set to TRUE to request the interface to auto-negotiate
transmission parameters with its peer interface.  When
set to FALSE, the transmission parameters are specified
manually.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_negotiate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)""",
        })

    self.__auto_negotiate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_negotiate(self):
    self.__auto_negotiate = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-negotiate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)


  def _get_standalone_link_training(self):
    """
    Getter method for standalone_link_training, mapped from YANG variable /interfaces/interface/ethernet/state/standalone_link_training (boolean)

    YANG Description: Link training is automatic tuning of the SerDes transmit and
receive parameters to ensure an optimal connection over copper
links. It is normally run as part of the auto negotiation
sequence as specified in IEEE 802.3 Clause 73.

Standalone link training is used when full auto negotiation is
not desired on an Ethernet link but link training is needed.
It is configured by setting the standalone-link-training leaf
to TRUE and augo-negotiate leaf to FALSE.

Note: If auto-negotiate is true, then the value of standalone
link training leaf will be ignored.
    """
    return self.__standalone_link_training
      
  def _set_standalone_link_training(self, v, load=False):
    """
    Setter method for standalone_link_training, mapped from YANG variable /interfaces/interface/ethernet/state/standalone_link_training (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_standalone_link_training is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_standalone_link_training() directly.

    YANG Description: Link training is automatic tuning of the SerDes transmit and
receive parameters to ensure an optimal connection over copper
links. It is normally run as part of the auto negotiation
sequence as specified in IEEE 802.3 Clause 73.

Standalone link training is used when full auto negotiation is
not desired on an Ethernet link but link training is needed.
It is configured by setting the standalone-link-training leaf
to TRUE and augo-negotiate leaf to FALSE.

Note: If auto-negotiate is true, then the value of standalone
link training leaf will be ignored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """standalone_link_training must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)""",
        })

    self.__standalone_link_training = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_standalone_link_training(self):
    self.__standalone_link_training = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standalone-link-training", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)


  def _get_duplex_mode(self):
    """
    Getter method for duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/state/duplex_mode (enumeration)

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
duplex mode that will be advertised to the peer.  If
unspecified, the interface should negotiate the duplex mode
directly (typically full-duplex).  When auto-negotiate is
FALSE, this sets the duplex mode on the interface directly.
    """
    return self.__duplex_mode
      
  def _set_duplex_mode(self, v, load=False):
    """
    Setter method for duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/state/duplex_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duplex_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duplex_mode() directly.

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
duplex mode that will be advertised to the peer.  If
unspecified, the interface should negotiate the duplex mode
directly (typically full-duplex).  When auto-negotiate is
FALSE, this sets the duplex mode on the interface directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duplex_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ethernet:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)""",
        })

    self.__duplex_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duplex_mode(self):
    self.__duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)


  def _get_port_speed(self):
    """
    Getter method for port_speed, mapped from YANG variable /interfaces/interface/ethernet/state/port_speed (identityref)

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
port-speed mode that will be advertised to the peer for
negotiation.  If unspecified, it is expected that the
interface will select the highest speed available based on
negotiation.  When auto-negotiate is set to FALSE, sets the
link speed to a fixed value -- supported values are defined
by ETHERNET_SPEED identities
    """
    return self.__port_speed
      
  def _set_port_speed(self, v, load=False):
    """
    Setter method for port_speed, mapped from YANG variable /interfaces/interface/ethernet/state/port_speed (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_speed() directly.

    YANG Description: When auto-negotiate is TRUE, this optionally sets the
port-speed mode that will be advertised to the peer for
negotiation.  If unspecified, it is expected that the
interface will select the highest speed available based on
negotiation.  When auto-negotiate is set to FALSE, sets the
link speed to a fixed value -- supported values are defined
by ETHERNET_SPEED identities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_speed must be of a type compatible with identityref""",
          'defined-type': "openconfig-if-ethernet:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)""",
        })

    self.__port_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_speed(self):
    self.__port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)


  def _get_enable_flow_control(self):
    """
    Getter method for enable_flow_control, mapped from YANG variable /interfaces/interface/ethernet/state/enable_flow_control (boolean)

    YANG Description: Enable or disable flow control for this interface.
Ethernet flow control is a mechanism by which a receiver
may send PAUSE frames to a sender to stop transmission for
a specified time.

This setting should override auto-negotiated flow control
settings.  If left unspecified, and auto-negotiate is TRUE,
flow control mode is negotiated with the peer interface.
    """
    return self.__enable_flow_control
      
  def _set_enable_flow_control(self, v, load=False):
    """
    Setter method for enable_flow_control, mapped from YANG variable /interfaces/interface/ethernet/state/enable_flow_control (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_flow_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_flow_control() directly.

    YANG Description: Enable or disable flow control for this interface.
Ethernet flow control is a mechanism by which a receiver
may send PAUSE frames to a sender to stop transmission for
a specified time.

This setting should override auto-negotiated flow control
settings.  If left unspecified, and auto-negotiate is TRUE,
flow control mode is negotiated with the peer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_flow_control must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)""",
        })

    self.__enable_flow_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_flow_control(self):
    self.__enable_flow_control = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-flow-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='boolean', is_config=False)


  def _get_fec_mode(self):
    """
    Getter method for fec_mode, mapped from YANG variable /interfaces/interface/ethernet/state/fec_mode (identityref)

    YANG Description: The FEC mode applied to the physical channels associated with
the interface.
    """
    return self.__fec_mode
      
  def _set_fec_mode(self, v, load=False):
    """
    Setter method for fec_mode, mapped from YANG variable /interfaces/interface/ethernet/state/fec_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_mode() directly.

    YANG Description: The FEC mode applied to the physical channels associated with
the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-if-ethernet:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)""",
        })

    self.__fec_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_mode(self):
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_FC': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS528': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_RS544_2X_INTERLEAVE': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:FEC_DISABLED': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)


  def _get_hw_mac_address(self):
    """
    Getter method for hw_mac_address, mapped from YANG variable /interfaces/interface/ethernet/state/hw_mac_address (oc-yang:mac-address)

    YANG Description: Represents the 'burned-in', or system-assigned, MAC
address for the Ethernet interface.
    """
    return self.__hw_mac_address
      
  def _set_hw_mac_address(self, v, load=False):
    """
    Setter method for hw_mac_address, mapped from YANG variable /interfaces/interface/ethernet/state/hw_mac_address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hw_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hw_mac_address() directly.

    YANG Description: Represents the 'burned-in', or system-assigned, MAC
address for the Ethernet interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="hw-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hw_mac_address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="hw-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__hw_mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hw_mac_address(self):
    self.__hw_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="hw-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='oc-yang:mac-address', is_config=False)


  def _get_negotiated_duplex_mode(self):
    """
    Getter method for negotiated_duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/state/negotiated_duplex_mode (enumeration)

    YANG Description: When auto-negotiate is set to TRUE, and the interface has
completed auto-negotiation with the remote peer, this value
shows the duplex mode that has been negotiated.
    """
    return self.__negotiated_duplex_mode
      
  def _set_negotiated_duplex_mode(self, v, load=False):
    """
    Setter method for negotiated_duplex_mode, mapped from YANG variable /interfaces/interface/ethernet/state/negotiated_duplex_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated_duplex_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated_duplex_mode() directly.

    YANG Description: When auto-negotiate is set to TRUE, and the interface has
completed auto-negotiation with the remote peer, this value
shows the duplex mode that has been negotiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="negotiated-duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated_duplex_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ethernet:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="negotiated-duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)""",
        })

    self.__negotiated_duplex_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated_duplex_mode(self):
    self.__negotiated_duplex_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FULL': {}, 'HALF': {}},), is_leaf=True, yang_name="negotiated-duplex-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='enumeration', is_config=False)


  def _get_negotiated_port_speed(self):
    """
    Getter method for negotiated_port_speed, mapped from YANG variable /interfaces/interface/ethernet/state/negotiated_port_speed (identityref)

    YANG Description: When auto-negotiate is set to TRUE, and the interface has
completed auto-negotiation with the remote peer, this value
shows the interface speed that has been negotiated.
    """
    return self.__negotiated_port_speed
      
  def _set_negotiated_port_speed(self, v, load=False):
    """
    Setter method for negotiated_port_speed, mapped from YANG variable /interfaces/interface/ethernet/state/negotiated_port_speed (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated_port_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated_port_speed() directly.

    YANG Description: When auto-negotiate is set to TRUE, and the interface has
completed auto-negotiation with the remote peer, this value
shows the interface speed that has been negotiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="negotiated-port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated_port_speed must be of a type compatible with identityref""",
          'defined-type': "openconfig-if-ethernet:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="negotiated-port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)""",
        })

    self.__negotiated_port_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated_port_speed(self):
    self.__negotiated_port_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_1GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_2500MB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_5GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_10GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_25GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_40GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_50GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_100GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_200GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_400GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_600GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_800GB': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}, 'oc-eth:SPEED_UNKNOWN': {'@module': 'openconfig-if-ethernet', '@namespace': 'http://openconfig.net/yang/interfaces/ethernet'}},), is_leaf=True, yang_name="negotiated-port-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='identityref', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/ethernet/state/counters (container)

    YANG Description: Ethernet interface counters
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/ethernet/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Ethernet interface counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_ethernet_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_ethernet_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_ethernet_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=False)


  def _get_aggregate_id(self):
    """
    Getter method for aggregate_id, mapped from YANG variable /interfaces/interface/ethernet/state/aggregate_id (leafref)

    YANG Description: Specify the logical aggregate interface to which
this interface belongs
    """
    return self.__aggregate_id
      
  def _set_aggregate_id(self, v, load=False):
    """
    Setter method for aggregate_id, mapped from YANG variable /interfaces/interface/ethernet/state/aggregate_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregate_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregate_id() directly.

    YANG Description: Specify the logical aggregate interface to which
this interface belongs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregate_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=False)""",
        })

    self.__aggregate_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregate_id(self):
    self.__aggregate_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aggregate-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='leafref', is_config=False)

  mac_address = __builtin__.property(_get_mac_address)
  auto_negotiate = __builtin__.property(_get_auto_negotiate)
  standalone_link_training = __builtin__.property(_get_standalone_link_training)
  duplex_mode = __builtin__.property(_get_duplex_mode)
  port_speed = __builtin__.property(_get_port_speed)
  enable_flow_control = __builtin__.property(_get_enable_flow_control)
  fec_mode = __builtin__.property(_get_fec_mode)
  hw_mac_address = __builtin__.property(_get_hw_mac_address)
  negotiated_duplex_mode = __builtin__.property(_get_negotiated_duplex_mode)
  negotiated_port_speed = __builtin__.property(_get_negotiated_port_speed)
  counters = __builtin__.property(_get_counters)
  aggregate_id = __builtin__.property(_get_aggregate_id)


  _pyangbind_elements = OrderedDict([('mac_address', mac_address), ('auto_negotiate', auto_negotiate), ('standalone_link_training', standalone_link_training), ('duplex_mode', duplex_mode), ('port_speed', port_speed), ('enable_flow_control', enable_flow_control), ('fec_mode', fec_mode), ('hw_mac_address', hw_mac_address), ('negotiated_duplex_mode', negotiated_duplex_mode), ('negotiated_port_speed', negotiated_port_speed), ('counters', counters), ('aggregate_id', aggregate_id), ])


class yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_mode','__native_vlan','__access_vlan','__trunk_vlans',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'config']

  def _get_interface_mode(self):
    """
    Getter method for interface_mode, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/interface_mode (oc-vlan-types:vlan-mode-type)

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    return self.__interface_mode
      
  def _set_interface_mode(self, v, load=False):
    """
    Setter method for interface_mode, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/interface_mode (oc-vlan-types:vlan-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode() directly.

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode must be of a type compatible with oc-vlan-types:vlan-mode-type""",
          'defined-type': "oc-vlan-types:vlan-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)""",
        })

    self.__interface_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode(self):
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/native_vlan (oc-vlan-types:vlan-id)

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/native_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_access_vlan(self):
    """
    Getter method for access_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/access_vlan (oc-vlan-types:vlan-id)

    YANG Description: Assign the access vlan to the access port.
    """
    return self.__access_vlan
      
  def _set_access_vlan(self, v, load=False):
    """
    Setter method for access_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/access_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_vlan() directly.

    YANG Description: Assign the access vlan to the access port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__access_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_vlan(self):
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_trunk_vlans(self):
    """
    Getter method for trunk_vlans, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/trunk_vlans (union)

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    return self.__trunk_vlans
      
  def _set_trunk_vlans(self, v, load=False):
    """
    Setter method for trunk_vlans, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/trunk_vlans (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_vlans() directly.

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trunk_vlans must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)""",
        })

    self.__trunk_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trunk_vlans(self):
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

  interface_mode = __builtin__.property(_get_interface_mode, _set_interface_mode)
  native_vlan = __builtin__.property(_get_native_vlan, _set_native_vlan)
  access_vlan = __builtin__.property(_get_access_vlan, _set_access_vlan)
  trunk_vlans = __builtin__.property(_get_trunk_vlans, _set_trunk_vlans)


  _pyangbind_elements = OrderedDict([('interface_mode', interface_mode), ('native_vlan', native_vlan), ('access_vlan', access_vlan), ('trunk_vlans', trunk_vlans), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State variables for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_mode','__native_vlan','__access_vlan','__trunk_vlans',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'state']

  def _get_interface_mode(self):
    """
    Getter method for interface_mode, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/interface_mode (oc-vlan-types:vlan-mode-type)

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    return self.__interface_mode
      
  def _set_interface_mode(self, v, load=False):
    """
    Setter method for interface_mode, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/interface_mode (oc-vlan-types:vlan-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode() directly.

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode must be of a type compatible with oc-vlan-types:vlan-mode-type""",
          'defined-type': "oc-vlan-types:vlan-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)""",
        })

    self.__interface_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode(self):
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/native_vlan (oc-vlan-types:vlan-id)

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/native_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_access_vlan(self):
    """
    Getter method for access_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/access_vlan (oc-vlan-types:vlan-id)

    YANG Description: Assign the access vlan to the access port.
    """
    return self.__access_vlan
      
  def _set_access_vlan(self, v, load=False):
    """
    Setter method for access_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/access_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_vlan() directly.

    YANG Description: Assign the access vlan to the access port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__access_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_vlan(self):
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_trunk_vlans(self):
    """
    Getter method for trunk_vlans, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/trunk_vlans (union)

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    return self.__trunk_vlans
      
  def _set_trunk_vlans(self, v, load=False):
    """
    Setter method for trunk_vlans, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/trunk_vlans (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_vlans() directly.

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trunk_vlans must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)""",
        })

    self.__trunk_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trunk_vlans(self):
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

  interface_mode = __builtin__.property(_get_interface_mode)
  native_vlan = __builtin__.property(_get_native_vlan)
  access_vlan = __builtin__.property(_get_access_vlan)
  trunk_vlans = __builtin__.property(_get_trunk_vlans)


  _pyangbind_elements = OrderedDict([('interface_mode', interface_mode), ('native_vlan', native_vlan), ('access_vlan', access_vlan), ('trunk_vlans', trunk_vlans), ])


class yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/dot1x-vlan-map/vlan-name/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured VLAN
name in the VLAN ID to VLAN name mapping
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_name','__id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'dot1x-vlan-map', 'vlan-name', 'config']

  def _get_vlan_name(self):
    """
    Getter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config/vlan_name (string)

    YANG Description: The VLAN name to be mapped to the VLAN id.
    """
    return self.__vlan_name
      
  def _set_vlan_name(self, v, load=False):
    """
    Setter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config/vlan_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_name() directly.

    YANG Description: The VLAN name to be mapped to the VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=True)""",
        })

    self.__vlan_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_name(self):
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config/id (oc-vlan-types:vlan-id)

    YANG Description: The VLAN id to be mapped to the VLAN name.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config/id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The VLAN id to be mapped to the VLAN name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=True)

  vlan_name = __builtin__.property(_get_vlan_name, _set_vlan_name)
  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('vlan_name', vlan_name), ('id', id), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/dot1x-vlan-map/vlan-name/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each VLAN id
to VLAN name mapping.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_name','__id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'dot1x-vlan-map', 'vlan-name', 'state']

  def _get_vlan_name(self):
    """
    Getter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state/vlan_name (string)

    YANG Description: The VLAN name to be mapped to the VLAN id.
    """
    return self.__vlan_name
      
  def _set_vlan_name(self, v, load=False):
    """
    Setter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state/vlan_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_name() directly.

    YANG Description: The VLAN name to be mapped to the VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)""",
        })

    self.__vlan_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_name(self):
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state/id (oc-vlan-types:vlan-id)

    YANG Description: The VLAN id to be mapped to the VLAN name.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state/id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The VLAN id to be mapped to the VLAN name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-vlan-types:vlan-id', is_config=False)

  vlan_name = __builtin__.property(_get_vlan_name)
  id = __builtin__.property(_get_id)


  _pyangbind_elements = OrderedDict([('vlan_name', vlan_name), ('id', id), ])


class yc_vlan_name_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/dot1x-vlan-map/vlan-name. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from VLAN name to VLAN id.
Entries in this list are utilized for DVA using a VLAN
name; eg when RADIUS returns a VLAN name as the
tunnel-private-group-id.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_name','__config','__state',)

  _yang_name = 'vlan-name'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'dot1x-vlan-map', 'vlan-name']

  def _get_vlan_name(self):
    """
    Getter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/vlan_name (leafref)

    YANG Description: References the configured VLAN name
    """
    return self.__vlan_name
      
  def _set_vlan_name(self, v, load=False):
    """
    Setter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/vlan_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_name() directly.

    YANG Description: References the configured VLAN name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=True)""",
        })

    self.__vlan_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_name(self):
    self.__vlan_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config (container)

    YANG Description: Configuration data for each configured VLAN
name in the VLAN ID to VLAN name mapping
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured VLAN
name in the VLAN ID to VLAN name mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state (container)

    YANG Description: Operational state data for each VLAN id
to VLAN name mapping.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each VLAN id
to VLAN name mapping.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

  vlan_name = __builtin__.property(_get_vlan_name, _set_vlan_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('vlan_name', vlan_name), ('config', config), ('state', state), ])


class yc_dot1x_vlan_map_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan/dot1x-vlan-map. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for mapping a VLAN name to VLAN id
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_name',)

  _yang_name = 'dot1x-vlan-map'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_name = YANGDynClass(base=YANGListType("vlan_name",yc_vlan_name_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name, yang_name="vlan-name", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-name', extensions=None), is_container='list', yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan', 'dot1x-vlan-map']

  def _get_vlan_name(self):
    """
    Getter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name (list)

    YANG Description: A list of mappings from VLAN name to VLAN id.
Entries in this list are utilized for DVA using a VLAN
name; eg when RADIUS returns a VLAN name as the
tunnel-private-group-id.
    """
    return self.__vlan_name
      
  def _set_vlan_name(self, v, load=False):
    """
    Setter method for vlan_name, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map/vlan_name (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_name() directly.

    YANG Description: A list of mappings from VLAN name to VLAN id.
Entries in this list are utilized for DVA using a VLAN
name; eg when RADIUS returns a VLAN name as the
tunnel-private-group-id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vlan_name",yc_vlan_name_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name, yang_name="vlan-name", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-name', extensions=None), is_container='list', yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_name must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vlan_name",yc_vlan_name_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name, yang_name="vlan-name", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-name', extensions=None), is_container='list', yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)""",
        })

    self.__vlan_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_name(self):
    self.__vlan_name = YANGDynClass(base=YANGListType("vlan_name",yc_vlan_name_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map_vlan_name, yang_name="vlan-name", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vlan-name', extensions=None), is_container='list', yang_name="vlan-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)

  vlan_name = __builtin__.property(_get_vlan_name, _set_vlan_name)


  _pyangbind_elements = OrderedDict([('vlan_name', vlan_name), ])


class yc_switched_vlan_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/switched-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__dot1x_vlan_map',)

  _yang_name = 'switched-vlan'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__dot1x_vlan_map = YANGDynClass(base=yc_dot1x_vlan_map_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map, is_container='container', yang_name="dot1x-vlan-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'switched-vlan']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config (container)

    YANG Description: Configuration parameters for VLANs
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state (container)

    YANG Description: State variables for VLANs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State variables for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_dot1x_vlan_map(self):
    """
    Getter method for dot1x_vlan_map, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map (container)

    YANG Description: Enclosing container for mapping a VLAN name to VLAN id
    """
    return self.__dot1x_vlan_map
      
  def _set_dot1x_vlan_map(self, v, load=False):
    """
    Setter method for dot1x_vlan_map, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/dot1x_vlan_map (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1x_vlan_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1x_vlan_map() directly.

    YANG Description: Enclosing container for mapping a VLAN name to VLAN id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot1x_vlan_map_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map, is_container='container', yang_name="dot1x-vlan-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1x_vlan_map must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot1x_vlan_map_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map, is_container='container', yang_name="dot1x-vlan-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__dot1x_vlan_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1x_vlan_map(self):
    self.__dot1x_vlan_map = YANGDynClass(base=yc_dot1x_vlan_map_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan_dot1x_vlan_map, is_container='container', yang_name="dot1x-vlan-map", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  dot1x_vlan_map = __builtin__.property(_get_dot1x_vlan_map, _set_dot1x_vlan_map)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('dot1x_vlan_map', dot1x_vlan_map), ])


class yc_config_openconfig_interfaces__interfaces_interface_ethernet_dot1x_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/dot1x/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level configuration container for 802.1X.
  """
  __slots__ = ('_path_helper', '_extmethods', '__authenticate_port','__host_mode','__reauthenticate_interval','__retransmit_interval','__supplicant_timeout','__max_requests','__server_fail_vlan','__auth_fail_vlan',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authenticate_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=True)
    self.__host_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=True)
    self.__reauthenticate_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    self.__supplicant_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    self.__max_requests = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    self.__server_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)
    self.__auth_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'dot1x', 'config']

  def _get_authenticate_port(self):
    """
    Getter method for authenticate_port, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/authenticate_port (boolean)

    YANG Description: Enable 802.1X port control on an interface.
    """
    return self.__authenticate_port
      
  def _set_authenticate_port(self, v, load=False):
    """
    Setter method for authenticate_port, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/authenticate_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authenticate_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authenticate_port() directly.

    YANG Description: Enable 802.1X port control on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authenticate_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=True)""",
        })

    self.__authenticate_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authenticate_port(self):
    self.__authenticate_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=True)


  def _get_host_mode(self):
    """
    Getter method for host_mode, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/host_mode (enumeration)

    YANG Description: Allow for single or multiple hosts to communicate through
an 802.1X controlled port.
    """
    return self.__host_mode
      
  def _set_host_mode(self, v, load=False):
    """
    Setter method for host_mode, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/host_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_mode() directly.

    YANG Description: Allow for single or multiple hosts to communicate through
an 802.1X controlled port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-8021x:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=True)""",
        })

    self.__host_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_mode(self):
    self.__host_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=True)


  def _get_reauthenticate_interval(self):
    """
    Getter method for reauthenticate_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/reauthenticate_interval (uint16)

    YANG Description: Enable periodic re-authentication of the device connected
to this port. Setting a value of 0 disabled reauthentication
on this port.
    """
    return self.__reauthenticate_interval
      
  def _set_reauthenticate_interval(self, v, load=False):
    """
    Setter method for reauthenticate_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/reauthenticate_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reauthenticate_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reauthenticate_interval() directly.

    YANG Description: Enable periodic re-authentication of the device connected
to this port. Setting a value of 0 disabled reauthentication
on this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reauthenticate_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)""",
        })

    self.__reauthenticate_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reauthenticate_interval(self):
    self.__reauthenticate_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/retransmit_interval (uint16)

    YANG Description: How long the interface waits for a response from an
EAPoL Start before restarting 802.1X authentication on the
port.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/retransmit_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: How long the interface waits for a response from an
EAPoL Start before restarting 802.1X authentication on the
port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)


  def _get_supplicant_timeout(self):
    """
    Getter method for supplicant_timeout, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/supplicant_timeout (uint16)

    YANG Description: Time to wait for a response from the supplicant before
restarting the 802.1X authentication process.
    """
    return self.__supplicant_timeout
      
  def _set_supplicant_timeout(self, v, load=False):
    """
    Setter method for supplicant_timeout, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/supplicant_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supplicant_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supplicant_timeout() directly.

    YANG Description: Time to wait for a response from the supplicant before
restarting the 802.1X authentication process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supplicant_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)""",
        })

    self.__supplicant_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supplicant_timeout(self):
    self.__supplicant_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)


  def _get_max_requests(self):
    """
    Getter method for max_requests, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/max_requests (uint16)

    YANG Description: Maximum number of times an EAPoL request packet is retransmitted
to the supplicant before the authentication session fails.
    """
    return self.__max_requests
      
  def _set_max_requests(self, v, load=False):
    """
    Setter method for max_requests, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/max_requests (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_requests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_requests() directly.

    YANG Description: Maximum number of times an EAPoL request packet is retransmitted
to the supplicant before the authentication session fails.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_requests must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)""",
        })

    self.__max_requests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_requests(self):
    self.__max_requests = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=True)


  def _get_server_fail_vlan(self):
    """
    Getter method for server_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/server_fail_vlan (union)

    YANG Description: If RADIUS is unresponsive, the supplicant shall be placed in
this VLAN. If this VLAN is configured as a VLAN name, the
vlan-map must be populated for the Authenticator to map this
VLAN name to a VLAN id.
    """
    return self.__server_fail_vlan
      
  def _set_server_fail_vlan(self, v, load=False):
    """
    Setter method for server_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/server_fail_vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_fail_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_fail_vlan() directly.

    YANG Description: If RADIUS is unresponsive, the supplicant shall be placed in
this VLAN. If this VLAN is configured as a VLAN name, the
vlan-map must be populated for the Authenticator to map this
VLAN name to a VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_fail_vlan must be of a type compatible with union""",
          'defined-type': "openconfig-if-8021x:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)""",
        })

    self.__server_fail_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_fail_vlan(self):
    self.__server_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)


  def _get_auth_fail_vlan(self):
    """
    Getter method for auth_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/auth_fail_vlan (union)

    YANG Description: Upon failure to authenticate, the port is set to this VLAN.
If this VLAN is a configured as a VLAN name, the vlan-map must
be populated for the Authenticator to map this VLAN name to a
VLAN id.
    """
    return self.__auth_fail_vlan
      
  def _set_auth_fail_vlan(self, v, load=False):
    """
    Setter method for auth_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config/auth_fail_vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_fail_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_fail_vlan() directly.

    YANG Description: Upon failure to authenticate, the port is set to this VLAN.
If this VLAN is a configured as a VLAN name, the vlan-map must
be populated for the Authenticator to map this VLAN name to a
VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_fail_vlan must be of a type compatible with union""",
          'defined-type': "openconfig-if-8021x:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)""",
        })

    self.__auth_fail_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_fail_vlan(self):
    self.__auth_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=True)

  authenticate_port = __builtin__.property(_get_authenticate_port, _set_authenticate_port)
  host_mode = __builtin__.property(_get_host_mode, _set_host_mode)
  reauthenticate_interval = __builtin__.property(_get_reauthenticate_interval, _set_reauthenticate_interval)
  retransmit_interval = __builtin__.property(_get_retransmit_interval, _set_retransmit_interval)
  supplicant_timeout = __builtin__.property(_get_supplicant_timeout, _set_supplicant_timeout)
  max_requests = __builtin__.property(_get_max_requests, _set_max_requests)
  server_fail_vlan = __builtin__.property(_get_server_fail_vlan, _set_server_fail_vlan)
  auth_fail_vlan = __builtin__.property(_get_auth_fail_vlan, _set_auth_fail_vlan)


  _pyangbind_elements = OrderedDict([('authenticate_port', authenticate_port), ('host_mode', host_mode), ('reauthenticate_interval', reauthenticate_interval), ('retransmit_interval', retransmit_interval), ('supplicant_timeout', supplicant_timeout), ('max_requests', max_requests), ('server_fail_vlan', server_fail_vlan), ('auth_fail_vlan', auth_fail_vlan), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_dot1x_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/dot1x/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level state container for 802.1X.
  """
  __slots__ = ('_path_helper', '_extmethods', '__authenticate_port','__host_mode','__reauthenticate_interval','__retransmit_interval','__supplicant_timeout','__max_requests','__server_fail_vlan','__auth_fail_vlan',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authenticate_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=False)
    self.__host_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)
    self.__reauthenticate_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    self.__supplicant_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    self.__max_requests = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    self.__server_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)
    self.__auth_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'dot1x', 'state']

  def _get_authenticate_port(self):
    """
    Getter method for authenticate_port, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/authenticate_port (boolean)

    YANG Description: Enable 802.1X port control on an interface.
    """
    return self.__authenticate_port
      
  def _set_authenticate_port(self, v, load=False):
    """
    Setter method for authenticate_port, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/authenticate_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authenticate_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authenticate_port() directly.

    YANG Description: Enable 802.1X port control on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authenticate_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=False)""",
        })

    self.__authenticate_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authenticate_port(self):
    self.__authenticate_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authenticate-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='boolean', is_config=False)


  def _get_host_mode(self):
    """
    Getter method for host_mode, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/host_mode (enumeration)

    YANG Description: Allow for single or multiple hosts to communicate through
an 802.1X controlled port.
    """
    return self.__host_mode
      
  def _set_host_mode(self, v, load=False):
    """
    Setter method for host_mode, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/host_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_mode() directly.

    YANG Description: Allow for single or multiple hosts to communicate through
an 802.1X controlled port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-8021x:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)""",
        })

    self.__host_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_mode(self):
    self.__host_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_HOST': {}, 'MULTI_HOST': {}, 'MULTI_DOMAIN': {}},), is_leaf=True, yang_name="host-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)


  def _get_reauthenticate_interval(self):
    """
    Getter method for reauthenticate_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/reauthenticate_interval (uint16)

    YANG Description: Enable periodic re-authentication of the device connected
to this port. Setting a value of 0 disabled reauthentication
on this port.
    """
    return self.__reauthenticate_interval
      
  def _set_reauthenticate_interval(self, v, load=False):
    """
    Setter method for reauthenticate_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/reauthenticate_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reauthenticate_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reauthenticate_interval() directly.

    YANG Description: Enable periodic re-authentication of the device connected
to this port. Setting a value of 0 disabled reauthentication
on this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reauthenticate_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)""",
        })

    self.__reauthenticate_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reauthenticate_interval(self):
    self.__reauthenticate_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="reauthenticate-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/retransmit_interval (uint16)

    YANG Description: How long the interface waits for a response from an
EAPoL Start before restarting 802.1X authentication on the
port.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/retransmit_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: How long the interface waits for a response from an
EAPoL Start before restarting 802.1X authentication on the
port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)


  def _get_supplicant_timeout(self):
    """
    Getter method for supplicant_timeout, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/supplicant_timeout (uint16)

    YANG Description: Time to wait for a response from the supplicant before
restarting the 802.1X authentication process.
    """
    return self.__supplicant_timeout
      
  def _set_supplicant_timeout(self, v, load=False):
    """
    Setter method for supplicant_timeout, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/supplicant_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supplicant_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supplicant_timeout() directly.

    YANG Description: Time to wait for a response from the supplicant before
restarting the 802.1X authentication process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supplicant_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)""",
        })

    self.__supplicant_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supplicant_timeout(self):
    self.__supplicant_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="supplicant-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)


  def _get_max_requests(self):
    """
    Getter method for max_requests, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/max_requests (uint16)

    YANG Description: Maximum number of times an EAPoL request packet is retransmitted
to the supplicant before the authentication session fails.
    """
    return self.__max_requests
      
  def _set_max_requests(self, v, load=False):
    """
    Setter method for max_requests, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/max_requests (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_requests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_requests() directly.

    YANG Description: Maximum number of times an EAPoL request packet is retransmitted
to the supplicant before the authentication session fails.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_requests must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)""",
        })

    self.__max_requests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_requests(self):
    self.__max_requests = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="max-requests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='uint16', is_config=False)


  def _get_server_fail_vlan(self):
    """
    Getter method for server_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/server_fail_vlan (union)

    YANG Description: If RADIUS is unresponsive, the supplicant shall be placed in
this VLAN. If this VLAN is configured as a VLAN name, the
vlan-map must be populated for the Authenticator to map this
VLAN name to a VLAN id.
    """
    return self.__server_fail_vlan
      
  def _set_server_fail_vlan(self, v, load=False):
    """
    Setter method for server_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/server_fail_vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_fail_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_fail_vlan() directly.

    YANG Description: If RADIUS is unresponsive, the supplicant shall be placed in
this VLAN. If this VLAN is configured as a VLAN name, the
vlan-map must be populated for the Authenticator to map this
VLAN name to a VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_fail_vlan must be of a type compatible with union""",
          'defined-type': "openconfig-if-8021x:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)""",
        })

    self.__server_fail_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_fail_vlan(self):
    self.__server_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="server-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)


  def _get_auth_fail_vlan(self):
    """
    Getter method for auth_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/auth_fail_vlan (union)

    YANG Description: Upon failure to authenticate, the port is set to this VLAN.
If this VLAN is a configured as a VLAN name, the vlan-map must
be populated for the Authenticator to map this VLAN name to a
VLAN id.
    """
    return self.__auth_fail_vlan
      
  def _set_auth_fail_vlan(self, v, load=False):
    """
    Setter method for auth_fail_vlan, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state/auth_fail_vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_fail_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_fail_vlan() directly.

    YANG Description: Upon failure to authenticate, the port is set to this VLAN.
If this VLAN is a configured as a VLAN name, the vlan-map must
be populated for the Authenticator to map this VLAN name to a
VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_fail_vlan must be of a type compatible with union""",
          'defined-type': "openconfig-if-8021x:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)""",
        })

    self.__auth_fail_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_fail_vlan(self):
    self.__auth_fail_vlan = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),], is_leaf=True, yang_name="auth-fail-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='union', is_config=False)

  authenticate_port = __builtin__.property(_get_authenticate_port)
  host_mode = __builtin__.property(_get_host_mode)
  reauthenticate_interval = __builtin__.property(_get_reauthenticate_interval)
  retransmit_interval = __builtin__.property(_get_retransmit_interval)
  supplicant_timeout = __builtin__.property(_get_supplicant_timeout)
  max_requests = __builtin__.property(_get_max_requests)
  server_fail_vlan = __builtin__.property(_get_server_fail_vlan)
  auth_fail_vlan = __builtin__.property(_get_auth_fail_vlan)


  _pyangbind_elements = OrderedDict([('authenticate_port', authenticate_port), ('host_mode', host_mode), ('reauthenticate_interval', reauthenticate_interval), ('retransmit_interval', retransmit_interval), ('supplicant_timeout', supplicant_timeout), ('max_requests', max_requests), ('server_fail_vlan', server_fail_vlan), ('auth_fail_vlan', auth_fail_vlan), ])


class yc_dot1x_openconfig_interfaces__interfaces_interface_ethernet_dot1x(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/dot1x. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for 802.1X configuration and
state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'dot1x'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_dot1x_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_dot1x_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'dot1x']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config (container)

    YANG Description: Top level configuration container for 802.1X.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/dot1x/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top level configuration container for 802.1X.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_dot1x_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_dot1x_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_dot1x_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state (container)

    YANG Description: Top level state container for 802.1X.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/dot1x/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level state container for 802.1X.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_dot1x_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_dot1x_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_dot1x_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/authenticated-sessions/authenticated-session/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level state container for 802.1X.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__session_id','__status',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-yang:mac-address', is_config=False)
    self.__session_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AUTHENTICATED': {}, 'AUTHENTICATING': {}, 'FAILED_AUTHENTICATION': {}, 'SUPPLICANT_TIMEOUT': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'authenticated-sessions', 'authenticated-session', 'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/mac (oc-yang:mac-address)

    YANG Description: Device MAC address.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: Device MAC address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='oc-yang:mac-address', is_config=False)


  def _get_session_id(self):
    """
    Getter method for session_id, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/session_id (string)

    YANG Description: The locally-significant session id which this authenticated
session applies to. Typically used for RADIUS accounting or
other system level telemetry.
    """
    return self.__session_id
      
  def _set_session_id(self, v, load=False):
    """
    Setter method for session_id, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/session_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_id() directly.

    YANG Description: The locally-significant session id which this authenticated
session applies to. Typically used for RADIUS accounting or
other system level telemetry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="session-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)""",
        })

    self.__session_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_id(self):
    self.__session_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='string', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/status (enumeration)

    YANG Description: The status of the 802.1X session for a device.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of the 802.1X session for a device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AUTHENTICATED': {}, 'AUTHENTICATING': {}, 'FAILED_AUTHENTICATION': {}, 'SUPPLICANT_TIMEOUT': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-8021x:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AUTHENTICATED': {}, 'AUTHENTICATING': {}, 'FAILED_AUTHENTICATION': {}, 'SUPPLICANT_TIMEOUT': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AUTHENTICATED': {}, 'AUTHENTICATING': {}, 'FAILED_AUTHENTICATION': {}, 'SUPPLICANT_TIMEOUT': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='enumeration', is_config=False)

  mac = __builtin__.property(_get_mac)
  session_id = __builtin__.property(_get_session_id)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('mac', mac), ('session_id', session_id), ('status', status), ])


class yc_authenticated_session_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/authenticated-sessions/authenticated-session. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of authenticated sessions on this device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__state',)

  _yang_name = 'authenticated-session'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'authenticated-sessions', 'authenticated-session']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/mac (leafref)

    YANG Description: Device MAC address.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/mac (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: Device MAC address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state (container)

    YANG Description: Top level state container for 802.1X.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level state container for 802.1X.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=False)

  mac = __builtin__.property(_get_mac)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('mac', mac), ('state', state), ])


class yc_authenticated_sessions_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/authenticated-sessions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for authenticated sessions state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__authenticated_session',)

  _yang_name = 'authenticated-sessions'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__authenticated_session = YANGDynClass(base=YANGListType("mac",yc_authenticated_session_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session, yang_name="authenticated-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="authenticated-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'authenticated-sessions']

  def _get_authenticated_session(self):
    """
    Getter method for authenticated_session, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session (list)

    YANG Description: The list of authenticated sessions on this device.
    """
    return self.__authenticated_session
      
  def _set_authenticated_session(self, v, load=False):
    """
    Setter method for authenticated_session, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions/authenticated_session (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authenticated_session is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authenticated_session() directly.

    YANG Description: The list of authenticated sessions on this device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac",yc_authenticated_session_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session, yang_name="authenticated-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="authenticated-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authenticated_session must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac",yc_authenticated_session_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session, yang_name="authenticated-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="authenticated-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)""",
        })

    self.__authenticated_session = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authenticated_session(self):
    self.__authenticated_session = YANGDynClass(base=YANGListType("mac",yc_authenticated_session_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions_authenticated_session, yang_name="authenticated-session", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="authenticated-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='list', is_config=True)

  authenticated_session = __builtin__.property(_get_authenticated_session, _set_authenticated_session)


  _pyangbind_elements = OrderedDict([('authenticated_session', authenticated_session), ])


class yc_config_openconfig_interfaces__interfaces_interface_ethernet_poe_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/poe/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for PoE
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'poe', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/ethernet/poe/config/enabled (boolean)

    YANG Description: Enable or disable PoE in the ethernet interface.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/ethernet/poe/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable PoE in the ethernet interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_ethernet_poe_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/poe/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for PoE
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__power_used','__power_class',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=False)
    self.__power_used = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='decimal64', is_config=False)
    self.__power_class = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="power-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'poe', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/ethernet/poe/state/enabled (boolean)

    YANG Description: Enable or disable PoE in the ethernet interface.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/ethernet/poe/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable PoE in the ethernet interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='boolean', is_config=False)


  def _get_power_used(self):
    """
    Getter method for power_used, mapped from YANG variable /interfaces/interface/ethernet/poe/state/power_used (decimal64)

    YANG Description: Power used by the ethernet interface in Watts.
    """
    return self.__power_used
      
  def _set_power_used(self, v, load=False):
    """
    Setter method for power_used, mapped from YANG variable /interfaces/interface/ethernet/poe/state/power_used (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_used() directly.

    YANG Description: Power used by the ethernet interface in Watts.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_used must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='decimal64', is_config=False)""",
        })

    self.__power_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_used(self):
    self.__power_used = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='decimal64', is_config=False)


  def _get_power_class(self):
    """
    Getter method for power_class, mapped from YANG variable /interfaces/interface/ethernet/poe/state/power_class (uint8)

    YANG Description: IEEE 802.3af Power class detected for this ethernet
interface.
    """
    return self.__power_class
      
  def _set_power_class(self, v, load=False):
    """
    Setter method for power_class, mapped from YANG variable /interfaces/interface/ethernet/poe/state/power_class (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_class() directly.

    YANG Description: IEEE 802.3af Power class detected for this ethernet
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="power-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_class must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="power-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='uint8', is_config=False)""",
        })

    self.__power_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_class(self):
    self.__power_class = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="power-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='uint8', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  power_used = __builtin__.property(_get_power_used)
  power_class = __builtin__.property(_get_power_class)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('power_used', power_used), ('power_class', power_class), ])


class yc_poe_openconfig_interfaces__interfaces_interface_ethernet_poe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet/poe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for PoE configuration and state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'poe'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_poe_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_poe_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet', 'poe']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/ethernet/poe/config (container)

    YANG Description: Configuration data for PoE
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/poe/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for PoE
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_poe_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_poe_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_poe_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/poe/state (container)

    YANG Description: Operational state data for PoE
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/poe/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for PoE
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_poe_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_poe_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_poe_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_ethernet_openconfig_interfaces__interfaces_interface_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for ethernet configuration
and state
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__switched_vlan','__dot1x','__authenticated_sessions','__poe',)

  _yang_name = 'ethernet'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    self.__switched_vlan = YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__dot1x = YANGDynClass(base=yc_dot1x_openconfig_interfaces__interfaces_interface_ethernet_dot1x, is_container='container', yang_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    self.__authenticated_sessions = YANGDynClass(base=yc_authenticated_sessions_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions, is_container='container', yang_name="authenticated-sessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    self.__poe = YANGDynClass(base=yc_poe_openconfig_interfaces__interfaces_interface_ethernet_poe, is_container='container', yang_name="poe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'ethernet']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/ethernet/config (container)

    YANG Description: Configuration data for ethernet interfaces
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for ethernet interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/ethernet/state (container)

    YANG Description: State variables for Ethernet interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/ethernet/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State variables for Ethernet interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)


  def _get_switched_vlan(self):
    """
    Getter method for switched_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan (container)

    YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
    """
    return self.__switched_vlan
      
  def _set_switched_vlan(self, v, load=False):
    """
    Setter method for switched_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switched_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switched_vlan() directly.

    YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switched_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__switched_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switched_vlan(self):
    self.__switched_vlan = YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_ethernet_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_dot1x(self):
    """
    Getter method for dot1x, mapped from YANG variable /interfaces/interface/ethernet/dot1x (container)

    YANG Description: Top level container for 802.1X configuration and
state data.
    """
    return self.__dot1x
      
  def _set_dot1x(self, v, load=False):
    """
    Setter method for dot1x, mapped from YANG variable /interfaces/interface/ethernet/dot1x (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1x is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1x() directly.

    YANG Description: Top level container for 802.1X configuration and
state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot1x_openconfig_interfaces__interfaces_interface_ethernet_dot1x, is_container='container', yang_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1x must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot1x_openconfig_interfaces__interfaces_interface_ethernet_dot1x, is_container='container', yang_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__dot1x = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1x(self):
    self.__dot1x = YANGDynClass(base=yc_dot1x_openconfig_interfaces__interfaces_interface_ethernet_dot1x, is_container='container', yang_name="dot1x", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)


  def _get_authenticated_sessions(self):
    """
    Getter method for authenticated_sessions, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions (container)

    YANG Description: Top level container for authenticated sessions state data.
    """
    return self.__authenticated_sessions
      
  def _set_authenticated_sessions(self, v, load=False):
    """
    Setter method for authenticated_sessions, mapped from YANG variable /interfaces/interface/ethernet/authenticated_sessions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authenticated_sessions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authenticated_sessions() directly.

    YANG Description: Top level container for authenticated sessions state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authenticated_sessions_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions, is_container='container', yang_name="authenticated-sessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authenticated_sessions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authenticated_sessions_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions, is_container='container', yang_name="authenticated-sessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)""",
        })

    self.__authenticated_sessions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authenticated_sessions(self):
    self.__authenticated_sessions = YANGDynClass(base=yc_authenticated_sessions_openconfig_interfaces__interfaces_interface_ethernet_authenticated_sessions, is_container='container', yang_name="authenticated-sessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/8021x', defining_module='openconfig-if-8021x', yang_type='container', is_config=True)


  def _get_poe(self):
    """
    Getter method for poe, mapped from YANG variable /interfaces/interface/ethernet/poe (container)

    YANG Description: Top-level container for PoE configuration and state data
    """
    return self.__poe
      
  def _set_poe(self, v, load=False):
    """
    Setter method for poe, mapped from YANG variable /interfaces/interface/ethernet/poe (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_poe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_poe() directly.

    YANG Description: Top-level container for PoE configuration and state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_poe_openconfig_interfaces__interfaces_interface_ethernet_poe, is_container='container', yang_name="poe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """poe must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_poe_openconfig_interfaces__interfaces_interface_ethernet_poe, is_container='container', yang_name="poe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)""",
        })

    self.__poe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_poe(self):
    self.__poe = YANGDynClass(base=yc_poe_openconfig_interfaces__interfaces_interface_ethernet_poe, is_container='container', yang_name="poe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/poe', defining_module='openconfig-if-poe', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  switched_vlan = __builtin__.property(_get_switched_vlan, _set_switched_vlan)
  dot1x = __builtin__.property(_get_dot1x, _set_dot1x)
  authenticated_sessions = __builtin__.property(_get_authenticated_sessions, _set_authenticated_sessions)
  poe = __builtin__.property(_get_poe, _set_poe)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('switched_vlan', switched_vlan), ('dot1x', dot1x), ('authenticated_sessions', authenticated_sessions), ('poe', poe), ])


class yc_config_openconfig_interfaces__interfaces_interface_aggregation_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration variables for logical aggregate /
LAG interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__lag_type','__min_links',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=True)
    self.__min_links = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation', 'config']

  def _get_lag_type(self):
    """
    Getter method for lag_type, mapped from YANG variable /interfaces/interface/aggregation/config/lag_type (aggregation-type)

    YANG Description: Sets the type of LAG, i.e., how it is
configured / maintained
    """
    return self.__lag_type
      
  def _set_lag_type(self, v, load=False):
    """
    Setter method for lag_type, mapped from YANG variable /interfaces/interface/aggregation/config/lag_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lag_type() directly.

    YANG Description: Sets the type of LAG, i.e., how it is
configured / maintained
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lag_type must be of a type compatible with aggregation-type""",
          'defined-type': "openconfig-if-aggregate:aggregation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=True)""",
        })

    self.__lag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lag_type(self):
    self.__lag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=True)


  def _get_min_links(self):
    """
    Getter method for min_links, mapped from YANG variable /interfaces/interface/aggregation/config/min_links (uint16)

    YANG Description: Specifies the mininum number of member
interfaces that must be active for the aggregate interface
to be available
    """
    return self.__min_links
      
  def _set_min_links(self, v, load=False):
    """
    Setter method for min_links, mapped from YANG variable /interfaces/interface/aggregation/config/min_links (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_links() directly.

    YANG Description: Specifies the mininum number of member
interfaces that must be active for the aggregate interface
to be available
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_links must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=True)""",
        })

    self.__min_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_links(self):
    self.__min_links = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=True)

  lag_type = __builtin__.property(_get_lag_type, _set_lag_type)
  min_links = __builtin__.property(_get_min_links, _set_min_links)


  _pyangbind_elements = OrderedDict([('lag_type', lag_type), ('min_links', min_links), ])


class yc_state_openconfig_interfaces__interfaces_interface_aggregation_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state variables for logical
aggregate / LAG interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__lag_type','__min_links','__lag_speed','__member',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=False)
    self.__min_links = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=False)
    self.__lag_speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lag-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint32', is_config=False)
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='oc-if:base-interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation', 'state']

  def _get_lag_type(self):
    """
    Getter method for lag_type, mapped from YANG variable /interfaces/interface/aggregation/state/lag_type (aggregation-type)

    YANG Description: Sets the type of LAG, i.e., how it is
configured / maintained
    """
    return self.__lag_type
      
  def _set_lag_type(self, v, load=False):
    """
    Setter method for lag_type, mapped from YANG variable /interfaces/interface/aggregation/state/lag_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lag_type() directly.

    YANG Description: Sets the type of LAG, i.e., how it is
configured / maintained
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lag_type must be of a type compatible with aggregation-type""",
          'defined-type': "openconfig-if-aggregate:aggregation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=False)""",
        })

    self.__lag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lag_type(self):
    self.__lag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LACP': {}, 'STATIC': {}},), is_leaf=True, yang_name="lag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='aggregation-type', is_config=False)


  def _get_min_links(self):
    """
    Getter method for min_links, mapped from YANG variable /interfaces/interface/aggregation/state/min_links (uint16)

    YANG Description: Specifies the mininum number of member
interfaces that must be active for the aggregate interface
to be available
    """
    return self.__min_links
      
  def _set_min_links(self, v, load=False):
    """
    Setter method for min_links, mapped from YANG variable /interfaces/interface/aggregation/state/min_links (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_links() directly.

    YANG Description: Specifies the mininum number of member
interfaces that must be active for the aggregate interface
to be available
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_links must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=False)""",
        })

    self.__min_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_links(self):
    self.__min_links = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="min-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint16', is_config=False)


  def _get_lag_speed(self):
    """
    Getter method for lag_speed, mapped from YANG variable /interfaces/interface/aggregation/state/lag_speed (uint32)

    YANG Description: Reports effective speed of the aggregate interface,
based on speed of active member interfaces
    """
    return self.__lag_speed
      
  def _set_lag_speed(self, v, load=False):
    """
    Setter method for lag_speed, mapped from YANG variable /interfaces/interface/aggregation/state/lag_speed (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lag_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lag_speed() directly.

    YANG Description: Reports effective speed of the aggregate interface,
based on speed of active member interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lag-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lag_speed must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lag-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint32', is_config=False)""",
        })

    self.__lag_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lag_speed(self):
    self.__lag_speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lag-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='uint32', is_config=False)


  def _get_member(self):
    """
    Getter method for member, mapped from YANG variable /interfaces/interface/aggregation/state/member (oc-if:base-interface-ref)

    YANG Description: List of current member interfaces for the aggregate,
expressed as references to existing interfaces
    """
    return self.__member
      
  def _set_member(self, v, load=False):
    """
    Setter method for member, mapped from YANG variable /interfaces/interface/aggregation/state/member (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member() directly.

    YANG Description: List of current member interfaces for the aggregate,
expressed as references to existing interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member(self):
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='oc-if:base-interface-ref', is_config=False)

  lag_type = __builtin__.property(_get_lag_type)
  min_links = __builtin__.property(_get_min_links)
  lag_speed = __builtin__.property(_get_lag_speed)
  member = __builtin__.property(_get_member)


  _pyangbind_elements = OrderedDict([('lag_type', lag_type), ('min_links', min_links), ('lag_speed', lag_speed), ('member', member), ])


class yc_config_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation/switched-vlan/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_mode','__native_vlan','__access_vlan','__trunk_vlans',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation', 'switched-vlan', 'config']

  def _get_interface_mode(self):
    """
    Getter method for interface_mode, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/interface_mode (oc-vlan-types:vlan-mode-type)

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    return self.__interface_mode
      
  def _set_interface_mode(self, v, load=False):
    """
    Setter method for interface_mode, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/interface_mode (oc-vlan-types:vlan-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode() directly.

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode must be of a type compatible with oc-vlan-types:vlan-mode-type""",
          'defined-type': "oc-vlan-types:vlan-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)""",
        })

    self.__interface_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode(self):
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=True)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/native_vlan (oc-vlan-types:vlan-id)

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/native_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_access_vlan(self):
    """
    Getter method for access_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/access_vlan (oc-vlan-types:vlan-id)

    YANG Description: Assign the access vlan to the access port.
    """
    return self.__access_vlan
      
  def _set_access_vlan(self, v, load=False):
    """
    Setter method for access_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/access_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_vlan() directly.

    YANG Description: Assign the access vlan to the access port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__access_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_vlan(self):
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_trunk_vlans(self):
    """
    Getter method for trunk_vlans, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/trunk_vlans (union)

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    return self.__trunk_vlans
      
  def _set_trunk_vlans(self, v, load=False):
    """
    Setter method for trunk_vlans, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config/trunk_vlans (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_vlans() directly.

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trunk_vlans must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)""",
        })

    self.__trunk_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trunk_vlans(self):
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

  interface_mode = __builtin__.property(_get_interface_mode, _set_interface_mode)
  native_vlan = __builtin__.property(_get_native_vlan, _set_native_vlan)
  access_vlan = __builtin__.property(_get_access_vlan, _set_access_vlan)
  trunk_vlans = __builtin__.property(_get_trunk_vlans, _set_trunk_vlans)


  _pyangbind_elements = OrderedDict([('interface_mode', interface_mode), ('native_vlan', native_vlan), ('access_vlan', access_vlan), ('trunk_vlans', trunk_vlans), ])


class yc_state_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation/switched-vlan/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State variables for VLANs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_mode','__native_vlan','__access_vlan','__trunk_vlans',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation', 'switched-vlan', 'state']

  def _get_interface_mode(self):
    """
    Getter method for interface_mode, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/interface_mode (oc-vlan-types:vlan-mode-type)

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    return self.__interface_mode
      
  def _set_interface_mode(self, v, load=False):
    """
    Setter method for interface_mode, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/interface_mode (oc-vlan-types:vlan-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode() directly.

    YANG Description: Set the interface to access or trunk mode for
VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode must be of a type compatible with oc-vlan-types:vlan-mode-type""",
          'defined-type': "oc-vlan-types:vlan-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)""",
        })

    self.__interface_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode(self):
    self.__interface_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACCESS': {}, 'TRUNK': {}},), is_leaf=True, yang_name="interface-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-mode-type', is_config=False)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/native_vlan (oc-vlan-types:vlan-id)

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/native_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Set the native VLAN id for untagged frames arriving on
a trunk interface.  Tagged frames sent on an interface
configured with a native VLAN should have their tags
stripped prior to transmission. This configuration is only
valid on a trunk interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="native-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_access_vlan(self):
    """
    Getter method for access_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/access_vlan (oc-vlan-types:vlan-id)

    YANG Description: Assign the access vlan to the access port.
    """
    return self.__access_vlan
      
  def _set_access_vlan(self, v, load=False):
    """
    Setter method for access_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/access_vlan (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_vlan() directly.

    YANG Description: Assign the access vlan to the access port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_vlan must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__access_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_vlan(self):
    self.__access_vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="access-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_trunk_vlans(self):
    """
    Getter method for trunk_vlans, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/trunk_vlans (union)

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    return self.__trunk_vlans
      
  def _set_trunk_vlans(self, v, load=False):
    """
    Setter method for trunk_vlans, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state/trunk_vlans (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_vlans() directly.

    YANG Description: Specify VLANs, or ranges thereof, that the interface may
carry when in trunk mode.  If not specified, all VLANs are
allowed on the interface. Ranges are specified in the form
x..y, where x<y - ranges are assumed to be inclusive (such
that the VLAN range is x <= range <= y.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trunk_vlans must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)""",
        })

    self.__trunk_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trunk_vlans(self):
    self.__trunk_vlans = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])\\.\\.(409[0-4]|40[0-8][0-9]|[1-3][0-9]{3}|[1-9][0-9]{1,2}|[1-9])'}),]), is_leaf=False, yang_name="trunk-vlans", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

  interface_mode = __builtin__.property(_get_interface_mode)
  native_vlan = __builtin__.property(_get_native_vlan)
  access_vlan = __builtin__.property(_get_access_vlan)
  trunk_vlans = __builtin__.property(_get_trunk_vlans)


  _pyangbind_elements = OrderedDict([('interface_mode', interface_mode), ('native_vlan', native_vlan), ('access_vlan', access_vlan), ('trunk_vlans', trunk_vlans), ])


class yc_switched_vlan_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation/switched-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'switched-vlan'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation', 'switched-vlan']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config (container)

    YANG Description: Configuration parameters for VLANs
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state (container)

    YANG Description: State variables for VLANs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State variables for VLANs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_aggregation_openconfig_interfaces__interfaces_interface_aggregation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/aggregation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Options for logical interfaces representing
aggregates
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__switched_vlan',)

  _yang_name = 'aggregation'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    self.__switched_vlan = YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'aggregation']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/aggregation/config (container)

    YANG Description: Configuration variables for logical aggregate /
LAG interfaces
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/aggregation/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration variables for logical aggregate /
LAG interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_aggregation_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/aggregation/state (container)

    YANG Description: Operational state variables for logical
aggregate / LAG interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/aggregation/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state variables for logical
aggregate / LAG interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_aggregation_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)


  def _get_switched_vlan(self):
    """
    Getter method for switched_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan (container)

    YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
    """
    return self.__switched_vlan
      
  def _set_switched_vlan(self, v, load=False):
    """
    Setter method for switched_vlan, mapped from YANG variable /interfaces/interface/aggregation/switched_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switched_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switched_vlan() directly.

    YANG Description: Enclosing container for VLAN interface-specific
data on Ethernet interfaces.  These are for standard
L2, switched-style VLANs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switched_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__switched_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switched_vlan(self):
    self.__switched_vlan = YANGDynClass(base=yc_switched_vlan_openconfig_interfaces__interfaces_interface_aggregation_switched_vlan, is_container='container', yang_name="switched-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  switched_vlan = __builtin__.property(_get_switched_vlan, _set_switched_vlan)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('switched_vlan', switched_vlan), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for routed vlan interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'config']

  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /interfaces/interface/routed_vlan/config/vlan (union)

    YANG Description: References the VLAN for which this IP interface
provides routing services -- similar to a switch virtual
interface (SVI), or integrated routing and bridging interface
(IRB) in some implementations.
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /interfaces/interface/routed_vlan/config/vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: References the VLAN for which this IP interface
provides routing services -- similar to a switch virtual
interface (SVI), or integrated routing and bridging interface
(IRB) in some implementations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=True)

  vlan = __builtin__.property(_get_vlan, _set_vlan)


  _pyangbind_elements = OrderedDict([('vlan', vlan), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'state']

  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /interfaces/interface/routed_vlan/state/vlan (union)

    YANG Description: References the VLAN for which this IP interface
provides routing services -- similar to a switch virtual
interface (SVI), or integrated routing and bridging interface
(IRB) in some implementations.
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /interfaces/interface/routed_vlan/state/vlan (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: References the VLAN for which this IP interface
provides routing services -- similar to a switch virtual
interface (SVI), or integrated routing and bridging interface
(IRB) in some implementations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with union""",
          'defined-type': "openconfig-vlan:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),six.text_type,], is_leaf=True, yang_name="vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='union', is_config=False)

  vlan = __builtin__.property(_get_vlan)


  _pyangbind_elements = OrderedDict([('vlan', vlan), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-ip:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-ip:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ipv4-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'config']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address, _set_virtual_address)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay, _set_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode, _set_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__current_priority',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'state']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_current_priority(self):
    """
    Getter method for current_priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    return self.__current_priority
      
  def _set_current_priority(self, v, load=False):
    """
    Setter method for current_priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_priority() directly.

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__current_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_priority(self):
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  virtual_router_id = __builtin__.property(_get_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address)
  priority = __builtin__.property(_get_priority)
  preempt = __builtin__.property(_get_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval)
  current_priority = __builtin__.property(_get_current_priority)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('current_priority', current_priority), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'config']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

  track_interface = __builtin__.property(_get_track_interface, _set_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement, _set_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'state']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  track_interface = __builtin__.property(_get_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-tracking'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)

    YANG Description: Configuration data for VRRP interface tracking
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)

    YANG Description: Operational state data for VRRP interface tracking
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VRRP groups, keyed by virtual router id
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__config','__state','__interface_tracking',)

  _yang_name = 'vrrp-group'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp', 'vrrp-group']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config (container)

    YANG Description: Configuration data for the VRRP group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state (container)

    YANG Description: Operational state data for the VRRP group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_tracking(self):
    """
    Getter method for interface_tracking, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking (container)

    YANG Description: Top-level container for VRRP interface tracking
    """
    return self.__interface_tracking
      
  def _set_interface_tracking(self, v, load=False):
    """
    Setter method for interface_tracking, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/interface_tracking (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_tracking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_tracking() directly.

    YANG Description: Top-level container for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_tracking must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_tracking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_tracking(self):
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_tracking = __builtin__.property(_get_interface_tracking, _set_interface_tracking)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('config', config), ('state', state), ('interface_tracking', interface_tracking), ])


class yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VRRP groups handled by this
IP interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrrp_group',)

  _yang_name = 'vrrp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address', 'vrrp']

  def _get_vrrp_group(self):
    """
    Getter method for vrrp_group, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group (list)

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    return self.__vrrp_group
      
  def _set_vrrp_group(self, v, load=False):
    """
    Setter method for vrrp_group, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_group() directly.

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__vrrp_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_group(self):
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  vrrp_group = __builtin__.property(_get_vrrp_group, _set_vrrp_group)


  _pyangbind_elements = OrderedDict([('vrrp_group', vrrp_group), ])


class yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv4 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state','__vrrp',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp (container)

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ('vrrp', vrrp), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address (list)

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/proxy-arp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'proxy-arp', 'config']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/config/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/config/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/proxy-arp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'proxy-arp', 'state']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/state/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/state/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  mode = __builtin__.property(_get_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_proxy_arp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/proxy-arp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'proxy-arp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'proxy-arp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/config (container)

    YANG Description: Configuration parameters for proxy ARP
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/state (container)

    YANG Description: Operational state parameters for proxy ARP
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for neighbor list
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor (list)

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level IPv4 configuration data for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level IPv4 operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_ipv4_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv4 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__proxy_arp','__neighbors','__unnumbered','__config','__state',)

  _yang_name = 'ipv4'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv4']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_proxy_arp(self):
    """
    Getter method for proxy_arp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp (container)

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    return self.__proxy_arp
      
  def _set_proxy_arp(self, v, load=False):
    """
    Setter method for proxy_arp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/proxy_arp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy_arp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy_arp() directly.

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy_arp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__proxy_arp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy_arp(self):
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors (container)

    YANG Description: Enclosing container for neighbor list
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for neighbor list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config (container)

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state (container)

    YANG Description: Top level IPv4 operational state data
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level IPv4 operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  proxy_arp = __builtin__.property(_get_proxy_arp, _set_proxy_arp)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('proxy_arp', proxy_arp), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin','__status',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-ip:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='ip-address-origin', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/status (enumeration)

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ('status', status), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__virtual_link_local',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'config']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=True)


  def _get_virtual_link_local(self):
    """
    Getter method for virtual_link_local, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_link_local (oc-inet:ip-address)

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    return self.__virtual_link_local
      
  def _set_virtual_link_local(self, v, load=False):
    """
    Setter method for virtual_link_local, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config/virtual_link_local (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_local() directly.

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_link_local must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__virtual_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_link_local(self):
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address, _set_virtual_address)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay, _set_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode, _set_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)
  virtual_link_local = __builtin__.property(_get_virtual_link_local, _set_virtual_link_local)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('virtual_link_local', virtual_link_local), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the VRRP group
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__virtual_address','__priority','__preempt','__preempt_delay','__accept_mode','__advertisement_interval','__current_priority','__virtual_link_local',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'state']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_router_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: Set the virtual router id for use by the VRRP group.  This
usually also determines the virtual MAC address that is
generated for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_address(self):
    """
    Getter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    return self.__virtual_address
      
  def _set_virtual_address(self, v, load=False):
    """
    Setter method for virtual_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_address() directly.

    YANG Description: Configure one or more virtual addresses for the
VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_address(self):
    self.__virtual_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),]), is_leaf=False, yang_name="virtual-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/priority (uint8)

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the sending VRRP interface's priority
for the virtual router.  Higher values equal higher
priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(100), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/preempt (boolean)

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true, enables preemption by a higher
priority backup router of a lower priority master router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_preempt_delay(self):
    """
    Getter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    return self.__preempt_delay
      
  def _set_preempt_delay(self, v, load=False):
    """
    Setter method for preempt_delay, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/preempt_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_delay() directly.

    YANG Description: Set the delay the higher priority router waits
before preempting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__preempt_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_delay(self):
    self.__preempt_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="preempt-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_accept_mode(self):
    """
    Getter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    return self.__accept_mode
      
  def _set_accept_mode(self, v, load=False):
    """
    Setter method for accept_mode, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/accept_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_mode() directly.

    YANG Description: Configure whether packets destined for
virtual addresses are accepted even when the virtual
address is not owned by the router interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__accept_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_mode(self):
    self.__accept_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="accept-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: Sets the interval between successive VRRP
advertisements -- RFC 5798 defines this as a 12-bit
value expressed as 0.1 seconds, with default 100, i.e.,
1 second.  Several implementation express this in units of
seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4095']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(100), is_leaf=True, yang_name="advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint16', is_config=False)


  def _get_current_priority(self):
    """
    Getter method for current_priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    return self.__current_priority
      
  def _set_current_priority(self, v, load=False):
    """
    Setter method for current_priority, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_priority() directly.

    YANG Description: Operational value of the priority for the
interface in the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__current_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_priority(self):
    self.__current_priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="current-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)


  def _get_virtual_link_local(self):
    """
    Getter method for virtual_link_local, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_link_local (oc-inet:ip-address)

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    return self.__virtual_link_local
      
  def _set_virtual_link_local(self, v, load=False):
    """
    Setter method for virtual_link_local, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_link_local (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_local() directly.

    YANG Description: For VRRP on IPv6 interfaces, sets the virtual link local
address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_link_local must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__virtual_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_link_local(self):
    self.__virtual_link_local = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="virtual-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ip-address', is_config=False)

  virtual_router_id = __builtin__.property(_get_virtual_router_id)
  virtual_address = __builtin__.property(_get_virtual_address)
  priority = __builtin__.property(_get_priority)
  preempt = __builtin__.property(_get_preempt)
  preempt_delay = __builtin__.property(_get_preempt_delay)
  accept_mode = __builtin__.property(_get_accept_mode)
  advertisement_interval = __builtin__.property(_get_advertisement_interval)
  current_priority = __builtin__.property(_get_current_priority)
  virtual_link_local = __builtin__.property(_get_virtual_link_local)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('virtual_address', virtual_address), ('priority', priority), ('preempt', preempt), ('preempt_delay', preempt_delay), ('accept_mode', accept_mode), ('advertisement_interval', advertisement_interval), ('current_priority', current_priority), ('virtual_link_local', virtual_link_local), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'config']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=True)

  track_interface = __builtin__.property(_get_track_interface, _set_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement, _set_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__track_interface','__priority_decrement',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking', 'state']

  def _get_track_interface(self):
    """
    Getter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    return self.__track_interface
      
  def _set_track_interface(self, v, load=False):
    """
    Setter method for track_interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/track_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_track_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_track_interface() directly.

    YANG Description: Sets a list of one or more interfaces that should
be tracked for up/down events to dynamically change the
priority state of the VRRP group, and potentially
change the mastership if the tracked interface going
down lowers the priority sufficiently.  Any of the tracked
interfaces going down will cause the priority to be lowered.
Some implementations may only support a single
tracked interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """track_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__track_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_track_interface(self):
    self.__track_interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="track-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_priority_decrement(self):
    """
    Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    return self.__priority_decrement
      
  def _set_priority_decrement(self, v, load=False):
    """
    Setter method for priority_decrement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_decrement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_decrement() directly.

    YANG Description: Set the value to subtract from priority when
the tracked interface goes down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_decrement must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)""",
        })

    self.__priority_decrement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_decrement(self):
    self.__priority_decrement = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..254']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="priority-decrement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint8', is_config=False)

  track_interface = __builtin__.property(_get_track_interface)
  priority_decrement = __builtin__.property(_get_priority_decrement)


  _pyangbind_elements = OrderedDict([('track_interface', track_interface), ('priority_decrement', priority_decrement), ])


class yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for VRRP interface tracking
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-tracking'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group', 'interface-tracking']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)

    YANG Description: Configuration data for VRRP interface tracking
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)

    YANG Description: Operational state data for VRRP interface tracking
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VRRP groups, keyed by virtual router id
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtual_router_id','__config','__state','__interface_tracking',)

  _yang_name = 'vrrp-group'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp', 'vrrp-group']

  def _get_virtual_router_id(self):
    """
    Getter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    return self.__virtual_router_id
      
  def _set_virtual_router_id(self, v, load=False):
    """
    Setter method for virtual_router_id, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/virtual_router_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_router_id() directly.

    YANG Description: References the configured virtual router id for this
VRRP group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_router_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__virtual_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_router_id(self):
    self.__virtual_router_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config (container)

    YANG Description: Configuration data for the VRRP group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state (container)

    YANG Description: Operational state data for the VRRP group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the VRRP group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_tracking(self):
    """
    Getter method for interface_tracking, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking (container)

    YANG Description: Top-level container for VRRP interface tracking
    """
    return self.__interface_tracking
      
  def _set_interface_tracking(self, v, load=False):
    """
    Setter method for interface_tracking, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_tracking is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_tracking() directly.

    YANG Description: Top-level container for VRRP interface tracking
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_tracking must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_tracking = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_tracking(self):
    self.__interface_tracking = YANGDynClass(base=yc_interface_tracking_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group_interface_tracking, is_container='container', yang_name="interface-tracking", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  virtual_router_id = __builtin__.property(_get_virtual_router_id, _set_virtual_router_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_tracking = __builtin__.property(_get_interface_tracking, _set_interface_tracking)


  _pyangbind_elements = OrderedDict([('virtual_router_id', virtual_router_id), ('config', config), ('state', state), ('interface_tracking', interface_tracking), ])


class yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for VRRP groups handled by this
IP interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrrp_group',)

  _yang_name = 'vrrp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address', 'vrrp']

  def _get_vrrp_group(self):
    """
    Getter method for vrrp_group, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group (list)

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    return self.__vrrp_group
      
  def _set_vrrp_group(self, v, load=False):
    """
    Setter method for vrrp_group, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp/vrrp_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_group() directly.

    YANG Description: List of VRRP groups, keyed by virtual router id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__vrrp_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_group(self):
    self.__vrrp_group = YANGDynClass(base=YANGListType("virtual_router_id",yc_vrrp_group_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp_vrrp_group, yang_name="vrrp-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-router-id', extensions=None), is_container='list', yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  vrrp_group = __builtin__.property(_get_vrrp_group, _set_vrrp_group)


  _pyangbind_elements = OrderedDict([('vrrp_group', vrrp_group), ])


class yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv6 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state','__vrrp',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp (container)

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.

    YANG Description: Enclosing container for VRRP groups handled by this
IP interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=yc_vrrp_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ('vrrp', vrrp), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address (list)

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to router advertisements
for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'config']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  lifetime = __builtin__.property(_get_lifetime, _set_lifetime)
  suppress = __builtin__.property(_get_suppress, _set_suppress)
  managed = __builtin__.property(_get_managed, _set_managed)
  other_config = __builtin__.property(_get_other_config, _set_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to router
advertisements for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'state']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  interval = __builtin__.property(_get_interval)
  lifetime = __builtin__.property(_get_lifetime)
  suppress = __builtin__.property(_get_suppress)
  managed = __builtin__.property(_get_managed)
  other_config = __builtin__.property(_get_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes/prefix/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'config']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=True)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime, _set_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime, _set_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement, _set_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration, _set_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink, _set_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes/prefix/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'state']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-prefix', is_config=False)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_prefix_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes/prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__config','__state',)

  _yang_name = 'prefix'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'prefixes', 'prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config (container)

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state (container)

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('config', config), ('state', state), ])


class yc_prefixes_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix',)

  _yang_name = 'prefixes'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement', 'prefixes']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix (list)

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes/prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ])


class yc_router_advertisement_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/router-advertisement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters relating to
router advertisements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__prefixes',)

  _yang_name = 'router-advertisement'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'router-advertisement']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config (container)

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state (container)

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_prefixes(self):
    """
    Getter method for prefixes, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes (container)

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    return self.__prefixes
      
  def _set_prefixes(self, v, load=False):
    """
    Setter method for prefixes, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement/prefixes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixes() directly.

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefixes_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixes(self):
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  prefixes = __builtin__.property(_get_prefixes, _set_prefixes)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('prefixes', prefixes), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin','__is_router','__neighbor_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-ip:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='neighbor-origin', is_config=False)


  def _get_is_router(self):
    """
    Getter method for is_router, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/is_router (boolean)

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    return self.__is_router
      
  def _set_is_router(self, v, load=False):
    """
    Setter method for is_router, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/is_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_router() directly.

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_router(self):
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_neighbor_state(self):
    """
    Getter method for neighbor_state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    return self.__neighbor_state
      
  def _set_neighbor_state(self, v, load=False):
    """
    Setter method for neighbor_state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_state() directly.

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__neighbor_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_state(self):
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)
  is_router = __builtin__.property(_get_is_router)
  neighbor_state = __builtin__.property(_get_neighbor_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ('is_router', is_router), ('neighbor_state', neighbor_state), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP neighbor address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP neighbor address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor (list)

    YANG Description: List of IPv6 neighbors
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level config data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits, _set_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level operational state data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_ipv6_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv6 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__router_advertisement','__neighbors','__unnumbered','__config','__state',)

  _yang_name = 'ipv6'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan', 'ipv6']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_router_advertisement(self):
    """
    Getter method for router_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement (container)

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    return self.__router_advertisement
      
  def _set_router_advertisement(self, v, load=False):
    """
    Setter method for router_advertisement, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/router_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_advertisement() directly.

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__router_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_advertisement(self):
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors (container)

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config (container)

    YANG Description: Top-level config data for the IPv6 interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level config data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state (container)

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  router_advertisement = __builtin__.property(_get_router_advertisement, _set_router_advertisement)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('router_advertisement', router_advertisement), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ])


class yc_routed_vlan_openconfig_interfaces__interfaces_interface_routed_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/routed-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for routed vlan interfaces.  These
logical interfaces are also known as SVI (switched virtual
interface), IRB (integrated routing and bridging), RVI
(routed VLAN interface)
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__ipv4','__ipv6',)

  _yang_name = 'routed-vlan'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'routed-vlan']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/config (container)

    YANG Description: Configuration data for routed vlan interfaces
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for routed vlan interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_routed_vlan_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/routed_vlan/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_routed_vlan_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4 (container)

    YANG Description: Parameters for the IPv4 address family.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Parameters for the IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_routed_vlan_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6 (container)

    YANG Description: Parameters for the IPv6 address family.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Parameters for the IPv6 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_routed_vlan_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters associated with the
tunnel interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__src','__dst','__ttl','__gre_key',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)
    self.__dst = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    self.__gre_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'config']

  def _get_src(self):
    """
    Getter method for src, mapped from YANG variable /interfaces/interface/tunnel/config/src (oc-inet:ip-address)

    YANG Description: The source address that should be used for the
tunnel.
    """
    return self.__src
      
  def _set_src(self, v, load=False):
    """
    Setter method for src, mapped from YANG variable /interfaces/interface/tunnel/config/src (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src() directly.

    YANG Description: The source address that should be used for the
tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__src = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src(self):
    self.__src = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)


  def _get_dst(self):
    """
    Getter method for dst, mapped from YANG variable /interfaces/interface/tunnel/config/dst (oc-inet:ip-address)

    YANG Description: The destination address for the tunnel.
    """
    return self.__dst
      
  def _set_dst(self, v, load=False):
    """
    Setter method for dst, mapped from YANG variable /interfaces/interface/tunnel/config/dst (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst() directly.

    YANG Description: The destination address for the tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__dst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst(self):
    self.__dst = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /interfaces/interface/tunnel/config/ttl (uint8)

    YANG Description: The time-to-live (or hop limit) that should be utilised
for the IP packets used for the tunnel transport.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /interfaces/interface/tunnel/config/ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: The time-to-live (or hop limit) that should be utilised
for the IP packets used for the tunnel transport.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)


  def _get_gre_key(self):
    """
    Getter method for gre_key, mapped from YANG variable /interfaces/interface/tunnel/config/gre_key (uint32)

    YANG Description: The GRE key to be specified for the tunnel. The
key is used to identify a traffic flow within
a tunnel.
    """
    return self.__gre_key
      
  def _set_gre_key(self, v, load=False):
    """
    Setter method for gre_key, mapped from YANG variable /interfaces/interface/tunnel/config/gre_key (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gre_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gre_key() directly.

    YANG Description: The GRE key to be specified for the tunnel. The
key is used to identify a traffic flow within
a tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gre_key must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__gre_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gre_key(self):
    self.__gre_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)

  src = __builtin__.property(_get_src, _set_src)
  dst = __builtin__.property(_get_dst, _set_dst)
  ttl = __builtin__.property(_get_ttl, _set_ttl)
  gre_key = __builtin__.property(_get_gre_key, _set_gre_key)


  _pyangbind_elements = OrderedDict([('src', src), ('dst', dst), ('ttl', ttl), ('gre_key', gre_key), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters associated with
the tunnel interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__src','__dst','__ttl','__gre_key',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)
    self.__dst = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    self.__gre_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'state']

  def _get_src(self):
    """
    Getter method for src, mapped from YANG variable /interfaces/interface/tunnel/state/src (oc-inet:ip-address)

    YANG Description: The source address that should be used for the
tunnel.
    """
    return self.__src
      
  def _set_src(self, v, load=False):
    """
    Setter method for src, mapped from YANG variable /interfaces/interface/tunnel/state/src (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src() directly.

    YANG Description: The source address that should be used for the
tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__src = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src(self):
    self.__src = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="src", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)


  def _get_dst(self):
    """
    Getter method for dst, mapped from YANG variable /interfaces/interface/tunnel/state/dst (oc-inet:ip-address)

    YANG Description: The destination address for the tunnel.
    """
    return self.__dst
      
  def _set_dst(self, v, load=False):
    """
    Setter method for dst, mapped from YANG variable /interfaces/interface/tunnel/state/dst (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst() directly.

    YANG Description: The destination address for the tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)""",
        })

    self.__dst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst(self):
    self.__dst = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="dst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ip-address', is_config=False)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /interfaces/interface/tunnel/state/ttl (uint8)

    YANG Description: The time-to-live (or hop limit) that should be utilised
for the IP packets used for the tunnel transport.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /interfaces/interface/tunnel/state/ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: The time-to-live (or hop limit) that should be utilised
for the IP packets used for the tunnel transport.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)


  def _get_gre_key(self):
    """
    Getter method for gre_key, mapped from YANG variable /interfaces/interface/tunnel/state/gre_key (uint32)

    YANG Description: The GRE key to be specified for the tunnel. The
key is used to identify a traffic flow within
a tunnel.
    """
    return self.__gre_key
      
  def _set_gre_key(self, v, load=False):
    """
    Setter method for gre_key, mapped from YANG variable /interfaces/interface/tunnel/state/gre_key (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gre_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gre_key() directly.

    YANG Description: The GRE key to be specified for the tunnel. The
key is used to identify a traffic flow within
a tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gre_key must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__gre_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gre_key(self):
    self.__gre_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gre-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)

  src = __builtin__.property(_get_src)
  dst = __builtin__.property(_get_dst)
  ttl = __builtin__.property(_get_ttl)
  gre_key = __builtin__.property(_get_gre_key)


  _pyangbind_elements = OrderedDict([('src', src), ('dst', dst), ('ttl', ttl), ('gre_key', gre_key), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-tunnel:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/type (ipv4-address-type)

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/type (ipv4-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv4 address being assigned
to the interface. By default, addresses are assumed to be a primary address.
Where secondary addresses is to be configured, this leaf should be set
to SECONDARY.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-type""",
          'defined-type': "openconfig-if-tunnel:ipv4-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("PRIMARY"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ipv4-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., statically configured,
assigned by DHCP, etc..
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-tunnel:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ])


class yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv4 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address (list)

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv4 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/proxy-arp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'proxy-arp', 'config']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/config/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/config/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-tunnel:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/proxy-arp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters for proxy ARP
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'proxy-arp', 'state']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/state/mode (enumeration)

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/state/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: When set to a value other than DISABLE, the local system should
respond to ARP requests that are for target addresses other than
those that are configured on the local subinterface using its own
MAC address as the target hardware address. If the REMOTE_ONLY
value is specified, replies are only sent when the target address
falls outside the locally configured subnets on the interface,
whereas with the ALL value, all requests, regardless of their
target address are replied to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-tunnel:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DISABLE': {}, 'REMOTE_ONLY': {}, 'ALL': {}},), default=six.text_type("DISABLE"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

  mode = __builtin__.property(_get_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_proxy_arp_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/proxy-arp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'proxy-arp'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'proxy-arp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/config (container)

    YANG Description: Configuration parameters for proxy ARP
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/state (container)

    YANG Description: Operational state parameters for proxy ARP
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters for proxy ARP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each configured IPv4
address on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each IPv4 address
configured on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/ip (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv4 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry, static or dynamic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-tunnel:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each configured IPv4
address on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state (container)

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each IPv4 address
configured on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for neighbor list
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor (list)

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A list of mappings from IPv4 addresses to
link-layer addresses.

Entries in this list are used as static entries in the
ARP Cache.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level IPv4 configuration data for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level IPv4 operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/enabled (boolean)

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv4 is enabled or disabled on this
interface.  When IPv4 is enabled, this interface is
connected to an IPv4 stack, and the interface can send
and receive IPv4 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/mtu (uint16)

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv4 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['68..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint16', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_ipv4_openconfig_interfaces__interfaces_interface_tunnel_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv4 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__proxy_arp','__neighbors','__unnumbered','__config','__state',)

  _yang_name = 'ipv4'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv4']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/tunnel/ipv4/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_proxy_arp(self):
    """
    Getter method for proxy_arp, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp (container)

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    return self.__proxy_arp
      
  def _set_proxy_arp(self, v, load=False):
    """
    Setter method for proxy_arp, mapped from YANG variable /interfaces/interface/tunnel/ipv4/proxy_arp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy_arp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy_arp() directly.

    YANG Description: Configuration and operational state parameters
relating to proxy ARP. This functionality allows a
system to respond to ARP requests that are not
explicitly destined to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy_arp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__proxy_arp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy_arp(self):
    self.__proxy_arp = YANGDynClass(base=yc_proxy_arp_openconfig_interfaces__interfaces_interface_tunnel_ipv4_proxy_arp, is_container='container', yang_name="proxy-arp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors (container)

    YANG Description: Enclosing container for neighbor list
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/tunnel/ipv4/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for neighbor list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv4_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/tunnel/ipv4/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv4_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config (container)

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv4/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level IPv4 configuration data for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv4_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state (container)

    YANG Description: Top level IPv4 operational state data
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv4/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level IPv4 operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  proxy_arp = __builtin__.property(_get_proxy_arp, _set_proxy_arp)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('proxy_arp', proxy_arp), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/addresses/address/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'addresses', 'address', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/addresses/address/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__origin','__status',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'addresses', 'address', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address on the interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/prefix_length (uint8)

    YANG Description: The length of the subnet prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: The length of the subnet prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint8', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/type (oc-inet:ipv6-address-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the explicit type of the IPv6 address being assigned
to the interface. By default, addresses are assumed to be
global unicast.  Where a link-local address is to be explicitly
configured, this leaf should be set to LINK_LOCAL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with oc-inet:ipv6-address-type""",
          'defined-type': "oc-inet:ipv6-address-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GLOBAL_UNICAST': {}, 'LINK_LOCAL_UNICAST': {}},), default=six.text_type("GLOBAL_UNICAST"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address-type', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/origin (ip-address-origin)

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/origin (ip-address-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this address, e.g., static, dhcp, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with ip-address-origin""",
          'defined-type': "openconfig-if-tunnel:ip-address-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DHCP': {}, 'LINK_LAYER': {}, 'RANDOM': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='ip-address-origin', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/status (enumeration)

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state/status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: The status of an address.  Most of the states correspond
to states from the IPv6 Stateless Address
Autoconfiguration protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-tunnel:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PREFERRED': {}, 'DEPRECATED': {}, 'INVALID': {}, 'INACCESSIBLE': {}, 'UNKNOWN': {}, 'TENTATIVE': {}, 'DUPLICATE': {}, 'OPTIMISTIC': {}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  origin = __builtin__.property(_get_origin)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('origin', origin), ('status', status), ])


class yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of configured IPv6 addresses on the interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'address'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/ip (leafref)

    YANG Description: References the configured IP address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address list
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address (list)

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The list of configured IPv6 addresses on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to router advertisements
for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'config']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  lifetime = __builtin__.property(_get_lifetime, _set_lifetime)
  suppress = __builtin__.property(_get_suppress, _set_suppress)
  managed = __builtin__.property(_get_managed, _set_managed)
  other_config = __builtin__.property(_get_other_config, _set_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to router
advertisements for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__lifetime','__suppress','__managed','__other_config',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'state']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

  interval = __builtin__.property(_get_interval)
  lifetime = __builtin__.property(_get_lifetime)
  suppress = __builtin__.property(_get_suppress)
  managed = __builtin__.property(_get_managed)
  other_config = __builtin__.property(_get_other_config)


  _pyangbind_elements = OrderedDict([('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('managed', managed), ('other_config', other_config), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/prefixes/prefix/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=True)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'config']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=True)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime, _set_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime, _set_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement, _set_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration, _set_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink, _set_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/prefixes/prefix/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__valid_lifetime','__preferred_lifetime','__disable_advertisement','__disable_autoconfiguration','__enable_onlink',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=False)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'prefixes', 'prefix', 'state']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/prefix (oc-inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 prefix to be advertised within the router advertisement
message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with oc-inet:ipv6-prefix""",
          'defined-type': "oc-inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))/(12[0-8]|1[0-1][0-9]|[1-9][0-9]|[0-9])'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-prefix', is_config=False)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: The length of time that the prefix is valid relative to the time
the packet was sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: The length of time that the address within the prefix remains
in the preferred state, i.e., unrestricted use is allowed by
upper-layer protocols. See RFC4862 for a complete definition
of preferred behaviours.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_disable_advertisement(self):
    """
    Getter method for disable_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    return self.__disable_advertisement
      
  def _set_disable_advertisement(self, v, load=False):
    """
    Setter method for disable_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/disable_advertisement (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_advertisement() directly.

    YANG Description: When set to true, the prefix is not advertised within
router advertisement messages that are sent as a result of
router soliciation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_advertisement must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__disable_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_advertisement(self):
    self.__disable_advertisement = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_disable_autoconfiguration(self):
    """
    Getter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    return self.__disable_autoconfiguration
      
  def _set_disable_autoconfiguration(self, v, load=False):
    """
    Setter method for disable_autoconfiguration, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/disable_autoconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable_autoconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable_autoconfiguration() directly.

    YANG Description: When set to true, the prefix is marked as not to be used for stateless
address configuration. This is achieved by setting the autonomous address
configuration bit for the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable_autoconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__disable_autoconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable_autoconfiguration(self):
    self.__disable_autoconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable-autoconfiguration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_enable_onlink(self):
    """
    Getter method for enable_onlink, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    return self.__enable_onlink
      
  def _set_enable_onlink(self, v, load=False):
    """
    Setter method for enable_onlink, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state/enable_onlink (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_onlink is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_onlink() directly.

    YANG Description: When set to true, the prefix is marked as being on link by setting the
L-bit for the prefix within a router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_onlink must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__enable_onlink = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_onlink(self):
    self.__enable_onlink = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-onlink", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  valid_lifetime = __builtin__.property(_get_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime)
  disable_advertisement = __builtin__.property(_get_disable_advertisement)
  disable_autoconfiguration = __builtin__.property(_get_disable_autoconfiguration)
  enable_onlink = __builtin__.property(_get_enable_onlink)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('disable_advertisement', disable_advertisement), ('disable_autoconfiguration', disable_autoconfiguration), ('enable_onlink', enable_onlink), ])


class yc_prefix_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/prefixes/prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__config','__state',)

  _yang_name = 'prefix'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'prefixes', 'prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Reference to the IPv6 prefix key for the prefix list.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config (container)

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state (container)

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters corresponding to an IPv6 prefix
within the router advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('config', config), ('state', state), ])


class yc_prefixes_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement/prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix',)

  _yang_name = 'prefixes'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement', 'prefixes']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix (list)

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes/prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: List of prefixes that are to be included in the IPv6
router-advertisement messages for the interface. The list
is keyed by the IPv6 prefix in CIDR representation.

Prefixes that are listed are those that are to be
advertised in router advertisement messages. Where there
are IPv6 global addresses configured on an interface and
the prefix is not listed in the prefix list, it MUST NOT
be advertised in the router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=YANGListType("prefix",yc_prefix_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes_prefix, yang_name="prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ])


class yc_router_advertisement_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/router-advertisement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters relating to
router advertisements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__prefixes',)

  _yang_name = 'router-advertisement'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'router-advertisement']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config (container)

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to router advertisements
for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state (container)

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters relating to router
advertisements for IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_prefixes(self):
    """
    Getter method for prefixes, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes (container)

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    return self.__prefixes
      
  def _set_prefixes(self, v, load=False):
    """
    Setter method for prefixes, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement/prefixes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixes() directly.

    YANG Description: Container for a list of prefixes that are included in the
router advertisement message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefixes_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixes(self):
    self.__prefixes = YANGDynClass(base=yc_prefixes_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  prefixes = __builtin__.property(_get_prefixes, _set_prefixes)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('prefixes', prefixes), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each IPv6 address on
the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'neighbors', 'neighbor', 'config']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=True)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address, _set_link_layer_address)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for each IPv6 address on the
interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__link_layer_address','__origin','__is_router','__neighbor_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'neighbors', 'neighbor', 'state']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the neighbor node.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/ip (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: The IPv6 address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_link_layer_address(self):
    """
    Getter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)

    YANG Description: The link-layer address of the neighbor node.
    """
    return self.__link_layer_address
      
  def _set_link_layer_address(self, v, load=False):
    """
    Setter method for link_layer_address, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/link_layer_address (oc-yang:phys-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_layer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_layer_address() directly.

    YANG Description: The link-layer address of the neighbor node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_layer_address must be of a type compatible with oc-yang:phys-address""",
          'defined-type': "oc-yang:phys-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)""",
        })

    self.__link_layer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_layer_address(self):
    self.__link_layer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?'}), is_leaf=True, yang_name="link-layer-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:phys-address', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/origin (neighbor-origin)

    YANG Description: The origin of this neighbor entry.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/origin (neighbor-origin)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The origin of this neighbor entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with neighbor-origin""",
          'defined-type': "openconfig-if-tunnel:neighbor-origin",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OTHER': {}, 'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='neighbor-origin', is_config=False)


  def _get_is_router(self):
    """
    Getter method for is_router, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/is_router (boolean)

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    return self.__is_router
      
  def _set_is_router(self, v, load=False):
    """
    Setter method for is_router, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/is_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_router() directly.

    YANG Description: Indicates that the neighbor node acts as a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__is_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_router(self):
    self.__is_router = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_neighbor_state(self):
    """
    Getter method for neighbor_state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    return self.__neighbor_state
      
  def _set_neighbor_state(self, v, load=False):
    """
    Setter method for neighbor_state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state/neighbor_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_state() directly.

    YANG Description: The Neighbor Unreachability Detection state of this
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-tunnel:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)""",
        })

    self.__neighbor_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_state(self):
    self.__neighbor_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INCOMPLETE': {}, 'REACHABLE': {}, 'STALE': {}, 'DELAY': {}, 'PROBE': {}},), is_leaf=True, yang_name="neighbor-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='enumeration', is_config=False)

  ip = __builtin__.property(_get_ip)
  link_layer_address = __builtin__.property(_get_link_layer_address)
  origin = __builtin__.property(_get_origin)
  is_router = __builtin__.property(_get_is_router)
  neighbor_state = __builtin__.property(_get_neighbor_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('link_layer_address', link_layer_address), ('origin', origin), ('is_router', is_router), ('neighbor_state', neighbor_state), ])


class yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__config','__state',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'neighbors', 'neighbor']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/ip (leafref)

    YANG Description: References the configured IP neighbor address
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/ip (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: References the configured IP neighbor address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config (container)

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each IPv6 address on
the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state (container)

    YANG Description: State data for each IPv6 address on the
interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for each IPv6 address on the
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('ip', ip), ('config', config), ('state', state), ])


class yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of IPv6 neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor (list)

    YANG Description: List of IPv6 neighbors
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip",yc_neighbor_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='list', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for unnumbered interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/config/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for unnumbered interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/state/enabled (boolean)

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Indicates that the subinterface is unnumbered.  By default
the subinterface is numbered, i.e., expected to have an
IP address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered/interface-ref/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configured reference to interface / subinterface
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered', 'interface-ref', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  subinterface = __builtin__.property(_get_subinterface, _set_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered/interface-ref/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state for interface-ref
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__subinterface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered', 'interface-ref', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state/interface (leafref)

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to a base interface.  If a reference to a
subinterface is required, this leaf must be specified
to indicate the base interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)


  def _get_subinterface(self):
    """
    Getter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state/subinterface (leafref)

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    return self.__subinterface
      
  def _set_subinterface(self, v, load=False):
    """
    Setter method for subinterface, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state/subinterface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterface() directly.

    YANG Description: Reference to a subinterface -- this requires the base
interface to be specified using the interface leaf in
this container.  If only a reference to a base interface
is requuired, this leaf should not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)""",
        })

    self.__subinterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterface(self):
    self.__subinterface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subinterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='leafref', is_config=False)

  interface = __builtin__.property(_get_interface)
  subinterface = __builtin__.property(_get_subinterface)


  _pyangbind_elements = OrderedDict([('interface', interface), ('subinterface', subinterface), ])


class yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered/interface-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'interface-ref'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered', 'interface-ref']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config (container)

    YANG Description: Configured reference to interface / subinterface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configured reference to interface / subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state (container)

    YANG Description: Operational state for interface-ref
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state for interface-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/unnumbered. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__interface_ref',)

  _yang_name = 'unnumbered'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'unnumbered']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/config (container)

    YANG Description: Configuration data for unnumbered interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for unnumbered interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/state (container)

    YANG Description: Operational state data for unnumbered interfaces
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for unnumbered interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref (container)

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface. The interface
that is being referenced is uniquely referenced based on
the specified interface and subinterface leaves. In contexts
where a Layer 3 interface is to be referenced, both the
interface and subinterface leaves must be populated, as
Layer 3 configuration within the OpenConfig models is
associated with a subinterface. In the case where a
Layer 2 interface is to be referenced, only the
interface is specified.

The interface/subinterface leaf tuple must be used as
the means by which the interface is specified, regardless
of any other context information (e.g., key in a list).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=yc_interface_ref_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered_interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('interface_ref', interface_ref), ])


class yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level config data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=True)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits, _set_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client, _set_dhcp_client)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ])


class yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_pkts','__in_octets','__in_error_pkts','__in_forwarded_pkts','__in_forwarded_octets','__in_discarded_pkts','__out_pkts','__out_octets','__out_error_pkts','__out_forwarded_pkts','__out_forwarded_octets','__out_discarded_pkts',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'state', 'counters']

  def _get_in_pkts(self):
    """
    Getter method for in_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    return self.__in_pkts
      
  def _set_in_pkts(self, v, load=False):
    """
    Setter method for in_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pkts() directly.

    YANG Description: The total number of IP packets received for the specified
address family, including those received in error
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pkts(self):
    self.__in_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_octets(self):
    """
    Getter method for in_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_octets (oc-yang:counter64)

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    return self.__in_octets
      
  def _set_in_octets(self, v, load=False):
    """
    Setter method for in_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_octets() directly.

    YANG Description: The total number of octets received in input IP packets
for the specified address family, including those received
in error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_octets(self):
    self.__in_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_error_pkts(self):
    """
    Getter method for in_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    return self.__in_error_pkts
      
  def _set_in_error_pkts(self, v, load=False):
    """
    Setter method for in_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_error_pkts() directly.

    YANG Description: Number of IP packets discarded due to errors for the
specified address family, including errors in the IP
header, no route found to the IP destination, invalid
address, unknown protocol, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_error_pkts(self):
    self.__in_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_pkts(self):
    """
    Getter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    return self.__in_forwarded_pkts
      
  def _set_in_forwarded_pkts(self, v, load=False):
    """
    Setter method for in_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_pkts() directly.

    YANG Description: The number of input packets for which the device was not
their final IP destination and for which the device
attempted to find a route to forward them to that final
destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_pkts(self):
    self.__in_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_forwarded_octets(self):
    """
    Getter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    return self.__in_forwarded_octets
      
  def _set_in_forwarded_octets(self, v, load=False):
    """
    Setter method for in_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_forwarded_octets() directly.

    YANG Description: The number of octets received in input IP packets
for the specified address family for which the device was
not their final IP destination and for which the
device attempted to find a route to forward them to that
final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_forwarded_octets(self):
    self.__in_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_discarded_pkts(self):
    """
    Getter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    return self.__in_discarded_pkts
      
  def _set_in_discarded_pkts(self, v, load=False):
    """
    Setter method for in_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/in_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_discarded_pkts() directly.

    YANG Description: The number of input IP packets for the
specified address family, for which no problems were
encountered to prevent their continued processing, but
were discarded (e.g., for lack of buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_discarded_pkts(self):
    self.__in_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pkts(self):
    """
    Getter method for out_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_pkts (oc-yang:counter64)

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    return self.__out_pkts
      
  def _set_out_pkts(self, v, load=False):
    """
    Setter method for out_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pkts() directly.

    YANG Description: The total number of IP packets for the
specified address family that the device supplied
to the lower layers for transmission.  This includes
packets generated locally and those forwarded by the
device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pkts(self):
    self.__out_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_octets(self):
    """
    Getter method for out_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_octets (oc-yang:counter64)

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    return self.__out_octets
      
  def _set_out_octets(self, v, load=False):
    """
    Setter method for out_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_octets() directly.

    YANG Description: The total number of octets in IP packets for the
specified address family that the device
supplied to the lower layers for transmission.  This
includes packets generated locally and those forwarded by
the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_octets(self):
    self.__out_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_error_pkts(self):
    """
    Getter method for out_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_error_pkts (oc-yang:counter64)

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    return self.__out_error_pkts
      
  def _set_out_error_pkts(self, v, load=False):
    """
    Setter method for out_error_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_error_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_error_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_error_pkts() directly.

    YANG Description: Number of IP packets for the specified address family
locally generated and discarded due to errors, including
no route found to the IP destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_error_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_error_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_error_pkts(self):
    self.__out_error_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-error-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_pkts(self):
    """
    Getter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    return self.__out_forwarded_pkts
      
  def _set_out_forwarded_pkts(self, v, load=False):
    """
    Setter method for out_forwarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_forwarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_pkts() directly.

    YANG Description: The number of packets for which this entity was not their
final IP destination and for which it was successful in
finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_pkts(self):
    self.__out_forwarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_forwarded_octets(self):
    """
    Getter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    return self.__out_forwarded_octets
      
  def _set_out_forwarded_octets(self, v, load=False):
    """
    Setter method for out_forwarded_octets, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_forwarded_octets (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_forwarded_octets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_forwarded_octets() directly.

    YANG Description: The number of octets in packets for which this entity was
not their final IP destination and for which it was
successful in finding a path to their final destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_forwarded_octets must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_forwarded_octets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_forwarded_octets(self):
    self.__out_forwarded_octets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-forwarded-octets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_discarded_pkts(self):
    """
    Getter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    return self.__out_discarded_pkts
      
  def _set_out_discarded_pkts(self, v, load=False):
    """
    Setter method for out_discarded_pkts, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters/out_discarded_pkts (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_discarded_pkts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_discarded_pkts() directly.

    YANG Description: The number of output IP packets for the
specified address family for which no problem was
encountered to prevent their transmission to their
destination, but were discarded (e.g., for lack of
buffer space).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_discarded_pkts must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_discarded_pkts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_discarded_pkts(self):
    self.__out_discarded_pkts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-discarded-pkts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='oc-yang:counter64', is_config=False)

  in_pkts = __builtin__.property(_get_in_pkts)
  in_octets = __builtin__.property(_get_in_octets)
  in_error_pkts = __builtin__.property(_get_in_error_pkts)
  in_forwarded_pkts = __builtin__.property(_get_in_forwarded_pkts)
  in_forwarded_octets = __builtin__.property(_get_in_forwarded_octets)
  in_discarded_pkts = __builtin__.property(_get_in_discarded_pkts)
  out_pkts = __builtin__.property(_get_out_pkts)
  out_octets = __builtin__.property(_get_out_octets)
  out_error_pkts = __builtin__.property(_get_out_error_pkts)
  out_forwarded_pkts = __builtin__.property(_get_out_forwarded_pkts)
  out_forwarded_octets = __builtin__.property(_get_out_forwarded_octets)
  out_discarded_pkts = __builtin__.property(_get_out_discarded_pkts)


  _pyangbind_elements = OrderedDict([('in_pkts', in_pkts), ('in_octets', in_octets), ('in_error_pkts', in_error_pkts), ('in_forwarded_pkts', in_forwarded_pkts), ('in_forwarded_octets', in_forwarded_octets), ('in_discarded_pkts', in_discarded_pkts), ('out_pkts', out_pkts), ('out_octets', out_octets), ('out_error_pkts', out_error_pkts), ('out_forwarded_pkts', out_forwarded_pkts), ('out_forwarded_octets', out_forwarded_octets), ('out_discarded_pkts', out_discarded_pkts), ])


class yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level operational state data for the IPv6 interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__mtu','__dup_addr_detect_transmits','__dhcp_client','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/enabled (boolean)

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Controls whether IPv6 is enabled or disabled on this
interface.  When IPv6 is enabled, this interface is
connected to an IPv6 stack, and the interface can send
and receive IPv6 packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/mtu (uint32)

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The size, in octets, of the largest IPv6 packet that the
interface will send and receive.

The server may restrict the allowed values for this leaf,
depending on the interface's type.

If this leaf is not configured, the operationally used MTU
depends on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1280..max']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_dup_addr_detect_transmits(self):
    """
    Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/dup_addr_detect_transmits (uint32)

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    return self.__dup_addr_detect_transmits
      
  def _set_dup_addr_detect_transmits(self, v, load=False):
    """
    Setter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/dup_addr_detect_transmits (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dup_addr_detect_transmits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dup_addr_detect_transmits() directly.

    YANG Description: The number of consecutive Neighbor Solicitation messages
sent while performing Duplicate Address Detection on a
tentative address.  A value of zero indicates that
Duplicate Address Detection is not performed on
tentative addresses.  A value of one indicates a single
transmission with no follow-up retransmissions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dup_addr_detect_transmits must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)""",
        })

    self.__dup_addr_detect_transmits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dup_addr_detect_transmits(self):
    self.__dup_addr_detect_transmits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="dup-addr-detect-transmits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='uint32', is_config=False)


  def _get_dhcp_client(self):
    """
    Getter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/dhcp_client (boolean)

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    return self.__dhcp_client
      
  def _set_dhcp_client(self, v, load=False):
    """
    Setter method for dhcp_client, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/dhcp_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_client() directly.

    YANG Description: Enables a DHCP client on the interface in order to request
an address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_client(self):
    self.__dhcp_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dhcp-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters (container)

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Packet and byte counters for IP transmission and
reception for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  mtu = __builtin__.property(_get_mtu)
  dup_addr_detect_transmits = __builtin__.property(_get_dup_addr_detect_transmits)
  dhcp_client = __builtin__.property(_get_dhcp_client)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('mtu', mtu), ('dup_addr_detect_transmits', dup_addr_detect_transmits), ('dhcp_client', dhcp_client), ('counters', counters), ])


class yc_ipv6_openconfig_interfaces__interfaces_interface_tunnel_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the IPv6 address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__router_advertisement','__neighbors','__unnumbered','__config','__state',)

  _yang_name = 'ipv6'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel', 'ipv6']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses (container)

    YANG Description: Enclosing container for address list
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /interfaces/interface/tunnel/ipv6/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Enclosing container for address list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_openconfig_interfaces__interfaces_interface_tunnel_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_router_advertisement(self):
    """
    Getter method for router_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement (container)

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    return self.__router_advertisement
      
  def _set_router_advertisement(self, v, load=False):
    """
    Setter method for router_advertisement, mapped from YANG variable /interfaces/interface/tunnel/ipv6/router_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_advertisement() directly.

    YANG Description: Configuration and operational state parameters relating to
router advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__router_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_advertisement(self):
    self.__router_advertisement = YANGDynClass(base=yc_router_advertisement_openconfig_interfaces__interfaces_interface_tunnel_ipv6_router_advertisement, is_container='container', yang_name="router-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors (container)

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /interfaces/interface/tunnel/ipv6/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for list of IPv6 neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_interfaces__interfaces_interface_tunnel_ipv6_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_unnumbered(self):
    """
    Getter method for unnumbered, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered (container)

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    return self.__unnumbered
      
  def _set_unnumbered(self, v, load=False):
    """
    Setter method for unnumbered, mapped from YANG variable /interfaces/interface/tunnel/ipv6/unnumbered (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered() directly.

    YANG Description: Top-level container for setting unnumbered interfaces.
Includes reference the interface that provides the
address information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__unnumbered = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered(self):
    self.__unnumbered = YANGDynClass(base=yc_unnumbered_openconfig_interfaces__interfaces_interface_tunnel_ipv6_unnumbered, is_container='container', yang_name="unnumbered", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config (container)

    YANG Description: Top-level config data for the IPv6 interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/ipv6/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level config data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_ipv6_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state (container)

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/ipv6/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top-level operational state data for the IPv6 interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses)
  router_advertisement = __builtin__.property(_get_router_advertisement, _set_router_advertisement)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)
  unnumbered = __builtin__.property(_get_unnumbered, _set_unnumbered)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('router_advertisement', router_advertisement), ('neighbors', neighbors), ('unnumbered', unnumbered), ('config', config), ('state', state), ])


class yc_tunnel_openconfig_interfaces__interfaces_interface_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: In the case that the interface is logical tunnel
interface, the parameters for the tunnel are
specified within this subtree. Tunnel interfaces
have only a single logical subinterface associated
with them.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__ipv4','__ipv6',)

  _yang_name = 'tunnel'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_tunnel_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_tunnel_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'tunnel']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/tunnel/config (container)

    YANG Description: Configuration parameters associated with the
tunnel interface
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/tunnel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters associated with the
tunnel interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_tunnel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/tunnel/state (container)

    YANG Description: Operational state parameters associated with
the tunnel interface.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/tunnel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state parameters associated with
the tunnel interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_tunnel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /interfaces/interface/tunnel/ipv4 (container)

    YANG Description: Parameters for the IPv4 address family.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /interfaces/interface/tunnel/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Parameters for the IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_openconfig_interfaces__interfaces_interface_tunnel_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_tunnel_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_openconfig_interfaces__interfaces_interface_tunnel_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /interfaces/interface/tunnel/ipv6 (container)

    YANG Description: Parameters for the IPv6 address family.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /interfaces/interface/tunnel/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Parameters for the IPv6 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_openconfig_interfaces__interfaces_interface_tunnel_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_tunnel_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_openconfig_interfaces__interfaces_interface_tunnel_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_interface_openconfig_interfaces__interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of named interfaces on the device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__hold_time','__subinterfaces','__ethernet','__aggregation','__routed_vlan','__tunnel',)

  _yang_name = 'interface'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__hold_time = YANGDynClass(base=yc_hold_time_openconfig_interfaces__interfaces_interface_hold_time, is_container='container', yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__subinterfaces = YANGDynClass(base=yc_subinterfaces_openconfig_interfaces__interfaces_interface_subinterfaces, is_container='container', yang_name="subinterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_interfaces__interfaces_interface_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    self.__aggregation = YANGDynClass(base=yc_aggregation_openconfig_interfaces__interfaces_interface_aggregation, is_container='container', yang_name="aggregation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    self.__routed_vlan = YANGDynClass(base=yc_routed_vlan_openconfig_interfaces__interfaces_interface_routed_vlan, is_container='container', yang_name="routed-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__tunnel = YANGDynClass(base=yc_tunnel_openconfig_interfaces__interfaces_interface_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /interfaces/interface/name (leafref)

    YANG Description: References the name of the interface
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /interfaces/interface/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the name of the interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /interfaces/interface/config (container)

    YANG Description: Configurable items at the global, physical interface
level
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /interfaces/interface/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configurable items at the global, physical interface
level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_interfaces__interfaces_interface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_interfaces__interfaces_interface_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /interfaces/interface/state (container)

    YANG Description: Operational state data at the global interface level
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /interfaces/interface/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data at the global interface level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_interfaces__interfaces_interface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_interfaces__interfaces_interface_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /interfaces/interface/hold_time (container)

    YANG Description: Top-level container for hold-time settings to enable
dampening advertisements of interface transitions.
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /interfaces/interface/hold_time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: Top-level container for hold-time settings to enable
dampening advertisements of interface transitions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_hold_time_openconfig_interfaces__interfaces_interface_hold_time, is_container='container', yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_hold_time_openconfig_interfaces__interfaces_interface_hold_time, is_container='container', yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=yc_hold_time_openconfig_interfaces__interfaces_interface_hold_time, is_container='container', yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_subinterfaces(self):
    """
    Getter method for subinterfaces, mapped from YANG variable /interfaces/interface/subinterfaces (container)

    YANG Description: Enclosing container for the list of subinterfaces associated
with a physical interface
    """
    return self.__subinterfaces
      
  def _set_subinterfaces(self, v, load=False):
    """
    Setter method for subinterfaces, mapped from YANG variable /interfaces/interface/subinterfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subinterfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subinterfaces() directly.

    YANG Description: Enclosing container for the list of subinterfaces associated
with a physical interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subinterfaces_openconfig_interfaces__interfaces_interface_subinterfaces, is_container='container', yang_name="subinterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subinterfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subinterfaces_openconfig_interfaces__interfaces_interface_subinterfaces, is_container='container', yang_name="subinterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__subinterfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subinterfaces(self):
    self.__subinterfaces = YANGDynClass(base=yc_subinterfaces_openconfig_interfaces__interfaces_interface_subinterfaces, is_container='container', yang_name="subinterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /interfaces/interface/ethernet (container)

    YANG Description: Top-level container for ethernet configuration
and state
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /interfaces/interface/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: Top-level container for ethernet configuration
and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_openconfig_interfaces__interfaces_interface_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_openconfig_interfaces__interfaces_interface_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_interfaces__interfaces_interface_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/ethernet', defining_module='openconfig-if-ethernet', yang_type='container', is_config=True)


  def _get_aggregation(self):
    """
    Getter method for aggregation, mapped from YANG variable /interfaces/interface/aggregation (container)

    YANG Description: Options for logical interfaces representing
aggregates
    """
    return self.__aggregation
      
  def _set_aggregation(self, v, load=False):
    """
    Setter method for aggregation, mapped from YANG variable /interfaces/interface/aggregation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation() directly.

    YANG Description: Options for logical interfaces representing
aggregates
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aggregation_openconfig_interfaces__interfaces_interface_aggregation, is_container='container', yang_name="aggregation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aggregation_openconfig_interfaces__interfaces_interface_aggregation, is_container='container', yang_name="aggregation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)""",
        })

    self.__aggregation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregation(self):
    self.__aggregation = YANGDynClass(base=yc_aggregation_openconfig_interfaces__interfaces_interface_aggregation, is_container='container', yang_name="aggregation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/aggregate', defining_module='openconfig-if-aggregate', yang_type='container', is_config=True)


  def _get_routed_vlan(self):
    """
    Getter method for routed_vlan, mapped from YANG variable /interfaces/interface/routed_vlan (container)

    YANG Description: Top-level container for routed vlan interfaces.  These
logical interfaces are also known as SVI (switched virtual
interface), IRB (integrated routing and bridging), RVI
(routed VLAN interface)
    """
    return self.__routed_vlan
      
  def _set_routed_vlan(self, v, load=False):
    """
    Setter method for routed_vlan, mapped from YANG variable /interfaces/interface/routed_vlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routed_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routed_vlan() directly.

    YANG Description: Top-level container for routed vlan interfaces.  These
logical interfaces are also known as SVI (switched virtual
interface), IRB (integrated routing and bridging), RVI
(routed VLAN interface)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routed_vlan_openconfig_interfaces__interfaces_interface_routed_vlan, is_container='container', yang_name="routed-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routed_vlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routed_vlan_openconfig_interfaces__interfaces_interface_routed_vlan, is_container='container', yang_name="routed-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__routed_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routed_vlan(self):
    self.__routed_vlan = YANGDynClass(base=yc_routed_vlan_openconfig_interfaces__interfaces_interface_routed_vlan, is_container='container', yang_name="routed-vlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_tunnel(self):
    """
    Getter method for tunnel, mapped from YANG variable /interfaces/interface/tunnel (container)

    YANG Description: In the case that the interface is logical tunnel
interface, the parameters for the tunnel are
specified within this subtree. Tunnel interfaces
have only a single logical subinterface associated
with them.
    """
    return self.__tunnel
      
  def _set_tunnel(self, v, load=False):
    """
    Setter method for tunnel, mapped from YANG variable /interfaces/interface/tunnel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel() directly.

    YANG Description: In the case that the interface is logical tunnel
interface, the parameters for the tunnel are
specified within this subtree. Tunnel interfaces
have only a single logical subinterface associated
with them.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_openconfig_interfaces__interfaces_interface_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_openconfig_interfaces__interfaces_interface_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)""",
        })

    self.__tunnel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel(self):
    self.__tunnel = YANGDynClass(base=yc_tunnel_openconfig_interfaces__interfaces_interface_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces/tunnel', defining_module='openconfig-if-tunnel', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  hold_time = __builtin__.property(_get_hold_time, _set_hold_time)
  subinterfaces = __builtin__.property(_get_subinterfaces, _set_subinterfaces)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)
  aggregation = __builtin__.property(_get_aggregation, _set_aggregation)
  routed_vlan = __builtin__.property(_get_routed_vlan, _set_routed_vlan)
  tunnel = __builtin__.property(_get_tunnel, _set_tunnel)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('hold_time', hold_time), ('subinterfaces', subinterfaces), ('ethernet', ethernet), ('aggregation', aggregation), ('routed_vlan', routed_vlan), ('tunnel', tunnel), ])


class yc_interfaces_openconfig_interfaces__interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for interfaces, including configuration
and state data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_openconfig_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /interfaces/interface (list)

    YANG Description: The list of named interfaces on the device.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The list of named interfaces on the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_openconfig_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_openconfig_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_openconfig_interfaces__interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class openconfig_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /openconfig-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing network interfaces and subinterfaces.  This
module also defines convenience types / groupings for other
models to create references to interfaces:

 base-interface-ref (type) -  reference to a base interface
 interface-ref (grouping) -  container for reference to a
   interface + subinterface
 interface-ref-state (grouping) - container for read-only
   (opstate) reference to interface + subinterface

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7223 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7223.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'openconfig-interfaces'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_openconfig_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_openconfig_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_openconfig_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_openconfig_interfaces__interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


