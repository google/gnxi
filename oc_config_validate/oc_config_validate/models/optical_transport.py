# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal','__client_mapping_mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__client_mapping_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)


  def _get_client_mapping_mode(self):
    """
    Getter method for client_mapping_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/client_mapping_mode (identityref)

    YANG Description: The client side mapping mode internal to the device that
specifies the number of client electrical interfaces and
the data rate of each client electrical interface. For
example, a ZR+ transceiver with an optical line rate of 400G
could be configured to break out into four 100G client
signals which might connect to an interface or a
physical-channel. This would be configured on the aggregate
logical channel as MODE_4X100G. This is only valid on the
aggregate logical channel that is connected directly to the
optical-channel.
    """
    return self.__client_mapping_mode
      
  def _set_client_mapping_mode(self, v, load=False):
    """
    Setter method for client_mapping_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/client_mapping_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_mapping_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_mapping_mode() directly.

    YANG Description: The client side mapping mode internal to the device that
specifies the number of client electrical interfaces and
the data rate of each client electrical interface. For
example, a ZR+ transceiver with an optical line rate of 400G
could be configured to break out into four 100G client
signals which might connect to an interface or a
physical-channel. This would be configured on the aggregate
logical channel as MODE_4X100G. This is only valid on the
aggregate logical channel that is connected directly to the
optical-channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_mapping_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__client_mapping_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_mapping_mode(self):
    self.__client_mapping_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  admin_state = __builtin__.property(_get_admin_state, _set_admin_state)
  rate_class = __builtin__.property(_get_rate_class, _set_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol, _set_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type, _set_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode, _set_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal, _set_test_signal)
  client_mapping_mode = __builtin__.property(_get_client_mapping_mode, _set_client_mapping_mode)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('admin_state', admin_state), ('rate_class', rate_class), ('trib_protocol', trib_protocol), ('logical_channel_type', logical_channel_type), ('loopback_mode', loopback_mode), ('test_signal', test_signal), ('client_mapping_mode', client_mapping_mode), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal','__client_mapping_mode','__link_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__client_mapping_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_10G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_40G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_650G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_700G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_750G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_800G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_850G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_900G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_950G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1000G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1050G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1150G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1250G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1300G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1350G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1450G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1500G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1550G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_RATE_1600G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_1GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC48': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM16': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_LAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_10GE_WAN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC192': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM64': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU1E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU2E': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_40GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OC768': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_STM256': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU3': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_100G_MLG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUCN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODU4': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_400GE': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTSIG': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ODUFLEX_GFP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_ETHERNET': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:PROT_OTN': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'FACILITY': {}, 'TERMINAL': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_client_mapping_mode(self):
    """
    Getter method for client_mapping_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/client_mapping_mode (identityref)

    YANG Description: The client side mapping mode internal to the device that
specifies the number of client electrical interfaces and
the data rate of each client electrical interface. For
example, a ZR+ transceiver with an optical line rate of 400G
could be configured to break out into four 100G client
signals which might connect to an interface or a
physical-channel. This would be configured on the aggregate
logical channel as MODE_4X100G. This is only valid on the
aggregate logical channel that is connected directly to the
optical-channel.
    """
    return self.__client_mapping_mode
      
  def _set_client_mapping_mode(self, v, load=False):
    """
    Setter method for client_mapping_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/client_mapping_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_mapping_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_mapping_mode() directly.

    YANG Description: The client side mapping mode internal to the device that
specifies the number of client electrical interfaces and
the data rate of each client electrical interface. For
example, a ZR+ transceiver with an optical line rate of 400G
could be configured to break out into four 100G client
signals which might connect to an interface or a
physical-channel. This would be configured on the aggregate
logical channel as MODE_4X100G. This is only valid on the
aggregate logical channel that is connected directly to the
optical-channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_mapping_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__client_mapping_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_mapping_mode(self):
    self.__client_mapping_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_1X400G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_2X200G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_3X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:MODE_4X100G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="client-mapping-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_link_state(self):
    """
    Getter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    return self.__link_state
      
  def _set_link_state(self, v, load=False):
    """
    Setter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_state() directly.

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__link_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_state(self):
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}, 'TESTING': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  admin_state = __builtin__.property(_get_admin_state)
  rate_class = __builtin__.property(_get_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal)
  client_mapping_mode = __builtin__.property(_get_client_mapping_mode)
  link_state = __builtin__.property(_get_link_state)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('admin_state', admin_state), ('rate_class', rate_class), ('trib_protocol', trib_protocol), ('logical_channel_type', logical_channel_type), ('loopback_mode', loopback_mode), ('test_signal', test_signal), ('client_mapping_mode', client_mapping_mode), ('link_state', link_state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for OTN protocol framing
  """
  __slots__ = ('_path_helper', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto','__tributary_slot_granularity',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'config']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)


  def _get_tributary_slot_granularity(self):
    """
    Getter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tributary_slot_granularity (identityref)

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    return self.__tributary_slot_granularity
      
  def _set_tributary_slot_granularity(self, v, load=False):
    """
    Setter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tributary_slot_granularity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_granularity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_granularity() directly.

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_granularity must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__tributary_slot_granularity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_granularity(self):
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit, _set_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected, _set_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto, _set_tti_msg_auto)
  tributary_slot_granularity = __builtin__.property(_get_tributary_slot_granularity, _set_tributary_slot_granularity)


  _pyangbind_elements = OrderedDict([('tti_msg_transmit', tti_msg_transmit), ('tti_msg_expected', tti_msg_expected), ('tti_msg_auto', tti_msg_auto), ('tributary_slot_granularity', tributary_slot_granularity), ])


class yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/pre-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'pre-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'state', 'pre-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/post-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'post-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'state', 'post-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/q-value. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'q-value'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'state', 'q-value']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/esnr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'esnr'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'state', 'esnr']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto','__tributary_slot_granularity','__tti_msg_recv','__rdi_msg','__errored_seconds','__severely_errored_seconds','__unavailable_seconds','__code_violations','__errored_blocks','__fec_uncorrectable_words','__fec_corrected_bytes','__fec_corrected_bits','__background_block_errors','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__tti_msg_recv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__rdi_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__errored_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn', 'state']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_tributary_slot_granularity(self):
    """
    Getter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tributary_slot_granularity (identityref)

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    return self.__tributary_slot_granularity
      
  def _set_tributary_slot_granularity(self, v, load=False):
    """
    Setter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tributary_slot_granularity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_granularity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_granularity() directly.

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_granularity must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__tributary_slot_granularity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_granularity(self):
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_1.25G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_2.5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:TRIB_SLOT_5G': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_tti_msg_recv(self):
    """
    Getter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)

    YANG Description: Trail trace identifier (TTI) message received
    """
    return self.__tti_msg_recv
      
  def _set_tti_msg_recv(self, v, load=False):
    """
    Setter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_recv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_recv() directly.

    YANG Description: Trail trace identifier (TTI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_recv must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_recv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_recv(self):
    self.__tti_msg_recv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_rdi_msg(self):
    """
    Getter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)

    YANG Description: Remote defect indication (RDI) message received
    """
    return self.__rdi_msg
      
  def _set_rdi_msg(self, v, load=False):
    """
    Setter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdi_msg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdi_msg() directly.

    YANG Description: Remote defect indication (RDI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rdi_msg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__rdi_msg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rdi_msg(self):
    self.__rdi_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_errored_seconds(self):
    """
    Getter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    return self.__errored_seconds
      
  def _set_errored_seconds(self, v, load=False):
    """
    Setter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errored_seconds() directly.

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errored_seconds(self):
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_severely_errored_seconds(self):
    """
    Getter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    return self.__severely_errored_seconds
      
  def _set_severely_errored_seconds(self, v, load=False):
    """
    Setter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severely_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severely_errored_seconds() directly.

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severely_errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__severely_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severely_errored_seconds(self):
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_unavailable_seconds(self):
    """
    Getter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)

    YANG Description: The number of seconds during which the link is unavailable
    """
    return self.__unavailable_seconds
      
  def _set_unavailable_seconds(self, v, load=False):
    """
    Setter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unavailable_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unavailable_seconds() directly.

    YANG Description: The number of seconds during which the link is unavailable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unavailable_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__unavailable_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unavailable_seconds(self):
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_code_violations(self):
    """
    Getter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    return self.__code_violations
      
  def _set_code_violations(self, v, load=False):
    """
    Setter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_code_violations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_code_violations() directly.

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """code_violations must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__code_violations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_code_violations(self):
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_errored_blocks(self):
    """
    Getter method for errored_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_blocks (yang:counter64)

    YANG Description: The number of errored blocks. Error detection codes are
capable to detect whether one or more errors have occurred
in a given sequence of bits  the block. It is normally not
possible to determine the exact number of errored bits within
the block.
    """
    return self.__errored_blocks
      
  def _set_errored_blocks(self, v, load=False):
    """
    Setter method for errored_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errored_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errored_blocks() directly.

    YANG Description: The number of errored blocks. Error detection codes are
capable to detect whether one or more errors have occurred
in a given sequence of bits  the block. It is normally not
possible to determine the exact number of errored bits within
the block.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errored_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__errored_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errored_blocks(self):
    self.__errored_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_words(self):
    """
    Getter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_words
      
  def _set_fec_uncorrectable_words(self, v, load=False):
    """
    Setter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_words is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_words() directly.

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_words must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_words = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_words(self):
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bytes(self):
    """
    Getter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)

    YANG Description: The number of bytes that were corrected by the FEC
    """
    return self.__fec_corrected_bytes
      
  def _set_fec_corrected_bytes(self, v, load=False):
    """
    Setter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bytes() directly.

    YANG Description: The number of bytes that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bytes must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bytes(self):
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bits(self):
    """
    Getter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)

    YANG Description: The number of bits that were corrected by the FEC
    """
    return self.__fec_corrected_bits
      
  def _set_fec_corrected_bits(self, v, load=False):
    """
    Setter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bits() directly.

    YANG Description: The number of bits that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bits must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bits(self):
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_background_block_errors(self):
    """
    Getter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)

    YANG Description: The number of background block errors
    """
    return self.__background_block_errors
      
  def _set_background_block_errors(self, v, load=False):
    """
    Setter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_background_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_background_block_errors() directly.

    YANG Description: The number of background block errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """background_block_errors must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__background_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_background_block_errors(self):
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto)
  tributary_slot_granularity = __builtin__.property(_get_tributary_slot_granularity)
  tti_msg_recv = __builtin__.property(_get_tti_msg_recv)
  rdi_msg = __builtin__.property(_get_rdi_msg)
  errored_seconds = __builtin__.property(_get_errored_seconds)
  severely_errored_seconds = __builtin__.property(_get_severely_errored_seconds)
  unavailable_seconds = __builtin__.property(_get_unavailable_seconds)
  code_violations = __builtin__.property(_get_code_violations)
  errored_blocks = __builtin__.property(_get_errored_blocks)
  fec_uncorrectable_words = __builtin__.property(_get_fec_uncorrectable_words)
  fec_corrected_bytes = __builtin__.property(_get_fec_corrected_bytes)
  fec_corrected_bits = __builtin__.property(_get_fec_corrected_bits)
  background_block_errors = __builtin__.property(_get_background_block_errors)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('tti_msg_transmit', tti_msg_transmit), ('tti_msg_expected', tti_msg_expected), ('tti_msg_auto', tti_msg_auto), ('tributary_slot_granularity', tributary_slot_granularity), ('tti_msg_recv', tti_msg_recv), ('rdi_msg', rdi_msg), ('errored_seconds', errored_seconds), ('severely_errored_seconds', severely_errored_seconds), ('unavailable_seconds', unavailable_seconds), ('code_violations', code_violations), ('errored_blocks', errored_blocks), ('fec_uncorrectable_words', fec_uncorrectable_words), ('fec_corrected_bytes', fec_corrected_bytes), ('fec_corrected_bits', fec_corrected_bits), ('background_block_errors', background_block_errors), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


class yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'otn'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'otn']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)

    YANG Description: Configuration data for OTN protocol framing
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for OTN protocol framing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for Ethernet protocol framing on
logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_als','__als_delay',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'config']

  def _get_client_als(self):
    """
    Getter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/client_als (enumeration)

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    return self.__client_als
      
  def _set_client_als(self, v, load=False):
    """
    Setter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/client_als (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_als is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_als() directly.

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_als must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)""",
        })

    self.__client_als = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_als(self):
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)


  def _get_als_delay(self):
    """
    Getter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/als_delay (uint32)

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    return self.__als_delay
      
  def _set_als_delay(self, v, load=False):
    """
    Setter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/als_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_als_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_als_delay() directly.

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """als_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__als_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_als_delay(self):
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)

  client_als = __builtin__.property(_get_client_als, _set_client_als)
  als_delay = __builtin__.property(_get_als_delay, _set_als_delay)


  _pyangbind_elements = OrderedDict([('client_als', client_als), ('als_delay', als_delay), ])


class yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_pre_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state/pre-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'pre-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'state', 'pre-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_post_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state/post-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'post-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'state', 'post-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_q_value(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state/q-value. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'q-value'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'state', 'q-value']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_esnr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state/esnr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'esnr'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'state', 'esnr']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for Ethernet protocol framing
on logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_als','__als_delay','__in_mac_control_frames','__in_mac_pause_frames','__in_oversize_frames','__in_undersize_frames','__in_jabber_frames','__in_fragment_frames','__in_8021q_frames','__in_crc_errors','__in_block_errors','__in_carrier_errors','__in_interrupted_tx','__in_late_collision','__in_mac_errors_rx','__in_single_collision','__in_symbol_error','__in_maxsize_exceeded','__out_mac_control_frames','__out_mac_pause_frames','__out_8021q_frames','__out_mac_errors_tx','__in_pcs_bip_errors','__in_pcs_errored_seconds','__in_pcs_severely_errored_seconds','__in_pcs_unavailable_seconds','__out_pcs_bip_errors','__out_crc_errors','__out_block_errors','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_carrier_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_interrupted_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_late_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_errors_rx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_single_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_symbol_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_maxsize_exceeded = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_errors_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'state']

  def _get_client_als(self):
    """
    Getter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/client_als (enumeration)

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    return self.__client_als
      
  def _set_client_als(self, v, load=False):
    """
    Setter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/client_als (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_als is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_als() directly.

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_als must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__client_als = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_als(self):
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'LASER_SHUTDOWN': {}, 'ETHERNET': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)


  def _get_als_delay(self):
    """
    Getter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/als_delay (uint32)

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    return self.__als_delay
      
  def _set_als_delay(self, v, load=False):
    """
    Setter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/als_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_als_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_als_delay() directly.

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """als_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__als_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_als_delay(self):
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_in_mac_control_frames(self):
    """
    Getter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames received on the interface
    """
    return self.__in_mac_control_frames
      
  def _set_in_mac_control_frames(self, v, load=False):
    """
    Setter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_control_frames() directly.

    YANG Description: MAC layer control frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_control_frames(self):
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_pause_frames(self):
    """
    Getter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    return self.__in_mac_pause_frames
      
  def _set_in_mac_pause_frames(self, v, load=False):
    """
    Setter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_pause_frames(self):
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_oversize_frames(self):
    """
    Getter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    return self.__in_oversize_frames
      
  def _set_in_oversize_frames(self, v, load=False):
    """
    Setter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_oversize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_oversize_frames() directly.

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_oversize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_oversize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_oversize_frames(self):
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_undersize_frames(self):
    """
    Getter method for in_undersize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_undersize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    return self.__in_undersize_frames
      
  def _set_in_undersize_frames(self, v, load=False):
    """
    Setter method for in_undersize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_undersize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_undersize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_undersize_frames() directly.

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_undersize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_undersize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_undersize_frames(self):
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_jabber_frames(self):
    """
    Getter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    return self.__in_jabber_frames
      
  def _set_in_jabber_frames(self, v, load=False):
    """
    Setter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_jabber_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_jabber_frames() directly.

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_jabber_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_jabber_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_jabber_frames(self):
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fragment_frames(self):
    """
    Getter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    return self.__in_fragment_frames
      
  def _set_in_fragment_frames(self, v, load=False):
    """
    Setter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fragment_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fragment_frames() directly.

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fragment_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fragment_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fragment_frames(self):
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_8021q_frames(self):
    """
    Getter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    return self.__in_8021q_frames
      
  def _set_in_8021q_frames(self, v, load=False):
    """
    Setter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_8021q_frames(self):
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_crc_errors(self):
    """
    Getter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    return self.__in_crc_errors
      
  def _set_in_crc_errors(self, v, load=False):
    """
    Setter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_crc_errors() directly.

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_crc_errors(self):
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_block_errors(self):
    """
    Getter method for in_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_block_errors (oc-yang:counter64)

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    return self.__in_block_errors
      
  def _set_in_block_errors(self, v, load=False):
    """
    Setter method for in_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_block_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_block_errors() directly.

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_block_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_block_errors(self):
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_carrier_errors(self):
    """
    Getter method for in_carrier_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_carrier_errors (oc-yang:counter64)

    YANG Description: The number of received errored frames due to a carrier issue.
The value refers to MIB counter for
dot3StatsCarrierSenseErrors
oid=1.3.6.1.2.1.10.7.2.1.11
    """
    return self.__in_carrier_errors
      
  def _set_in_carrier_errors(self, v, load=False):
    """
    Setter method for in_carrier_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_carrier_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_carrier_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_carrier_errors() directly.

    YANG Description: The number of received errored frames due to a carrier issue.
The value refers to MIB counter for
dot3StatsCarrierSenseErrors
oid=1.3.6.1.2.1.10.7.2.1.11
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_carrier_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_carrier_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_carrier_errors(self):
    self.__in_carrier_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-carrier-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_interrupted_tx(self):
    """
    Getter method for in_interrupted_tx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_interrupted_tx (oc-yang:counter64)

    YANG Description: The number of received errored frames due to interrupted
transmission issue. The value refers to MIB counter for
dot3StatsDeferredTransmissions
oid=1.3.6.1.2.1.10.7.2.1.7
    """
    return self.__in_interrupted_tx
      
  def _set_in_interrupted_tx(self, v, load=False):
    """
    Setter method for in_interrupted_tx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_interrupted_tx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_interrupted_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_interrupted_tx() directly.

    YANG Description: The number of received errored frames due to interrupted
transmission issue. The value refers to MIB counter for
dot3StatsDeferredTransmissions
oid=1.3.6.1.2.1.10.7.2.1.7
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_interrupted_tx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_interrupted_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_interrupted_tx(self):
    self.__in_interrupted_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-interrupted-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_late_collision(self):
    """
    Getter method for in_late_collision, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_late_collision (oc-yang:counter64)

    YANG Description: The number of received errored frames due to late collision
issue. The value refers to MIB counter for
dot3StatsLateCollisions
oid=1.3.6.1.2.1.10.7.2.1.8
    """
    return self.__in_late_collision
      
  def _set_in_late_collision(self, v, load=False):
    """
    Setter method for in_late_collision, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_late_collision (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_late_collision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_late_collision() directly.

    YANG Description: The number of received errored frames due to late collision
issue. The value refers to MIB counter for
dot3StatsLateCollisions
oid=1.3.6.1.2.1.10.7.2.1.8
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_late_collision must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_late_collision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_late_collision(self):
    self.__in_late_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-late-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_errors_rx(self):
    """
    Getter method for in_mac_errors_rx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_errors_rx (oc-yang:counter64)

    YANG Description: The number of received errored frames due to MAC errors
received. The value refers to MIB counter for
dot3StatsInternalMacReceiveErrors
oid=1.3.6.1.2.1.10.7.2.1.16
    """
    return self.__in_mac_errors_rx
      
  def _set_in_mac_errors_rx(self, v, load=False):
    """
    Setter method for in_mac_errors_rx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_errors_rx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_errors_rx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_errors_rx() directly.

    YANG Description: The number of received errored frames due to MAC errors
received. The value refers to MIB counter for
dot3StatsInternalMacReceiveErrors
oid=1.3.6.1.2.1.10.7.2.1.16
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_errors_rx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_errors_rx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_errors_rx(self):
    self.__in_mac_errors_rx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-errors-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_single_collision(self):
    """
    Getter method for in_single_collision, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_single_collision (oc-yang:counter64)

    YANG Description: The number of received errored frames due to single collision
issue. The value refers to MIB counter for
dot3StatsSingleCollisionFrames
oid=1.3.6.1.2.1.10.7.2.1.4
    """
    return self.__in_single_collision
      
  def _set_in_single_collision(self, v, load=False):
    """
    Setter method for in_single_collision, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_single_collision (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_single_collision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_single_collision() directly.

    YANG Description: The number of received errored frames due to single collision
issue. The value refers to MIB counter for
dot3StatsSingleCollisionFrames
oid=1.3.6.1.2.1.10.7.2.1.4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_single_collision must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_single_collision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_single_collision(self):
    self.__in_single_collision = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-single-collision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_symbol_error(self):
    """
    Getter method for in_symbol_error, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_symbol_error (oc-yang:counter64)

    YANG Description: The number of received errored frames due to symbol error.
The value refers to MIB counter for
in-symbol-error
oid=1.3.6.1.2.1.10.7.2.1.18
    """
    return self.__in_symbol_error
      
  def _set_in_symbol_error(self, v, load=False):
    """
    Setter method for in_symbol_error, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_symbol_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_symbol_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_symbol_error() directly.

    YANG Description: The number of received errored frames due to symbol error.
The value refers to MIB counter for
in-symbol-error
oid=1.3.6.1.2.1.10.7.2.1.18
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_symbol_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_symbol_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_symbol_error(self):
    self.__in_symbol_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-symbol-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_maxsize_exceeded(self):
    """
    Getter method for in_maxsize_exceeded, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_maxsize_exceeded (oc-yang:counter64)

    YANG Description: The total number frames received that are well-formed but
dropped due to exceeding the maximum frame size on the interface
(e.g., MTU or MRU)
    """
    return self.__in_maxsize_exceeded
      
  def _set_in_maxsize_exceeded(self, v, load=False):
    """
    Setter method for in_maxsize_exceeded, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_maxsize_exceeded (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_maxsize_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_maxsize_exceeded() directly.

    YANG Description: The total number frames received that are well-formed but
dropped due to exceeding the maximum frame size on the interface
(e.g., MTU or MRU)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_maxsize_exceeded must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_maxsize_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_maxsize_exceeded(self):
    self.__in_maxsize_exceeded = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-maxsize-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_control_frames(self):
    """
    Getter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames sent on the interface
    """
    return self.__out_mac_control_frames
      
  def _set_out_mac_control_frames(self, v, load=False):
    """
    Setter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_control_frames() directly.

    YANG Description: MAC layer control frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_control_frames(self):
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_pause_frames(self):
    """
    Getter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    return self.__out_mac_pause_frames
      
  def _set_out_mac_pause_frames(self, v, load=False):
    """
    Setter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_pause_frames(self):
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_8021q_frames(self):
    """
    Getter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    return self.__out_8021q_frames
      
  def _set_out_8021q_frames(self, v, load=False):
    """
    Setter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_8021q_frames(self):
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_errors_tx(self):
    """
    Getter method for out_mac_errors_tx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_errors_tx (oc-yang:counter64)

    YANG Description: The number of sent errored frames due to MAC errors
transmitted. The value refers to MIB counter for
dot3StatsInternalMacTransmitErrors
oid=1.3.6.1.2.1.10.7.2.1.10
    """
    return self.__out_mac_errors_tx
      
  def _set_out_mac_errors_tx(self, v, load=False):
    """
    Setter method for out_mac_errors_tx, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_errors_tx (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_errors_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_errors_tx() directly.

    YANG Description: The number of sent errored frames due to MAC errors
transmitted. The value refers to MIB counter for
dot3StatsInternalMacTransmitErrors
oid=1.3.6.1.2.1.10.7.2.1.10
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_errors_tx must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_errors_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_errors_tx(self):
    self.__out_mac_errors_tx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-errors-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_bip_errors(self):
    """
    Getter method for in_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_bip_errors (oc-yang:counter64)

    YANG Description: The number of received bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    return self.__in_pcs_bip_errors
      
  def _set_in_pcs_bip_errors(self, v, load=False):
    """
    Setter method for in_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_bip_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_bip_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_bip_errors() directly.

    YANG Description: The number of received bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_bip_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_bip_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_bip_errors(self):
    self.__in_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_errored_seconds(self):
    """
    Getter method for in_pcs_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_errored_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a sytem defined threshold indicating the
link is erroring
    """
    return self.__in_pcs_errored_seconds
      
  def _set_in_pcs_errored_seconds(self, v, load=False):
    """
    Setter method for in_pcs_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_errored_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_errored_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a sytem defined threshold indicating the
link is erroring
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_errored_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_errored_seconds(self):
    self.__in_pcs_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_severely_errored_seconds(self):
    """
    Getter method for in_pcs_severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_severely_errored_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is severely erroring
    """
    return self.__in_pcs_severely_errored_seconds
      
  def _set_in_pcs_severely_errored_seconds(self, v, load=False):
    """
    Setter method for in_pcs_severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_severely_errored_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_severely_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_severely_errored_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is severely erroring
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_severely_errored_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_severely_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_severely_errored_seconds(self):
    self.__in_pcs_severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_unavailable_seconds(self):
    """
    Getter method for in_pcs_unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_unavailable_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is unavailable
    """
    return self.__in_pcs_unavailable_seconds
      
  def _set_in_pcs_unavailable_seconds(self, v, load=False):
    """
    Setter method for in_pcs_unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_unavailable_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_unavailable_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_unavailable_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is unavailable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_unavailable_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_unavailable_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_unavailable_seconds(self):
    self.__in_pcs_unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pcs_bip_errors(self):
    """
    Getter method for out_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_pcs_bip_errors (oc-yang:counter64)

    YANG Description: The number of transmitted bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    return self.__out_pcs_bip_errors
      
  def _set_out_pcs_bip_errors(self, v, load=False):
    """
    Setter method for out_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_pcs_bip_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pcs_bip_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pcs_bip_errors() directly.

    YANG Description: The number of transmitted bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pcs_bip_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pcs_bip_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pcs_bip_errors(self):
    self.__out_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_crc_errors(self):
    """
    Getter method for out_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_crc_errors (oc-yang:counter64)

    YANG Description: Number of FCS/CRC error check failures sent on the interface
    """
    return self.__out_crc_errors
      
  def _set_out_crc_errors(self, v, load=False):
    """
    Setter method for out_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_crc_errors() directly.

    YANG Description: Number of FCS/CRC error check failures sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_crc_errors(self):
    self.__out_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_block_errors(self):
    """
    Getter method for out_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_block_errors (oc-yang:counter64)

    YANG Description: The number of transmitted errored blocks. Error detection
codes are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    return self.__out_block_errors
      
  def _set_out_block_errors(self, v, load=False):
    """
    Setter method for out_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_block_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_block_errors() directly.

    YANG Description: The number of transmitted errored blocks. Error detection
codes are capable of detecting whether one or more errors have
occurred in a given sequence of bits  the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_block_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_block_errors(self):
    self.__out_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  client_als = __builtin__.property(_get_client_als)
  als_delay = __builtin__.property(_get_als_delay)
  in_mac_control_frames = __builtin__.property(_get_in_mac_control_frames)
  in_mac_pause_frames = __builtin__.property(_get_in_mac_pause_frames)
  in_oversize_frames = __builtin__.property(_get_in_oversize_frames)
  in_undersize_frames = __builtin__.property(_get_in_undersize_frames)
  in_jabber_frames = __builtin__.property(_get_in_jabber_frames)
  in_fragment_frames = __builtin__.property(_get_in_fragment_frames)
  in_8021q_frames = __builtin__.property(_get_in_8021q_frames)
  in_crc_errors = __builtin__.property(_get_in_crc_errors)
  in_block_errors = __builtin__.property(_get_in_block_errors)
  in_carrier_errors = __builtin__.property(_get_in_carrier_errors)
  in_interrupted_tx = __builtin__.property(_get_in_interrupted_tx)
  in_late_collision = __builtin__.property(_get_in_late_collision)
  in_mac_errors_rx = __builtin__.property(_get_in_mac_errors_rx)
  in_single_collision = __builtin__.property(_get_in_single_collision)
  in_symbol_error = __builtin__.property(_get_in_symbol_error)
  in_maxsize_exceeded = __builtin__.property(_get_in_maxsize_exceeded)
  out_mac_control_frames = __builtin__.property(_get_out_mac_control_frames)
  out_mac_pause_frames = __builtin__.property(_get_out_mac_pause_frames)
  out_8021q_frames = __builtin__.property(_get_out_8021q_frames)
  out_mac_errors_tx = __builtin__.property(_get_out_mac_errors_tx)
  in_pcs_bip_errors = __builtin__.property(_get_in_pcs_bip_errors)
  in_pcs_errored_seconds = __builtin__.property(_get_in_pcs_errored_seconds)
  in_pcs_severely_errored_seconds = __builtin__.property(_get_in_pcs_severely_errored_seconds)
  in_pcs_unavailable_seconds = __builtin__.property(_get_in_pcs_unavailable_seconds)
  out_pcs_bip_errors = __builtin__.property(_get_out_pcs_bip_errors)
  out_crc_errors = __builtin__.property(_get_out_crc_errors)
  out_block_errors = __builtin__.property(_get_out_block_errors)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('client_als', client_als), ('als_delay', als_delay), ('in_mac_control_frames', in_mac_control_frames), ('in_mac_pause_frames', in_mac_pause_frames), ('in_oversize_frames', in_oversize_frames), ('in_undersize_frames', in_undersize_frames), ('in_jabber_frames', in_jabber_frames), ('in_fragment_frames', in_fragment_frames), ('in_8021q_frames', in_8021q_frames), ('in_crc_errors', in_crc_errors), ('in_block_errors', in_block_errors), ('in_carrier_errors', in_carrier_errors), ('in_interrupted_tx', in_interrupted_tx), ('in_late_collision', in_late_collision), ('in_mac_errors_rx', in_mac_errors_rx), ('in_single_collision', in_single_collision), ('in_symbol_error', in_symbol_error), ('in_maxsize_exceeded', in_maxsize_exceeded), ('out_mac_control_frames', out_mac_control_frames), ('out_mac_pause_frames', out_mac_pause_frames), ('out_8021q_frames', out_8021q_frames), ('out_mac_errors_tx', out_mac_errors_tx), ('in_pcs_bip_errors', in_pcs_bip_errors), ('in_pcs_errored_seconds', in_pcs_errored_seconds), ('in_pcs_severely_errored_seconds', in_pcs_severely_errored_seconds), ('in_pcs_unavailable_seconds', in_pcs_unavailable_seconds), ('out_pcs_bip_errors', out_pcs_bip_errors), ('out_crc_errors', out_crc_errors), ('out_block_errors', out_block_errors), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP configuration data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__snooping',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/enabled (boolean)

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)


  def _get_snooping(self):
    """
    Getter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/snooping (boolean)

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    return self.__snooping
      
  def _set_snooping(self, v, load=False):
    """
    Setter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/snooping (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snooping() directly.

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snooping must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snooping(self):
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  snooping = __builtin__.property(_get_snooping, _set_snooping)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('snooping', snooping), ])


class yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP counters on each interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_in','__frame_out','__frame_error_in','__frame_discard','__tlv_discard','__tlv_unknown','__last_clear','__frame_error_out',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_error_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tlv_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tlv_unknown = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)
    self.__frame_error_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'state', 'counters']

  def _get_frame_in(self):
    """
    Getter method for frame_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_in (yang:counter64)

    YANG Description: The number of lldp frames received.
    """
    return self.__frame_in
      
  def _set_frame_in(self, v, load=False):
    """
    Setter method for frame_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_in (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_in() directly.

    YANG Description: The number of lldp frames received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_in must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_in(self):
    self.__frame_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_out(self):
    """
    Getter method for frame_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_out (yang:counter64)

    YANG Description: The number of frames transmitted out.
    """
    return self.__frame_out
      
  def _set_frame_out(self, v, load=False):
    """
    Setter method for frame_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_out (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_out() directly.

    YANG Description: The number of frames transmitted out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_out must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_out(self):
    self.__frame_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_error_in(self):
    """
    Getter method for frame_error_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_in (yang:counter64)

    YANG Description: The number of LLDP frames received with errors.
    """
    return self.__frame_error_in
      
  def _set_frame_error_in(self, v, load=False):
    """
    Setter method for frame_error_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_in (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_error_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_error_in() directly.

    YANG Description: The number of LLDP frames received with errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_error_in must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_error_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_error_in(self):
    self.__frame_error_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_discard(self):
    """
    Getter method for frame_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_discard (yang:counter64)

    YANG Description: The number of LLDP frames received and discarded.
    """
    return self.__frame_discard
      
  def _set_frame_discard(self, v, load=False):
    """
    Setter method for frame_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_discard (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_discard() directly.

    YANG Description: The number of LLDP frames received and discarded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_discard must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_discard(self):
    self.__frame_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_tlv_discard(self):
    """
    Getter method for tlv_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_discard (yang:counter64)

    YANG Description: The number of TLV frames received and discarded.
    """
    return self.__tlv_discard
      
  def _set_tlv_discard(self, v, load=False):
    """
    Setter method for tlv_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_discard (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv_discard() directly.

    YANG Description: The number of TLV frames received and discarded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv_discard must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__tlv_discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv_discard(self):
    self.__tlv_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_tlv_unknown(self):
    """
    Getter method for tlv_unknown, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_unknown (yang:counter64)

    YANG Description: The number of frames received with unknown TLV.
    """
    return self.__tlv_unknown
      
  def _set_tlv_unknown(self, v, load=False):
    """
    Setter method for tlv_unknown, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_unknown (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv_unknown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv_unknown() directly.

    YANG Description: The number of frames received with unknown TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv_unknown must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__tlv_unknown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv_unknown(self):
    self.__tlv_unknown = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_last_clear(self):
    """
    Getter method for last_clear, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/last_clear (yang:date-and-time)

    YANG Description: Indicates the last time the counters were
cleared.
    """
    return self.__last_clear
      
  def _set_last_clear(self, v, load=False):
    """
    Setter method for last_clear, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/last_clear (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_clear() directly.

    YANG Description: Indicates the last time the counters were
cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_clear must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_clear(self):
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)


  def _get_frame_error_out(self):
    """
    Getter method for frame_error_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_out (yang:counter64)

    YANG Description: The number of frame transmit errors on the
interface.
    """
    return self.__frame_error_out
      
  def _set_frame_error_out(self, v, load=False):
    """
    Setter method for frame_error_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_out (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_error_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_error_out() directly.

    YANG Description: The number of frame transmit errors on the
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_error_out must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_error_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_error_out(self):
    self.__frame_error_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)

  frame_in = __builtin__.property(_get_frame_in)
  frame_out = __builtin__.property(_get_frame_out)
  frame_error_in = __builtin__.property(_get_frame_error_in)
  frame_discard = __builtin__.property(_get_frame_discard)
  tlv_discard = __builtin__.property(_get_tlv_discard)
  tlv_unknown = __builtin__.property(_get_tlv_unknown)
  last_clear = __builtin__.property(_get_last_clear)
  frame_error_out = __builtin__.property(_get_frame_error_out)


  _pyangbind_elements = OrderedDict([('frame_in', frame_in), ('frame_out', frame_out), ('frame_error_in', frame_error_in), ('frame_discard', frame_discard), ('tlv_discard', tlv_discard), ('tlv_unknown', tlv_unknown), ('last_clear', last_clear), ('frame_error_out', frame_error_out), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP operational state data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__snooping','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/enabled (boolean)

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_snooping(self):
    """
    Getter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/snooping (boolean)

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    return self.__snooping
      
  def _set_snooping(self, v, load=False):
    """
    Setter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/snooping (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snooping() directly.

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snooping must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snooping(self):
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters (container)

    YANG Description: LLDP counters on each interface
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: LLDP counters on each interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  snooping = __builtin__.property(_get_snooping)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('snooping', snooping), ('counters', counters), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__system_name','__system_description','__chassis_id','__chassis_id_type','__id','__age','__last_update','__ttl','__port_id','__port_id_type','__port_description','__management_address','__management_address_type',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__system_description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__chassis_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__chassis_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CHASSIS_COMPONENT': {}, 'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'LOCAL': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__port_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'AGENT_CIRCUIT_ID': {}, 'LOCAL': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)
    self.__port_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__management_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__management_address_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors', 'neighbor', 'state']

  def _get_system_name(self):
    """
    Getter method for system_name, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_name (string)

    YANG Description: The system name field shall contain an alpha-numeric string
that indicates the system's administratively assigned name.
The system name should be the system's fully qualified domain
name. If implementations support IETF RFC 3418, the sysName
object should be used for this field.
    """
    return self.__system_name
      
  def _set_system_name(self, v, load=False):
    """
    Setter method for system_name, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_name() directly.

    YANG Description: The system name field shall contain an alpha-numeric string
that indicates the system's administratively assigned name.
The system name should be the system's fully qualified domain
name. If implementations support IETF RFC 3418, the sysName
object should be used for this field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__system_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_name(self):
    self.__system_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_system_description(self):
    """
    Getter method for system_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_description (string)

    YANG Description: The system description field shall contain an alpha-numeric
string that is the textual description of the network entity.
The system description should include the full name and
version identification of the system's hardware type,
software operating system, and networking software. If
implementations support IETF RFC 3418, the sysDescr object
should be used for this field.
    """
    return self.__system_description
      
  def _set_system_description(self, v, load=False):
    """
    Setter method for system_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_description() directly.

    YANG Description: The system description field shall contain an alpha-numeric
string that is the textual description of the network entity.
The system description should include the full name and
version identification of the system's hardware type,
software operating system, and networking software. If
implementations support IETF RFC 3418, the sysDescr object
should be used for this field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__system_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_description(self):
    self.__system_description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_chassis_id(self):
    """
    Getter method for chassis_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id (string)

    YANG Description: The Chassis ID is a mandatory TLV which identifies the
chassis component of the endpoint identifier associated with
the transmitting LLDP agent
    """
    return self.__chassis_id
      
  def _set_chassis_id(self, v, load=False):
    """
    Setter method for chassis_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_id() directly.

    YANG Description: The Chassis ID is a mandatory TLV which identifies the
chassis component of the endpoint identifier associated with
the transmitting LLDP agent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__chassis_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_id(self):
    self.__chassis_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_chassis_id_type(self):
    """
    Getter method for chassis_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id_type (oc-lldp-types:chassis-id-type)

    YANG Description: This field identifies the format and source of the chassis
identifier string. It is an enumerator defined by the
LldpChassisIdSubtype object from IEEE 802.1AB MIB.
    """
    return self.__chassis_id_type
      
  def _set_chassis_id_type(self, v, load=False):
    """
    Setter method for chassis_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id_type (oc-lldp-types:chassis-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_id_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_id_type() directly.

    YANG Description: This field identifies the format and source of the chassis
identifier string. It is an enumerator defined by the
LldpChassisIdSubtype object from IEEE 802.1AB MIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CHASSIS_COMPONENT': {}, 'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'LOCAL': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_id_type must be of a type compatible with oc-lldp-types:chassis-id-type""",
          'defined-type': "oc-lldp-types:chassis-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CHASSIS_COMPONENT': {}, 'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'LOCAL': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)""",
        })

    self.__chassis_id_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_id_type(self):
    self.__chassis_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CHASSIS_COMPONENT': {}, 'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'LOCAL': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/id (string)

    YANG Description: System generated identifier for the neighbor on the
interface.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: System generated identifier for the neighbor on the
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_age(self):
    """
    Getter method for age, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/age (uint64)

    YANG Description: Age since discovery
    """
    return self.__age
      
  def _set_age(self, v, load=False):
    """
    Setter method for age, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/age (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_age is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_age() directly.

    YANG Description: Age since discovery
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """age must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)""",
        })

    self.__age = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_age(self):
    self.__age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)


  def _get_last_update(self):
    """
    Getter method for last_update, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/last_update (int64)

    YANG Description: Seconds since last update received.
    """
    return self.__last_update
      
  def _set_last_update(self, v, load=False):
    """
    Setter method for last_update, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/last_update (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_update is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_update() directly.

    YANG Description: Seconds since last update received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_update must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)""",
        })

    self.__last_update = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_update(self):
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/ttl (uint16)

    YANG Description: The time-to-live (TTL) is a mandatory TLV which indicates
how long information from the neighbor should be considered
valid.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/ttl (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: The time-to-live (TTL) is a mandatory TLV which indicates
how long information from the neighbor should be considered
valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_port_id(self):
    """
    Getter method for port_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id (string)

    YANG Description: The Port ID is a mandatory TLV which identifies the port
component of the endpoint identifier associated with the
transmitting LLDP agent. If the specified port is an IEEE
802.3 Repeater port, then this TLV is optional.
    """
    return self.__port_id
      
  def _set_port_id(self, v, load=False):
    """
    Setter method for port_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_id() directly.

    YANG Description: The Port ID is a mandatory TLV which identifies the port
component of the endpoint identifier associated with the
transmitting LLDP agent. If the specified port is an IEEE
802.3 Repeater port, then this TLV is optional.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__port_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_id(self):
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_port_id_type(self):
    """
    Getter method for port_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id_type (oc-lldp-types:port-id-type)

    YANG Description: This field identifies the format and source of the port
identifier string. It is an enumerator defined by the
PtopoPortIdType object from RFC2922.
    """
    return self.__port_id_type
      
  def _set_port_id_type(self, v, load=False):
    """
    Setter method for port_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id_type (oc-lldp-types:port-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_id_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_id_type() directly.

    YANG Description: This field identifies the format and source of the port
identifier string. It is an enumerator defined by the
PtopoPortIdType object from RFC2922.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'AGENT_CIRCUIT_ID': {}, 'LOCAL': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_id_type must be of a type compatible with oc-lldp-types:port-id-type""",
          'defined-type': "oc-lldp-types:port-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'AGENT_CIRCUIT_ID': {}, 'LOCAL': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)""",
        })

    self.__port_id_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_id_type(self):
    self.__port_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'INTERFACE_ALIAS': {}, 'PORT_COMPONENT': {}, 'MAC_ADDRESS': {}, 'NETWORK_ADDRESS': {}, 'INTERFACE_NAME': {}, 'AGENT_CIRCUIT_ID': {}, 'LOCAL': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)


  def _get_port_description(self):
    """
    Getter method for port_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_description (string)

    YANG Description: The binary string containing the actual port identifier for
the port which this LLDP PDU was transmitted. The source and
format of this field is defined by PtopoPortId from
RFC2922.
    """
    return self.__port_description
      
  def _set_port_description(self, v, load=False):
    """
    Setter method for port_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_description() directly.

    YANG Description: The binary string containing the actual port identifier for
the port which this LLDP PDU was transmitted. The source and
format of this field is defined by PtopoPortId from
RFC2922.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__port_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_description(self):
    self.__port_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_management_address(self):
    """
    Getter method for management_address, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address (string)

    YANG Description: The Management Address is a mandatory TLV which identifies a
network address associated with the local LLDP agent, which
can be used to reach the agent on the port identified in the
Port ID TLV.
    """
    return self.__management_address
      
  def _set_management_address(self, v, load=False):
    """
    Setter method for management_address, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_address() directly.

    YANG Description: The Management Address is a mandatory TLV which identifies a
network address associated with the local LLDP agent, which
can be used to reach the agent on the port identified in the
Port ID TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__management_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_address(self):
    self.__management_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_management_address_type(self):
    """
    Getter method for management_address_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address_type (string)

    YANG Description: The enumerated value for the network address type
identified in this TLV. This enumeration is defined in the
'Assigned Numbers' RFC [RFC3232] and the
ianaAddressFamilyNumbers object.
    """
    return self.__management_address_type
      
  def _set_management_address_type(self, v, load=False):
    """
    Setter method for management_address_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_address_type() directly.

    YANG Description: The enumerated value for the network address type
identified in this TLV. This enumeration is defined in the
'Assigned Numbers' RFC [RFC3232] and the
ianaAddressFamilyNumbers object.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_address_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__management_address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_address_type(self):
    self.__management_address_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

  system_name = __builtin__.property(_get_system_name)
  system_description = __builtin__.property(_get_system_description)
  chassis_id = __builtin__.property(_get_chassis_id)
  chassis_id_type = __builtin__.property(_get_chassis_id_type)
  id = __builtin__.property(_get_id)
  age = __builtin__.property(_get_age)
  last_update = __builtin__.property(_get_last_update)
  ttl = __builtin__.property(_get_ttl)
  port_id = __builtin__.property(_get_port_id)
  port_id_type = __builtin__.property(_get_port_id_type)
  port_description = __builtin__.property(_get_port_description)
  management_address = __builtin__.property(_get_management_address)
  management_address_type = __builtin__.property(_get_management_address_type)


  _pyangbind_elements = OrderedDict([('system_name', system_name), ('system_description', system_description), ('chassis_id', chassis_id), ('chassis_id_type', chassis_id_type), ('id', id), ('age', age), ('last_update', last_update), ('ttl', ttl), ('port_id', port_id), ('port_id_type', port_id_type), ('port_description', port_description), ('management_address', management_address), ('management_address_type', management_address_type), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs/tlv/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__oui','__oui_subtype','__value',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__value = YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors', 'neighbor', 'custom-tlvs', 'tlv', 'state']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/type (int32)

    YANG Description: The integer value identifying the type of information
contained in the value field.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/type (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The integer value identifying the type of information
contained in the value field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)


  def _get_oui(self):
    """
    Getter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui (string)

    YANG Description: The organizationally unique identifier field shall contain
the organization's OUI as defined in Clause 9 of IEEE Std
802. The high-order octet is 0 and the low-order 3 octets
are the SMI Network Management Private Enterprise Code of
the Vendor in network byte order, as defined in the
'Assigned Numbers' RFC [RFC3232].
    """
    return self.__oui
      
  def _set_oui(self, v, load=False):
    """
    Setter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui() directly.

    YANG Description: The organizationally unique identifier field shall contain
the organization's OUI as defined in Clause 9 of IEEE Std
802. The high-order octet is 0 and the low-order 3 octets
are the SMI Network Management Private Enterprise Code of
the Vendor in network byte order, as defined in the
'Assigned Numbers' RFC [RFC3232].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui(self):
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_oui_subtype(self):
    """
    Getter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui_subtype (string)

    YANG Description: The organizationally defined subtype field shall contain a
unique subtype value assigned by the defining organization.
    """
    return self.__oui_subtype
      
  def _set_oui_subtype(self, v, load=False):
    """
    Setter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui_subtype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui_subtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui_subtype() directly.

    YANG Description: The organizationally defined subtype field shall contain a
unique subtype value assigned by the defining organization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui_subtype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__oui_subtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui_subtype(self):
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/value (binary)

    YANG Description: A variable-length octet-string containing the
instance-specific information for this TLV.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: A variable-length octet-string containing the
instance-specific information for this TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)

  type = __builtin__.property(_get_type)
  oui = __builtin__.property(_get_oui)
  oui_subtype = __builtin__.property(_get_oui_subtype)
  value = __builtin__.property(_get_value)


  _pyangbind_elements = OrderedDict([('type', type), ('oui', oui), ('oui_subtype', oui_subtype), ('value', value), ])


class yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs/tlv. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of custom LLDP TLVs from a neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__oui','__oui_subtype','__state',)

  _yang_name = 'tlv'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors', 'neighbor', 'custom-tlvs', 'tlv']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/type (leafref)

    YANG Description: Reference to type list key
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Reference to type list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_oui(self):
    """
    Getter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui (leafref)

    YANG Description: Reference to oui list key
    """
    return self.__oui
      
  def _set_oui(self, v, load=False):
    """
    Setter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui() directly.

    YANG Description: Reference to oui list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui(self):
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_oui_subtype(self):
    """
    Getter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui_subtype (leafref)

    YANG Description: Reference to oui-subtype list key
    """
    return self.__oui_subtype
      
  def _set_oui_subtype(self, v, load=False):
    """
    Setter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui_subtype (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui_subtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui_subtype() directly.

    YANG Description: Reference to oui-subtype list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui_subtype must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__oui_subtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui_subtype(self):
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  type = __builtin__.property(_get_type)
  oui = __builtin__.property(_get_oui)
  oui_subtype = __builtin__.property(_get_oui_subtype)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('type', type), ('oui', oui), ('oui_subtype', oui_subtype), ('state', state), ])


class yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of custom TLVs from a
neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__tlv',)

  _yang_name = 'custom-tlvs'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tlv = YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors', 'neighbor', 'custom-tlvs']

  def _get_tlv(self):
    """
    Getter method for tlv, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv (list)

    YANG Description: List of custom LLDP TLVs from a neighbor
    """
    return self.__tlv
      
  def _set_tlv(self, v, load=False):
    """
    Setter method for tlv, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv() directly.

    YANG Description: List of custom LLDP TLVs from a neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)""",
        })

    self.__tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv(self):
    self.__tlv = YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

  tlv = __builtin__.property(_get_tlv)


  _pyangbind_elements = OrderedDict([('tlv', tlv), ])


class yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__state','__custom_tlvs',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__custom_tlvs = YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors', 'neighbor']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/id (leafref)

    YANG Description: System generated identifier for the neighbor on
the logical channel.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: System generated identifier for the neighbor on
the logical channel.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_custom_tlvs(self):
    """
    Getter method for custom_tlvs, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs (container)

    YANG Description: Enclosing container for list of custom TLVs from a
neighbor
    """
    return self.__custom_tlvs
      
  def _set_custom_tlvs(self, v, load=False):
    """
    Setter method for custom_tlvs, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_custom_tlvs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_custom_tlvs() directly.

    YANG Description: Enclosing container for list of custom TLVs from a
neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """custom_tlvs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__custom_tlvs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_custom_tlvs(self):
    self.__custom_tlvs = YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id)
  state = __builtin__.property(_get_state)
  custom_tlvs = __builtin__.property(_get_custom_tlvs)


  _pyangbind_elements = OrderedDict([('id', id), ('state', state), ('custom_tlvs', custom_tlvs), ])


class yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor (list)

    YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__neighbors',)

  _yang_name = 'lldp'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet', 'lldp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config (container)

    YANG Description: LLDP configuration data for logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: LLDP configuration data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state (container)

    YANG Description: LLDP operational state data for logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: LLDP operational state data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors (container)

    YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('neighbors', neighbors), ])


class yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for data related to Ethernet framing
for the logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__lldp',)

  _yang_name = 'ethernet'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__lldp = YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ethernet']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config (container)

    YANG Description: Configuration data for Ethernet protocol framing on
logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for Ethernet protocol framing on
logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_lldp(self):
    """
    Getter method for lldp, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp (container)

    YANG Description: LLDP data for logical channels
    """
    return self.__lldp
      
  def _set_lldp(self, v, load=False):
    """
    Setter method for lldp, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp() directly.

    YANG Description: LLDP data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp(self):
    self.__lldp = YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  lldp = __builtin__.property(_get_lldp, _set_lldp)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('lldp', lldp), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the signal source for the
logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver','__physical_channel','__interface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ingress', 'config']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/interface (oc-if:base-interface-ref)

    YANG Description: Reference to the interface carrying the input signal
for the logical channel. The ingress will specify an interface
in the case of a transceiver being utilized directly in a
router and bypassing a dedicated terminal device. When
specified, the other leaves in the ingress config must be
empty.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to the interface carrying the input signal
for the logical channel. The ingress will specify an interface
in the case of a transceiver being utilized directly in a
router and bypassing a dedicated terminal device. When
specified, the other leaves in the ingress config must be
empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=True)

  transceiver = __builtin__.property(_get_transceiver, _set_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel, _set_physical_channel)
  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('transceiver', transceiver), ('physical_channel', physical_channel), ('interface', interface), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the signal source for the
logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver','__physical_channel','__interface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ingress', 'state']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to the interface carrying the input signal
for the logical channel. The ingress will specify an interface
in the case of a transceiver being utilized directly in a
router and bypassing a dedicated terminal device. When
specified, the other leaves in the ingress config must be
empty.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to the interface carrying the input signal
for the logical channel. The ingress will specify an interface
in the case of a transceiver being utilized directly in a
router and bypassing a dedicated terminal device. When
specified, the other leaves in the ingress config must be
empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-if:base-interface-ref', is_config=False)

  transceiver = __builtin__.property(_get_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel)
  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('transceiver', transceiver), ('physical_channel', physical_channel), ('interface', interface), ])


class yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver, individual physical channels, or an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'ingress'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'ingress']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation','__tributary_slot_index','__mapping',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'logical-channel-assignments', 'assignment', 'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)


  def _get_tributary_slot_index(self):
    """
    Getter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/tributary_slot_index (int32)

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    return self.__tributary_slot_index
      
  def _set_tributary_slot_index(self, v, load=False):
    """
    Setter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/tributary_slot_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_index() directly.

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)""",
        })

    self.__tributary_slot_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_index(self):
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)


  def _get_mapping(self):
    """
    Getter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/mapping (identityref)

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    return self.__mapping
      
  def _set_mapping(self, v, load=False):
    """
    Setter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/mapping (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapping() directly.

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mapping must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapping(self):
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  assignment_type = __builtin__.property(_get_assignment_type, _set_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel, _set_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel, _set_optical_channel)
  allocation = __builtin__.property(_get_allocation, _set_allocation)
  tributary_slot_index = __builtin__.property(_get_tributary_slot_index, _set_tributary_slot_index)
  mapping = __builtin__.property(_get_mapping, _set_mapping)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('assignment_type', assignment_type), ('logical_channel', logical_channel), ('optical_channel', optical_channel), ('allocation', allocation), ('tributary_slot_index', tributary_slot_index), ('mapping', mapping), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation','__tributary_slot_index','__mapping',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'logical-channel-assignments', 'assignment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOGICAL_CHANNEL': {}, 'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_tributary_slot_index(self):
    """
    Getter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/tributary_slot_index (int32)

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    return self.__tributary_slot_index
      
  def _set_tributary_slot_index(self, v, load=False):
    """
    Setter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/tributary_slot_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_index() directly.

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)""",
        })

    self.__tributary_slot_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_index(self):
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)


  def _get_mapping(self):
    """
    Getter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/mapping (identityref)

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    return self.__mapping
      
  def _set_mapping(self, v, load=False):
    """
    Setter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/mapping (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapping() directly.

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mapping must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapping(self):
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:AMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:BMP': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:CBR': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_T': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:GFP_F': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  assignment_type = __builtin__.property(_get_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel)
  allocation = __builtin__.property(_get_allocation)
  tributary_slot_index = __builtin__.property(_get_tributary_slot_index)
  mapping = __builtin__.property(_get_mapping)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('assignment_type', assignment_type), ('logical_channel', logical_channel), ('optical_channel', optical_channel), ('allocation', allocation), ('tributary_slot_index', tributary_slot_index), ('mapping', mapping), ])


class yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state',)

  _yang_name = 'assignment'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'logical-channel-assignments', 'assignment']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)

    YANG Description: Reference to the index for the current tributary
assignment
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index for the current tributary
assignment
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)

    YANG Description: Configuration data for tributary assignments
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)

    YANG Description: Operational state data for tributary assignments
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ])


class yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__assignment',)

  _yang_name = 'logical-channel-assignments'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel', 'logical-channel-assignments']

  def _get_assignment(self):
    """
    Getter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    return self.__assignment
      
  def _set_assignment(self, v, load=False):
    """
    Setter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment() directly.

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment(self):
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  assignment = __builtin__.property(_get_assignment, _set_assignment)


  _pyangbind_elements = OrderedDict([('assignment', assignment), ])


class yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state','__otn','__ethernet','__ingress','__logical_channel_assignments',)

  _yang_name = 'channel'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels', 'channel']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)

    YANG Description: Reference to the index of the logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index of the logical channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)

    YANG Description: Configuration data for logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)

    YANG Description: Operational state data for logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_otn(self):
    """
    Getter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    return self.__otn
      
  def _set_otn(self, v, load=False):
    """
    Setter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_otn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_otn() directly.

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """otn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__otn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_otn(self):
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ingress(self):
    """
    Getter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver, individual physical channels, or an interface
    """
    return self.__ingress
      
  def _set_ingress(self, v, load=False):
    """
    Setter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress() directly.

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver, individual physical channels, or an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ingress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress(self):
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_logical_channel_assignments(self):
    """
    Getter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)

    YANG Description: Enclosing container for tributary assignments
    """
    return self.__logical_channel_assignments
      
  def _set_logical_channel_assignments(self, v, load=False):
    """
    Setter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignments() directly.

    YANG Description: Enclosing container for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channel_assignments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignments(self):
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  otn = __builtin__.property(_get_otn, _set_otn)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)
  ingress = __builtin__.property(_get_ingress, _set_ingress)
  logical_channel_assignments = __builtin__.property(_get_logical_channel_assignments, _set_logical_channel_assignments)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ('otn', otn), ('ethernet', ethernet), ('ingress', ingress), ('logical_channel_assignments', logical_channel_assignments), ])


class yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container the list of logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel',)

  _yang_name = 'logical-channels'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'logical-channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)

    YANG Description: List of logical channels
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = OrderedDict([('channel', channel), ])


class yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the platform-defined
operational mode
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_id','__description','__vendor_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__vendor_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'operational-modes', 'mode', 'state']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_vendor_id(self):
    """
    Getter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    return self.__vendor_id
      
  def _set_vendor_id(self, v, load=False):
    """
    Setter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_id() directly.

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__vendor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_id(self):
    self.__vendor_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  description = __builtin__.property(_get_description)
  vendor_id = __builtin__.property(_get_vendor_id)


  _pyangbind_elements = OrderedDict([('mode_id', mode_id), ('description', description), ('vendor_id', vendor_id), ])


class yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_id','__state',)

  _yang_name = 'mode'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'operational-modes', 'mode']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)

    YANG Description: Reference to mode-id
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Reference to mode-id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('mode_id', mode_id), ('state', state), ])


class yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of operational modes
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'operational-modes'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device', 'operational-modes']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_terminal_device_openconfig_terminal_device__terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the terminal device
  """
  __slots__ = ('_path_helper', '_extmethods', '__logical_channels','__operational_modes',)

  _yang_name = 'terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['terminal-device']

  def _get_logical_channels(self):
    """
    Getter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)

    YANG Description: Enclosing container the list of logical channels
    """
    return self.__logical_channels
      
  def _set_logical_channels(self, v, load=False):
    """
    Setter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channels() directly.

    YANG Description: Enclosing container the list of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channels(self):
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_operational_modes(self):
    """
    Getter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)

    YANG Description: Enclosing container for list of operational modes
    """
    return self.__operational_modes
      
  def _set_operational_modes(self, v, load=False):
    """
    Setter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_modes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_modes() directly.

    YANG Description: Enclosing container for list of operational modes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_modes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__operational_modes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_modes(self):
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  logical_channels = __builtin__.property(_get_logical_channels, _set_logical_channels)
  operational_modes = __builtin__.property(_get_operational_modes, _set_operational_modes)


  _pyangbind_elements = OrderedDict([('logical_channels', logical_channels), ('operational_modes', operational_modes), ])


class openconfig_terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /openconfig-terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a terminal optics device model for
managing the terminal systems (client and line side) in a
DWDM transport network.

Elements of the model:

physical port: corresponds to a physical, pluggable client
port on the terminal device. Examples includes 10G, 40G, 100G
(e.g., 10x10G, 4x25G or 1x100G) and 400G/1T in the future.
Physical client ports will have associated operational state or
PMs.

physical channel: a physical lane or channel in the
physical client port.  Each physical client port has 1 or more
channels. An example is 100GBASE-LR4 client physical port having
4x25G channels. Channels have their own optical PMs and can be
monitored independently within a client physical port (e.g.,
channel power).  Physical client channels are defined in the
model as part of a physical client port, and are modeled
primarily for reading their PMs.

logical channel: a logical grouping of logical grooming elements
that may be assigned to subsequent grooming stages for
multiplexing / de-multiplexing, or to an optical channel for
line side transmission.  The logical channels can represent, for
example, an ODU/OTU logical packing of the client
data onto the line side.  Tributaries are similarly logical
groupings of demand that can be represented in this structure and
assigned to an optical channel.  Note that different types of
logical channels may be present, each with their corresponding
PMs.

optical channel:  corresponds to an optical carrier and is
assigned a wavelength/frequency.  Optical channels have PMs
such as power, BER, and operational mode.

Directionality:

To maintain simplicity in the model, the configuration is
described from client-to-line direction.  The assumption is that
equivalent reverse configuration is implicit, resulting in
the same line-to-client configuration.

Physical layout:

The model does not assume a particular physical layout of client
and line ports on the terminal device (e.g., such as number of
ports per linecard, separate linecards for client and line ports,
etc.).
  """
  __slots__ = ('_path_helper', '_extmethods', '__terminal_device',)

  _yang_name = 'openconfig-terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_terminal_device(self):
    """
    Getter method for terminal_device, mapped from YANG variable /terminal_device (container)

    YANG Description: Top-level container for the terminal device
    """
    return self.__terminal_device
      
  def _set_terminal_device(self, v, load=False):
    """
    Setter method for terminal_device, mapped from YANG variable /terminal_device (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_device() directly.

    YANG Description: Top-level container for the terminal device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_device must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__terminal_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_device(self):
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  terminal_device = __builtin__.property(_get_terminal_device, _set_terminal_device)


  _pyangbind_elements = OrderedDict([('terminal_device', terminal_device), ])


class yc_config_openconfig_transport_line_connectivity__connections_connection_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /connections/connection/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__source','__dest','__fiber_type',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=True)
    self.__source = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)
    self.__dest = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)
    self.__fiber_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['connections', 'connection', 'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /connections/connection/config/index (uint32)

    YANG Description: Index for the defined connection
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /connections/connection/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index for the defined connection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /connections/connection/config/source (union)

    YANG Description: The user supplied name of the source port of the connection
within the system. If the port is within the device, the
string should reflect the name of the port as it appears in
the components model. If the port is not represented in the
components model (e.g., a port on a passive chassis), the
string should reflect the system assigned name of the port.
If the source port is not within the device, then an
identityref of EXTERNAL should be specified.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /connections/connection/config/source (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: The user supplied name of the source port of the connection
within the system. If the port is within the device, the
string should reflect the name of the port as it appears in
the components model. If the port is not represented in the
components model (e.g., a port on a passive chassis), the
string should reflect the system assigned name of the port.
If the source port is not within the device, then an
identityref of EXTERNAL should be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with union""",
          'defined-type': "openconfig-transport-line-connectivity:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)


  def _get_dest(self):
    """
    Getter method for dest, mapped from YANG variable /connections/connection/config/dest (union)

    YANG Description: The user supplied name of the destination port of the connection
within the system. If the port is within the device, the string
should reflect the name of the port as it appears in the
components model. If the port is not represented in the components
model (e.g., a port on a passive chassis), the string should
reflect the system assigned name of the port. If the destination
port is not within the device, then an identityref of EXTERNAL
should be specified.
    """
    return self.__dest
      
  def _set_dest(self, v, load=False):
    """
    Setter method for dest, mapped from YANG variable /connections/connection/config/dest (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest() directly.

    YANG Description: The user supplied name of the destination port of the connection
within the system. If the port is within the device, the string
should reflect the name of the port as it appears in the
components model. If the port is not represented in the components
model (e.g., a port on a passive chassis), the string should
reflect the system assigned name of the port. If the destination
port is not within the device, then an identityref of EXTERNAL
should be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest must be of a type compatible with union""",
          'defined-type': "openconfig-transport-line-connectivity:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)""",
        })

    self.__dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest(self):
    self.__dest = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=True)


  def _get_fiber_type(self):
    """
    Getter method for fiber_type, mapped from YANG variable /connections/connection/config/fiber_type (identityref)

    YANG Description: The type of fiber jumper used for the connection.
    """
    return self.__fiber_type
      
  def _set_fiber_type(self, v, load=False):
    """
    Setter method for fiber_type, mapped from YANG variable /connections/connection/config/fiber_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type() directly.

    YANG Description: The type of fiber jumper used for the connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-transport-line-connectivity:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=True)""",
        })

    self.__fiber_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type(self):
    self.__fiber_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  source = __builtin__.property(_get_source, _set_source)
  dest = __builtin__.property(_get_dest, _set_dest)
  fiber_type = __builtin__.property(_get_fiber_type, _set_fiber_type)


  _pyangbind_elements = OrderedDict([('index', index), ('source', source), ('dest', dest), ('fiber_type', fiber_type), ])


class yc_state_openconfig_transport_line_connectivity__connections_connection_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /connections/connection/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__source','__dest','__fiber_type',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=False)
    self.__source = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)
    self.__dest = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)
    self.__fiber_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['connections', 'connection', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /connections/connection/state/index (uint32)

    YANG Description: Index for the defined connection
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /connections/connection/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index for the defined connection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='uint32', is_config=False)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /connections/connection/state/source (union)

    YANG Description: The user supplied name of the source port of the connection
within the system. If the port is within the device, the
string should reflect the name of the port as it appears in
the components model. If the port is not represented in the
components model (e.g., a port on a passive chassis), the
string should reflect the system assigned name of the port.
If the source port is not within the device, then an
identityref of EXTERNAL should be specified.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /connections/connection/state/source (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: The user supplied name of the source port of the connection
within the system. If the port is within the device, the
string should reflect the name of the port as it appears in
the components model. If the port is not represented in the
components model (e.g., a port on a passive chassis), the
string should reflect the system assigned name of the port.
If the source port is not within the device, then an
identityref of EXTERNAL should be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with union""",
          'defined-type': "openconfig-transport-line-connectivity:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)


  def _get_dest(self):
    """
    Getter method for dest, mapped from YANG variable /connections/connection/state/dest (union)

    YANG Description: The user supplied name of the destination port of the connection
within the system. If the port is within the device, the string
should reflect the name of the port as it appears in the
components model. If the port is not represented in the components
model (e.g., a port on a passive chassis), the string should
reflect the system assigned name of the port. If the destination
port is not within the device, then an identityref of EXTERNAL
should be specified.
    """
    return self.__dest
      
  def _set_dest(self, v, load=False):
    """
    Setter method for dest, mapped from YANG variable /connections/connection/state/dest (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest() directly.

    YANG Description: The user supplied name of the destination port of the connection
within the system. If the port is within the device, the string
should reflect the name of the port as it appears in the
components model. If the port is not represented in the components
model (e.g., a port on a passive chassis), the string should
reflect the system assigned name of the port. If the destination
port is not within the device, then an identityref of EXTERNAL
should be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest must be of a type compatible with union""",
          'defined-type': "openconfig-transport-line-connectivity:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)""",
        })

    self.__dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest(self):
    self.__dest = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}, 'oc-line-connect:EXTERNAL': {'@module': 'openconfig-transport-line-connectivity', '@namespace': 'http://openconfig.net/yang/openconfig-transport-line-connectivity'}},),], is_leaf=True, yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='union', is_config=False)


  def _get_fiber_type(self):
    """
    Getter method for fiber_type, mapped from YANG variable /connections/connection/state/fiber_type (identityref)

    YANG Description: The type of fiber jumper used for the connection.
    """
    return self.__fiber_type
      
  def _set_fiber_type(self, v, load=False):
    """
    Setter method for fiber_type, mapped from YANG variable /connections/connection/state/fiber_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type() directly.

    YANG Description: The type of fiber jumper used for the connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-transport-line-connectivity:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=False)""",
        })

    self.__fiber_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type(self):
    self.__fiber_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_SIMPLEX': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}, 'oc-opt-types:FIBER_JUMPER_MULTI_FIBER_STRAND': {'@module': 'openconfig-transport-types', '@namespace': 'http://openconfig.net/yang/transport-types'}},), is_leaf=True, yang_name="fiber-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='identityref', is_config=False)

  index = __builtin__.property(_get_index)
  source = __builtin__.property(_get_source)
  dest = __builtin__.property(_get_dest)
  fiber_type = __builtin__.property(_get_fiber_type)


  _pyangbind_elements = OrderedDict([('index', index), ('source', source), ('dest', dest), ('fiber_type', fiber_type), ])


class yc_connection_openconfig_transport_line_connectivity__connections_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /connections/connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of line system connections
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state',)

  _yang_name = 'connection'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_connectivity__connections_connection_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_connectivity__connections_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['connections', 'connection']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /connections/connection/index (leafref)

    YANG Description: Reference to index number of the connection
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /connections/connection/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to index number of the connection
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /connections/connection/config (container)

    YANG Description: Configuration data
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /connections/connection/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_connectivity__connections_connection_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_connectivity__connections_connection_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_connectivity__connections_connection_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /connections/connection/state (container)

    YANG Description: Operational state data
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /connections/connection/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_connectivity__connections_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_connectivity__connections_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_connectivity__connections_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ])


class yc_connections_openconfig_transport_line_connectivity__connections(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /connections. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for line system connections list
  """
  __slots__ = ('_path_helper', '_extmethods', '__connection',)

  _yang_name = 'connections'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connection = YANGDynClass(base=YANGListType("index",yc_connection_openconfig_transport_line_connectivity__connections_connection, yang_name="connection", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['connections']

  def _get_connection(self):
    """
    Getter method for connection, mapped from YANG variable /connections/connection (list)

    YANG Description: List of line system connections
    """
    return self.__connection
      
  def _set_connection(self, v, load=False):
    """
    Setter method for connection, mapped from YANG variable /connections/connection (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection() directly.

    YANG Description: List of line system connections
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_connection_openconfig_transport_line_connectivity__connections_connection, yang_name="connection", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_connection_openconfig_transport_line_connectivity__connections_connection, yang_name="connection", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='list', is_config=True)""",
        })

    self.__connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection(self):
    self.__connection = YANGDynClass(base=YANGListType("index",yc_connection_openconfig_transport_line_connectivity__connections_connection, yang_name="connection", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='list', is_config=True)

  connection = __builtin__.property(_get_connection, _set_connection)


  _pyangbind_elements = OrderedDict([('connection', connection), ])


class openconfig_transport_line_connectivity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /openconfig-transport-line-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes the device-level connectivity
(e.g., internal port-to-port) for optical transport line
system elements such as wavelength routers (ROADMs) and
amplifiers. All connections are uni-directional. Note that
this model explicitly does not intend to model or provide
a path to any higher layer topology modeling and is only
for modeling internal links
  """
  __slots__ = ('_path_helper', '_extmethods', '__connections',)

  _yang_name = 'openconfig-transport-line-connectivity'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connections = YANGDynClass(base=yc_connections_openconfig_transport_line_connectivity__connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_connections(self):
    """
    Getter method for connections, mapped from YANG variable /connections (container)

    YANG Description: Enclosing container for line system connections list
    """
    return self.__connections
      
  def _set_connections(self, v, load=False):
    """
    Setter method for connections, mapped from YANG variable /connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connections() directly.

    YANG Description: Enclosing container for line system connections list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_connections_openconfig_transport_line_connectivity__connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_connections_openconfig_transport_line_connectivity__connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)""",
        })

    self.__connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connections(self):
    self.__connections = YANGDynClass(base=yc_connections_openconfig_transport_line_connectivity__connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

  connections = __builtin__.property(_get_connections, _set_connections)


  _pyangbind_elements = OrderedDict([('connections', connections), ])


class yc_config_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the attenuator
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__attenuation_mode','__target_output_power','__attenuation','__enabled',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=True)
    self.__attenuation_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=True)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)
    self.__attenuation = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/name (string)

    YANG Description: User-defined name assigned to identify a specific attenuator
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific attenuator
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=True)


  def _get_attenuation_mode(self):
    """
    Getter method for attenuation_mode, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/attenuation_mode (identityref)

    YANG Description: The operating mode of the attenuator
    """
    return self.__attenuation_mode
      
  def _set_attenuation_mode(self, v, load=False):
    """
    Setter method for attenuation_mode, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/attenuation_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation_mode() directly.

    YANG Description: The operating mode of the attenuator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-attenuator:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=True)""",
        })

    self.__attenuation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation_mode(self):
    self.__attenuation_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=True)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/target_output_power (decimal64)

    YANG Description: Power level set on the output of attenuator.  This leaf is
only relevant when in CONSTANT_POWER mode.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Power level set on the output of attenuator.  This leaf is
only relevant when in CONSTANT_POWER mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/attenuation (decimal64)

    YANG Description: Attenuation applied by the attenuator.  This leaf is only
relevant when in CONSTANT_ATTENUATION mode.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: Attenuation applied by the attenuator.  This leaf is only
relevant when in CONSTANT_ATTENUATION mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/enabled (boolean)

    YANG Description: When true, attenuator is set to specified attenuation or varies to
maintain constant output power.  When false, the attenuator is set
max attenuation or blocked.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When true, attenuator is set to specified attenuation or varies to
maintain constant output power.  When false, the attenuator is set
max attenuation or blocked.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  attenuation_mode = __builtin__.property(_get_attenuation_mode, _set_attenuation_mode)
  target_output_power = __builtin__.property(_get_target_output_power, _set_target_output_power)
  attenuation = __builtin__.property(_get_attenuation, _set_attenuation)
  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('name', name), ('attenuation_mode', attenuation_mode), ('target_output_power', target_output_power), ('attenuation', attenuation), ('enabled', enabled), ])


class yc_actual_attenuation_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_actual_attenuation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator/state/actual-attenuation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The actual attenuation applied by the attenuator in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'actual-attenuation'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator', 'state', 'actual-attenuation']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_total_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_output_power_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator/state/output-power-total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power-total'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator', 'state', 'output-power-total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_optical_return_loss_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_optical_return_loss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator/state/optical-return-loss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-return-loss'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator', 'state', 'optical-return-loss']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the attenuator
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__attenuation_mode','__target_output_power','__attenuation','__enabled','__component','__ingress_port','__egress_port','__actual_attenuation','__output_power_total','__optical_return_loss',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=False)
    self.__attenuation_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=False)
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    self.__ingress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    self.__egress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    self.__actual_attenuation = YANGDynClass(base=yc_actual_attenuation_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_actual_attenuation, is_container='container', yang_name="actual-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/name (string)

    YANG Description: User-defined name assigned to identify a specific attenuator
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific attenuator
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='string', is_config=False)


  def _get_attenuation_mode(self):
    """
    Getter method for attenuation_mode, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/attenuation_mode (identityref)

    YANG Description: The operating mode of the attenuator
    """
    return self.__attenuation_mode
      
  def _set_attenuation_mode(self, v, load=False):
    """
    Setter method for attenuation_mode, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/attenuation_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation_mode() directly.

    YANG Description: The operating mode of the attenuator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-attenuator:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=False)""",
        })

    self.__attenuation_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation_mode(self):
    self.__attenuation_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_POWER': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}, 'oc-opt-att:CONSTANT_ATTENUATION': {'@module': 'openconfig-optical-attenuator', '@namespace': 'http://openconfig.net/yang/optical-attenuator'}},), is_leaf=True, yang_name="attenuation-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='identityref', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/target_output_power (decimal64)

    YANG Description: Power level set on the output of attenuator.  This leaf is
only relevant when in CONSTANT_POWER mode.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Power level set on the output of attenuator.  This leaf is
only relevant when in CONSTANT_POWER mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/attenuation (decimal64)

    YANG Description: Attenuation applied by the attenuator.  This leaf is only
relevant when in CONSTANT_ATTENUATION mode.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: Attenuation applied by the attenuator.  This leaf is only
relevant when in CONSTANT_ATTENUATION mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='decimal64', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/enabled (boolean)

    YANG Description: When true, attenuator is set to specified attenuation or varies to
maintain constant output power.  When false, the attenuator is set
max attenuation or blocked.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When true, attenuator is set to specified attenuation or varies to
maintain constant output power.  When false, the attenuator is set
max attenuation or blocked.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='boolean', is_config=False)


  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/component (leafref)

    YANG Description: Reference to the system-supplied physical component that
the attenuator block is contained within. Multiple
attenuator blocks may be contained within the same
physical component.
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/component (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: Reference to the system-supplied physical component that
the attenuator block is contained within. Multiple
attenuator blocks may be contained within the same
physical component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)


  def _get_ingress_port(self):
    """
    Getter method for ingress_port, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/ingress_port (leafref)

    YANG Description: Reference to system-supplied name of the attenuator ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    return self.__ingress_port
      
  def _set_ingress_port(self, v, load=False):
    """
    Setter method for ingress_port, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/ingress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_port() directly.

    YANG Description: Reference to system-supplied name of the attenuator ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)""",
        })

    self.__ingress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_port(self):
    self.__ingress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)


  def _get_egress_port(self):
    """
    Getter method for egress_port, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/egress_port (leafref)

    YANG Description: Reference to system-supplied name of the attenuator egress
port. This leaf is only valid for ports of type EGRESS.
    """
    return self.__egress_port
      
  def _set_egress_port(self, v, load=False):
    """
    Setter method for egress_port, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/egress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_port() directly.

    YANG Description: Reference to system-supplied name of the attenuator egress
port. This leaf is only valid for ports of type EGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)""",
        })

    self.__egress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_port(self):
    self.__egress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=False)


  def _get_actual_attenuation(self):
    """
    Getter method for actual_attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation (container)

    YANG Description: The actual attenuation applied by the attenuator in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__actual_attenuation
      
  def _set_actual_attenuation(self, v, load=False):
    """
    Setter method for actual_attenuation, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/actual_attenuation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actual_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actual_attenuation() directly.

    YANG Description: The actual attenuation applied by the attenuator in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actual_attenuation_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_actual_attenuation, is_container='container', yang_name="actual-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actual_attenuation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actual_attenuation_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_actual_attenuation, is_container='container', yang_name="actual-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)""",
        })

    self.__actual_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actual_attenuation(self):
    self.__actual_attenuation = YANGDynClass(base=yc_actual_attenuation_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_actual_attenuation, is_container='container', yang_name="actual-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)


  def _get_output_power_total(self):
    """
    Getter method for output_power_total, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total (container)

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_total
      
  def _set_output_power_total(self, v, load=False):
    """
    Setter method for output_power_total, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/output_power_total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_total() directly.

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_total_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_total_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)""",
        })

    self.__output_power_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_total(self):
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)


  def _get_optical_return_loss(self):
    """
    Getter method for optical_return_loss, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss (container)

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value.
    """
    return self.__optical_return_loss
      
  def _set_optical_return_loss(self, v, load=False):
    """
    Setter method for optical_return_loss, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state/optical_return_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_return_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_return_loss() directly.

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_return_loss_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_return_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_return_loss_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)""",
        })

    self.__optical_return_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_return_loss(self):
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  attenuation_mode = __builtin__.property(_get_attenuation_mode)
  target_output_power = __builtin__.property(_get_target_output_power)
  attenuation = __builtin__.property(_get_attenuation)
  enabled = __builtin__.property(_get_enabled)
  component = __builtin__.property(_get_component)
  ingress_port = __builtin__.property(_get_ingress_port)
  egress_port = __builtin__.property(_get_egress_port)
  actual_attenuation = __builtin__.property(_get_actual_attenuation)
  output_power_total = __builtin__.property(_get_output_power_total)
  optical_return_loss = __builtin__.property(_get_optical_return_loss)


  _pyangbind_elements = OrderedDict([('name', name), ('attenuation_mode', attenuation_mode), ('target_output_power', target_output_power), ('attenuation', attenuation), ('enabled', enabled), ('component', component), ('ingress_port', ingress_port), ('egress_port', egress_port), ('actual_attenuation', actual_attenuation), ('output_power_total', output_power_total), ('optical_return_loss', optical_return_loss), ])


class yc_attenuator_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators/attenuator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of variable optical attenuators present in the device
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'attenuator'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators', 'attenuator']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/name (leafref)

    YANG Description: Reference to the name of the attenuator
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_attenuator/attenuators/attenuator/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the attenuator
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config (container)

    YANG Description: Configuration data for the attenuator
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /optical_attenuator/attenuators/attenuator/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the attenuator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state (container)

    YANG Description: Operational state data for the attenuator
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /optical_attenuator/attenuators/attenuator/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the attenuator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_attenuators_openconfig_optical_attenuator__optical_attenuator_attenuators(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator/attenuators. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of attenuators
  """
  __slots__ = ('_path_helper', '_extmethods', '__attenuator',)

  _yang_name = 'attenuators'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attenuator = YANGDynClass(base=YANGListType("name",yc_attenuator_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator, yang_name="attenuator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator', 'attenuators']

  def _get_attenuator(self):
    """
    Getter method for attenuator, mapped from YANG variable /optical_attenuator/attenuators/attenuator (list)

    YANG Description: List of variable optical attenuators present in the device
    """
    return self.__attenuator
      
  def _set_attenuator(self, v, load=False):
    """
    Setter method for attenuator, mapped from YANG variable /optical_attenuator/attenuators/attenuator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuator() directly.

    YANG Description: List of variable optical attenuators present in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_attenuator_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator, yang_name="attenuator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuator must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_attenuator_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator, yang_name="attenuator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='list', is_config=True)""",
        })

    self.__attenuator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuator(self):
    self.__attenuator = YANGDynClass(base=YANGListType("name",yc_attenuator_openconfig_optical_attenuator__optical_attenuator_attenuators_attenuator, yang_name="attenuator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='list', is_config=True)

  attenuator = __builtin__.property(_get_attenuator, _set_attenuator)


  _pyangbind_elements = OrderedDict([('attenuator', attenuator), ])


class yc_optical_attenuator_openconfig_optical_attenuator__optical_attenuator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /optical-attenuator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for attenuators
  """
  __slots__ = ('_path_helper', '_extmethods', '__attenuators',)

  _yang_name = 'optical-attenuator'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attenuators = YANGDynClass(base=yc_attenuators_openconfig_optical_attenuator__optical_attenuator_attenuators, is_container='container', yang_name="attenuators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-attenuator']

  def _get_attenuators(self):
    """
    Getter method for attenuators, mapped from YANG variable /optical_attenuator/attenuators (container)

    YANG Description: Enclosing container for list of attenuators
    """
    return self.__attenuators
      
  def _set_attenuators(self, v, load=False):
    """
    Setter method for attenuators, mapped from YANG variable /optical_attenuator/attenuators (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuators is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuators() directly.

    YANG Description: Enclosing container for list of attenuators
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_attenuators_openconfig_optical_attenuator__optical_attenuator_attenuators, is_container='container', yang_name="attenuators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuators must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_attenuators_openconfig_optical_attenuator__optical_attenuator_attenuators, is_container='container', yang_name="attenuators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__attenuators = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuators(self):
    self.__attenuators = YANGDynClass(base=yc_attenuators_openconfig_optical_attenuator__optical_attenuator_attenuators, is_container='container', yang_name="attenuators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

  attenuators = __builtin__.property(_get_attenuators, _set_attenuators)


  _pyangbind_elements = OrderedDict([('attenuators', attenuators), ])


class openconfig_optical_attenuator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /openconfig-optical-attenuator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for variable optical attenuators, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_attenuator',)

  _yang_name = 'openconfig-optical-attenuator'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_attenuator = YANGDynClass(base=yc_optical_attenuator_openconfig_optical_attenuator__optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_attenuator(self):
    """
    Getter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)

    YANG Description: Enclosing container for attenuators
    """
    return self.__optical_attenuator
      
  def _set_optical_attenuator(self, v, load=False):
    """
    Setter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_attenuator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_attenuator() directly.

    YANG Description: Enclosing container for attenuators
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_attenuator_openconfig_optical_attenuator__optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_attenuator must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_attenuator_openconfig_optical_attenuator__optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__optical_attenuator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_attenuator(self):
    self.__optical_attenuator = YANGDynClass(base=yc_optical_attenuator_openconfig_optical_attenuator__optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

  optical_attenuator = __builtin__.property(_get_optical_attenuator, _set_optical_attenuator)


  _pyangbind_elements = OrderedDict([('optical_attenuator', optical_attenuator), ])


class yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__name','__lower_frequency','__upper_frequency','__admin_status','__super_channel','__super_channel_parent','__ase_control_mode','__ase_injection_mode','__ase_injection_threshold','__ase_injection_delta','__attenuation_control_mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=True)
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=True)
    self.__super_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=True)
    self.__super_channel_parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__ase_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)
    self.__ase_injection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=True)
    self.__ase_injection_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    self.__ase_injection_delta = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    self.__attenuation_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/config/index (uint32)

    YANG Description: Identifier for the defined media channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Identifier for the defined media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /wavelength_router/media_channels/channel/config/name (string)

    YANG Description: The user supplied name of the media channel
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /wavelength_router/media_channels/channel/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The user supplied name of the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=True)


  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/config/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: The lower frequency for the spectrum defined by this media
channel
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/config/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: The lower frequency for the spectrum defined by this media
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/config/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: The upper frequency for the spectrum defined by this media
channel
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/config/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: The upper frequency for the spectrum defined by this media
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /wavelength_router/media_channels/channel/config/admin_status (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin status of the media channel
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /wavelength_router/media_channels/channel/config/admin_status (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Sets the admin status of the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=True)


  def _get_super_channel(self):
    """
    Getter method for super_channel, mapped from YANG variable /wavelength_router/media_channels/channel/config/super_channel (boolean)

    YANG Description: True if the media channel is a super channel which
contains multiple media channels within it. The contained
media channels should fall within the boundaries of the
super channel. The device should raise an error if a media
channel crosses a super channel boundary. When using super
channels, spectrum power targets should be defined in either
the:
- port-spectrum-power-profiles for the port which matches the
  source port of the media channel representing the super
  channel
- media channels that are contained within the super
  channel, but not on the super channel itself
    """
    return self.__super_channel
      
  def _set_super_channel(self, v, load=False):
    """
    Setter method for super_channel, mapped from YANG variable /wavelength_router/media_channels/channel/config/super_channel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_super_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_super_channel() directly.

    YANG Description: True if the media channel is a super channel which
contains multiple media channels within it. The contained
media channels should fall within the boundaries of the
super channel. The device should raise an error if a media
channel crosses a super channel boundary. When using super
channels, spectrum power targets should be defined in either
the:
- port-spectrum-power-profiles for the port which matches the
  source port of the media channel representing the super
  channel
- media channels that are contained within the super
  channel, but not on the super channel itself
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """super_channel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=True)""",
        })

    self.__super_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_super_channel(self):
    self.__super_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=True)


  def _get_super_channel_parent(self):
    """
    Getter method for super_channel_parent, mapped from YANG variable /wavelength_router/media_channels/channel/config/super_channel_parent (leafref)

    YANG Description: If the media channel is contained within a super channel this
would specify the index of the super channel parent
    """
    return self.__super_channel_parent
      
  def _set_super_channel_parent(self, v, load=False):
    """
    Setter method for super_channel_parent, mapped from YANG variable /wavelength_router/media_channels/channel/config/super_channel_parent (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_super_channel_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_super_channel_parent() directly.

    YANG Description: If the media channel is contained within a super channel this
would specify the index of the super channel parent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """super_channel_parent must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__super_channel_parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_super_channel_parent(self):
    self.__super_channel_parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_ase_control_mode(self):
    """
    Getter method for ase_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_control_mode (identityref)

    YANG Description: Sets the ASE control mode for the media channel.
The control mode defines if and when ASE noise is injected
on the media channel
    """
    return self.__ase_control_mode
      
  def _set_ase_control_mode(self, v, load=False):
    """
    Setter method for ase_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_control_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_control_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_control_mode() directly.

    YANG Description: Sets the ASE control mode for the media channel.
The control mode defines if and when ASE noise is injected
on the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_control_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-wavelength-router:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)""",
        })

    self.__ase_control_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_control_mode(self):
    self.__ase_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)


  def _get_ase_injection_mode(self):
    """
    Getter method for ase_injection_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_mode (enumeration)

    YANG Description: When specified, defines the mode used to determine whether
ASE noise should be injected on the media channel.
    """
    return self.__ase_injection_mode
      
  def _set_ase_injection_mode(self, v, load=False):
    """
    Setter method for ase_injection_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_mode() directly.

    YANG Description: When specified, defines the mode used to determine whether
ASE noise should be injected on the media channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wavelength-router:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=True)""",
        })

    self.__ase_injection_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_mode(self):
    self.__ase_injection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=True)


  def _get_ase_injection_threshold(self):
    """
    Getter method for ase_injection_threshold, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_threshold (decimal64)

    YANG Description: Defines the optical power threshold value below which ASE
noise should be injected on the media channel. This or
ase-injection-delta is required if an ase-control-mode is
configured
    """
    return self.__ase_injection_threshold
      
  def _set_ase_injection_threshold(self, v, load=False):
    """
    Setter method for ase_injection_threshold, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_threshold() directly.

    YANG Description: Defines the optical power threshold value below which ASE
noise should be injected on the media channel. This or
ase-injection-delta is required if an ase-control-mode is
configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)""",
        })

    self.__ase_injection_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_threshold(self):
    self.__ase_injection_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)


  def _get_ase_injection_delta(self):
    """
    Getter method for ase_injection_delta, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_delta (decimal64)

    YANG Description: Defines the optical power loss from the configured spectrum
power profile, which would indicate that ASE noise should be
injected on the media channel. This or
ase-injection-threshold is required if an ase-control-mode
is configured
    """
    return self.__ase_injection_delta
      
  def _set_ase_injection_delta(self, v, load=False):
    """
    Setter method for ase_injection_delta, mapped from YANG variable /wavelength_router/media_channels/channel/config/ase_injection_delta (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_delta() directly.

    YANG Description: Defines the optical power loss from the configured spectrum
power profile, which would indicate that ASE noise should be
injected on the media channel. This or
ase-injection-threshold is required if an ase-control-mode
is configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_delta must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)""",
        })

    self.__ase_injection_delta = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_delta(self):
    self.__ase_injection_delta = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)


  def _get_attenuation_control_mode(self):
    """
    Getter method for attenuation_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/attenuation_control_mode (identityref)

    YANG Description: Sets the attenuation control mode for the media channel.
The control mode defines the behavior of how the attenuation
across a media channel is set
    """
    return self.__attenuation_control_mode
      
  def _set_attenuation_control_mode(self, v, load=False):
    """
    Setter method for attenuation_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/config/attenuation_control_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation_control_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation_control_mode() directly.

    YANG Description: Sets the attenuation control mode for the media channel.
The control mode defines the behavior of how the attenuation
across a media channel is set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation_control_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-wavelength-router:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)""",
        })

    self.__attenuation_control_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation_control_mode(self):
    self.__attenuation_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  name = __builtin__.property(_get_name, _set_name)
  lower_frequency = __builtin__.property(_get_lower_frequency, _set_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency, _set_upper_frequency)
  admin_status = __builtin__.property(_get_admin_status, _set_admin_status)
  super_channel = __builtin__.property(_get_super_channel, _set_super_channel)
  super_channel_parent = __builtin__.property(_get_super_channel_parent, _set_super_channel_parent)
  ase_control_mode = __builtin__.property(_get_ase_control_mode, _set_ase_control_mode)
  ase_injection_mode = __builtin__.property(_get_ase_injection_mode, _set_ase_injection_mode)
  ase_injection_threshold = __builtin__.property(_get_ase_injection_threshold, _set_ase_injection_threshold)
  ase_injection_delta = __builtin__.property(_get_ase_injection_delta, _set_ase_injection_delta)
  attenuation_control_mode = __builtin__.property(_get_attenuation_control_mode, _set_attenuation_control_mode)


  _pyangbind_elements = OrderedDict([('index', index), ('name', name), ('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('admin_status', admin_status), ('super_channel', super_channel), ('super_channel_parent', super_channel_parent), ('ase_control_mode', ase_control_mode), ('ase_injection_mode', ase_injection_mode), ('ase_injection_threshold', ase_injection_threshold), ('ase_injection_delta', ase_injection_delta), ('attenuation_control_mode', attenuation_control_mode), ])


class yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__name','__lower_frequency','__upper_frequency','__admin_status','__super_channel','__super_channel_parent','__ase_control_mode','__ase_injection_mode','__ase_injection_threshold','__ase_injection_delta','__attenuation_control_mode','__oper_status','__ase_status',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=False)
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=False)
    self.__super_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=False)
    self.__super_channel_parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)
    self.__ase_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)
    self.__ase_injection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)
    self.__ase_injection_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    self.__ase_injection_delta = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    self.__attenuation_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)
    self.__ase_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRESENT': {}, 'NOT_PRESENT': {}},), is_leaf=True, yang_name="ase-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/state/index (uint32)

    YANG Description: Identifier for the defined media channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Identifier for the defined media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='uint32', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /wavelength_router/media_channels/channel/state/name (string)

    YANG Description: The user supplied name of the media channel
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /wavelength_router/media_channels/channel/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The user supplied name of the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='string', is_config=False)


  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/state/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: The lower frequency for the spectrum defined by this media
channel
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/state/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: The lower frequency for the spectrum defined by this media
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/state/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: The upper frequency for the spectrum defined by this media
channel
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/state/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: The upper frequency for the spectrum defined by this media
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/admin_status (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin status of the media channel
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/admin_status (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Sets the admin status of the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=False)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'MAINT': {}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:admin-state-type', is_config=False)


  def _get_super_channel(self):
    """
    Getter method for super_channel, mapped from YANG variable /wavelength_router/media_channels/channel/state/super_channel (boolean)

    YANG Description: True if the media channel is a super channel which
contains multiple media channels within it. The contained
media channels should fall within the boundaries of the
super channel. The device should raise an error if a media
channel crosses a super channel boundary. When using super
channels, spectrum power targets should be defined in either
the:
- port-spectrum-power-profiles for the port which matches the
  source port of the media channel representing the super
  channel
- media channels that are contained within the super
  channel, but not on the super channel itself
    """
    return self.__super_channel
      
  def _set_super_channel(self, v, load=False):
    """
    Setter method for super_channel, mapped from YANG variable /wavelength_router/media_channels/channel/state/super_channel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_super_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_super_channel() directly.

    YANG Description: True if the media channel is a super channel which
contains multiple media channels within it. The contained
media channels should fall within the boundaries of the
super channel. The device should raise an error if a media
channel crosses a super channel boundary. When using super
channels, spectrum power targets should be defined in either
the:
- port-spectrum-power-profiles for the port which matches the
  source port of the media channel representing the super
  channel
- media channels that are contained within the super
  channel, but not on the super channel itself
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """super_channel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=False)""",
        })

    self.__super_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_super_channel(self):
    self.__super_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="super-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='boolean', is_config=False)


  def _get_super_channel_parent(self):
    """
    Getter method for super_channel_parent, mapped from YANG variable /wavelength_router/media_channels/channel/state/super_channel_parent (leafref)

    YANG Description: If the media channel is contained within a super channel this
would specify the index of the super channel parent
    """
    return self.__super_channel_parent
      
  def _set_super_channel_parent(self, v, load=False):
    """
    Setter method for super_channel_parent, mapped from YANG variable /wavelength_router/media_channels/channel/state/super_channel_parent (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_super_channel_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_super_channel_parent() directly.

    YANG Description: If the media channel is contained within a super channel this
would specify the index of the super channel parent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """super_channel_parent must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)""",
        })

    self.__super_channel_parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_super_channel_parent(self):
    self.__super_channel_parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="super-channel-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)


  def _get_ase_control_mode(self):
    """
    Getter method for ase_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_control_mode (identityref)

    YANG Description: Sets the ASE control mode for the media channel.
The control mode defines if and when ASE noise is injected
on the media channel
    """
    return self.__ase_control_mode
      
  def _set_ase_control_mode(self, v, load=False):
    """
    Setter method for ase_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_control_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_control_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_control_mode() directly.

    YANG Description: Sets the ASE control mode for the media channel.
The control mode defines if and when ASE noise is injected
on the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_control_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-wavelength-router:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)""",
        })

    self.__ase_control_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_control_mode(self):
    self.__ase_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_ENABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ASE_DISABLED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_ON_FAILURE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:AUTO_ASE_FAILURE_AND_RESTORE': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="ase-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)


  def _get_ase_injection_mode(self):
    """
    Getter method for ase_injection_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_mode (enumeration)

    YANG Description: When specified, defines the mode used to determine whether
ASE noise should be injected on the media channel.
    """
    return self.__ase_injection_mode
      
  def _set_ase_injection_mode(self, v, load=False):
    """
    Setter method for ase_injection_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_mode() directly.

    YANG Description: When specified, defines the mode used to determine whether
ASE noise should be injected on the media channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wavelength-router:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)""",
        })

    self.__ase_injection_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_mode(self):
    self.__ase_injection_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MODE_THRESHOLD': {}, 'MODE_DELTA': {}},), is_leaf=True, yang_name="ase-injection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)


  def _get_ase_injection_threshold(self):
    """
    Getter method for ase_injection_threshold, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_threshold (decimal64)

    YANG Description: Defines the optical power threshold value below which ASE
noise should be injected on the media channel. This or
ase-injection-delta is required if an ase-control-mode is
configured
    """
    return self.__ase_injection_threshold
      
  def _set_ase_injection_threshold(self, v, load=False):
    """
    Setter method for ase_injection_threshold, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_threshold() directly.

    YANG Description: Defines the optical power threshold value below which ASE
noise should be injected on the media channel. This or
ase-injection-delta is required if an ase-control-mode is
configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)""",
        })

    self.__ase_injection_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_threshold(self):
    self.__ase_injection_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)


  def _get_ase_injection_delta(self):
    """
    Getter method for ase_injection_delta, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_delta (decimal64)

    YANG Description: Defines the optical power loss from the configured spectrum
power profile, which would indicate that ASE noise should be
injected on the media channel. This or
ase-injection-threshold is required if an ase-control-mode
is configured
    """
    return self.__ase_injection_delta
      
  def _set_ase_injection_delta(self, v, load=False):
    """
    Setter method for ase_injection_delta, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_injection_delta (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_injection_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_injection_delta() directly.

    YANG Description: Defines the optical power loss from the configured spectrum
power profile, which would indicate that ASE noise should be
injected on the media channel. This or
ase-injection-threshold is required if an ase-control-mode
is configured
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_injection_delta must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)""",
        })

    self.__ase_injection_delta = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_injection_delta(self):
    self.__ase_injection_delta = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="ase-injection-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)


  def _get_attenuation_control_mode(self):
    """
    Getter method for attenuation_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/attenuation_control_mode (identityref)

    YANG Description: Sets the attenuation control mode for the media channel.
The control mode defines the behavior of how the attenuation
across a media channel is set
    """
    return self.__attenuation_control_mode
      
  def _set_attenuation_control_mode(self, v, load=False):
    """
    Setter method for attenuation_control_mode, mapped from YANG variable /wavelength_router/media_channels/channel/state/attenuation_control_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation_control_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation_control_mode() directly.

    YANG Description: Sets the attenuation control mode for the media channel.
The control mode defines the behavior of how the attenuation
across a media channel is set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation_control_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-wavelength-router:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)""",
        })

    self.__attenuation_control_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation_control_mode(self):
    self.__attenuation_control_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_FIXED_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}, 'oc-wave-router:ATTENUATION_DYNAMIC_LOSS_DAMPED': {'@module': 'openconfig-wavelength-router', '@namespace': 'http://openconfig.net/yang/wavelength-router'}},), is_leaf=True, yang_name="attenuation-control-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='identityref', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/oper_status (enumeration)

    YANG Description: Operational state of the media channel
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational state of the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wavelength-router:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'UP': {}, 'DOWN': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)


  def _get_ase_status(self):
    """
    Getter method for ase_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_status (enumeration)

    YANG Description: Status of injected ASE noise on the media channel
    """
    return self.__ase_status
      
  def _set_ase_status(self, v, load=False):
    """
    Setter method for ase_status, mapped from YANG variable /wavelength_router/media_channels/channel/state/ase_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_status() directly.

    YANG Description: Status of injected ASE noise on the media channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRESENT': {}, 'NOT_PRESENT': {}},), is_leaf=True, yang_name="ase-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_status must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wavelength-router:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRESENT': {}, 'NOT_PRESENT': {}},), is_leaf=True, yang_name="ase-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)""",
        })

    self.__ase_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_status(self):
    self.__ase_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PRESENT': {}, 'NOT_PRESENT': {}},), is_leaf=True, yang_name="ase-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='enumeration', is_config=False)

  index = __builtin__.property(_get_index)
  name = __builtin__.property(_get_name)
  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  admin_status = __builtin__.property(_get_admin_status)
  super_channel = __builtin__.property(_get_super_channel)
  super_channel_parent = __builtin__.property(_get_super_channel_parent)
  ase_control_mode = __builtin__.property(_get_ase_control_mode)
  ase_injection_mode = __builtin__.property(_get_ase_injection_mode)
  ase_injection_threshold = __builtin__.property(_get_ase_injection_threshold)
  ase_injection_delta = __builtin__.property(_get_ase_injection_delta)
  attenuation_control_mode = __builtin__.property(_get_attenuation_control_mode)
  oper_status = __builtin__.property(_get_oper_status)
  ase_status = __builtin__.property(_get_ase_status)


  _pyangbind_elements = OrderedDict([('index', index), ('name', name), ('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('admin_status', admin_status), ('super_channel', super_channel), ('super_channel_parent', super_channel_parent), ('ase_control_mode', ase_control_mode), ('ase_injection_mode', ase_injection_mode), ('ase_injection_threshold', ase_injection_threshold), ('ase_injection_delta', ase_injection_delta), ('attenuation_control_mode', attenuation_control_mode), ('oper_status', oper_status), ('ase_status', ase_status), ])


class yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/source/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the media channel source
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'source', 'config']

  def _get_port_name(self):
    """
    Getter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/source/config/port_name (leafref)

    YANG Description: Reference to the corresponding node port
    """
    return self.__port_name
      
  def _set_port_name(self, v, load=False):
    """
    Setter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/source/config/port_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_name() directly.

    YANG Description: Reference to the corresponding node port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_name(self):
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

  port_name = __builtin__.property(_get_port_name, _set_port_name)


  _pyangbind_elements = OrderedDict([('port_name', port_name), ])


class yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/source/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the media channel source
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_name',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'source', 'state']

  def _get_port_name(self):
    """
    Getter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/source/state/port_name (leafref)

    YANG Description: Reference to the corresponding node port
    """
    return self.__port_name
      
  def _set_port_name(self, v, load=False):
    """
    Setter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/source/state/port_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_name() directly.

    YANG Description: Reference to the corresponding node port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)""",
        })

    self.__port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_name(self):
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

  port_name = __builtin__.property(_get_port_name)


  _pyangbind_elements = OrderedDict([('port_name', port_name), ])


class yc_source_openconfig_wavelength_router__wavelength_router_media_channels_channel_source(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/source. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for media channel source
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'source'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'source']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/source/config (container)

    YANG Description: Configuration data for the media channel source
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/source/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the media channel source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/source/state (container)

    YANG Description: Operational state data for the media channel source
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/source/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the media channel source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_source_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/dest/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the media channel destination
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'dest', 'config']

  def _get_port_name(self):
    """
    Getter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/dest/config/port_name (leafref)

    YANG Description: Reference to the corresponding node port
    """
    return self.__port_name
      
  def _set_port_name(self, v, load=False):
    """
    Setter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/dest/config/port_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_name() directly.

    YANG Description: Reference to the corresponding node port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_name(self):
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

  port_name = __builtin__.property(_get_port_name, _set_port_name)


  _pyangbind_elements = OrderedDict([('port_name', port_name), ])


class yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/dest/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the media channel destination
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_name',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'dest', 'state']

  def _get_port_name(self):
    """
    Getter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/dest/state/port_name (leafref)

    YANG Description: Reference to the corresponding node port
    """
    return self.__port_name
      
  def _set_port_name(self, v, load=False):
    """
    Setter method for port_name, mapped from YANG variable /wavelength_router/media_channels/channel/dest/state/port_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_name() directly.

    YANG Description: Reference to the corresponding node port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)""",
        })

    self.__port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_name(self):
    self.__port_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

  port_name = __builtin__.property(_get_port_name)


  _pyangbind_elements = OrderedDict([('port_name', port_name), ])


class yc_dest_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/dest. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for media channel destination
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'dest'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'dest']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/dest/config (container)

    YANG Description: Configuration data for the media channel destination
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/dest/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the media channel destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/dest/state (container)

    YANG Description: Operational state data for the media channel destination
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/dest/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the media channel destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/spectrum-power-profile/distribution/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for target spectrum power
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__target_power',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'spectrum-power-profile', 'distribution', 'config']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified target spectrum power
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified target spectrum power
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_target_power(self):
    """
    Getter method for target_power, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/target_power (decimal64)

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    return self.__target_power
      
  def _set_target_power(self, v, load=False):
    """
    Setter method for target_power, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config/target_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_power() directly.

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)""",
        })

    self.__target_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_power(self):
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)

  lower_frequency = __builtin__.property(_get_lower_frequency, _set_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency, _set_upper_frequency)
  target_power = __builtin__.property(_get_target_power, _set_target_power)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('target_power', target_power), ])


class yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/spectrum-power-profile/distribution/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for target spectrum power
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__target_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'spectrum-power-profile', 'distribution', 'state']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified target spectrum power
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified target spectrum power
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_power(self):
    """
    Getter method for target_power, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/target_power (decimal64)

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    return self.__target_power
      
  def _set_target_power(self, v, load=False):
    """
    Setter method for target_power, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state/target_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_power() directly.

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)""",
        })

    self.__target_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_power(self):
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  target_power = __builtin__.property(_get_target_power)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('target_power', target_power), ])


class yc_distribution_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/spectrum-power-profile/distribution. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of tuples describing the target spectrum power
distribution
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__config','__state',)

  _yang_name = 'distribution'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'spectrum-power-profile', 'distribution']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/lower_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/lower_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/upper_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/upper_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config (container)

    YANG Description: Configuration data for target spectrum power
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state (container)

    YANG Description: Operational state data for target spectrum power
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  lower_frequency = __builtin__.property(_get_lower_frequency, _set_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency, _set_upper_frequency)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('config', config), ('state', state), ])


class yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel/spectrum-power-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of values describing
the target spectrum powers
  """
  __slots__ = ('_path_helper', '_extmethods', '__distribution',)

  _yang_name = 'spectrum-power-profile'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__distribution = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel', 'spectrum-power-profile']

  def _get_distribution(self):
    """
    Getter method for distribution, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution (list)

    YANG Description: List of tuples describing the target spectrum power
distribution
    """
    return self.__distribution
      
  def _set_distribution(self, v, load=False):
    """
    Setter method for distribution, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile/distribution (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distribution is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distribution() directly.

    YANG Description: List of tuples describing the target spectrum power
distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distribution must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)""",
        })

    self.__distribution = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distribution(self):
    self.__distribution = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

  distribution = __builtin__.property(_get_distribution, _set_distribution)


  _pyangbind_elements = OrderedDict([('distribution', distribution), ])


class yc_channel_openconfig_wavelength_router__wavelength_router_media_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of media channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state','__source','__dest','__spectrum_power_profile',)

  _yang_name = 'channel'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__source = YANGDynClass(base=yc_source_openconfig_wavelength_router__wavelength_router_media_channels_channel_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__dest = YANGDynClass(base=yc_dest_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest, is_container='container', yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__spectrum_power_profile = YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels', 'channel']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/index (leafref)

    YANG Description: Reference to index number of the media channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /wavelength_router/media_channels/channel/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to index number of the media channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/media_channels/channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_media_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/media_channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_media_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /wavelength_router/media_channels/channel/source (container)

    YANG Description: Top-level container for media channel source
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /wavelength_router/media_channels/channel/source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Top-level container for media channel source
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_openconfig_wavelength_router__wavelength_router_media_channels_channel_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_openconfig_wavelength_router__wavelength_router_media_channels_channel_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=yc_source_openconfig_wavelength_router__wavelength_router_media_channels_channel_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_dest(self):
    """
    Getter method for dest, mapped from YANG variable /wavelength_router/media_channels/channel/dest (container)

    YANG Description: Top-level container for media channel destination
    """
    return self.__dest
      
  def _set_dest(self, v, load=False):
    """
    Setter method for dest, mapped from YANG variable /wavelength_router/media_channels/channel/dest (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest() directly.

    YANG Description: Top-level container for media channel destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dest_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest, is_container='container', yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dest_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest, is_container='container', yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest(self):
    self.__dest = YANGDynClass(base=yc_dest_openconfig_wavelength_router__wavelength_router_media_channels_channel_dest, is_container='container', yang_name="dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_spectrum_power_profile(self):
    """
    Getter method for spectrum_power_profile, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile (container)

    YANG Description: Enclosing container for the list of values describing
the target spectrum powers
    """
    return self.__spectrum_power_profile
      
  def _set_spectrum_power_profile(self, v, load=False):
    """
    Setter method for spectrum_power_profile, mapped from YANG variable /wavelength_router/media_channels/channel/spectrum_power_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spectrum_power_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spectrum_power_profile() directly.

    YANG Description: Enclosing container for the list of values describing
the target spectrum powers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spectrum_power_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__spectrum_power_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spectrum_power_profile(self):
    self.__spectrum_power_profile = YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_media_channels_channel_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  source = __builtin__.property(_get_source, _set_source)
  dest = __builtin__.property(_get_dest, _set_dest)
  spectrum_power_profile = __builtin__.property(_get_spectrum_power_profile, _set_spectrum_power_profile)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ('source', source), ('dest', dest), ('spectrum_power_profile', spectrum_power_profile), ])


class yc_media_channels_openconfig_wavelength_router__wavelength_router_media_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/media-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for media channel list
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel',)

  _yang_name = 'media-channels'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_wavelength_router__wavelength_router_media_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'media-channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /wavelength_router/media_channels/channel (list)

    YANG Description: List of media channels
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /wavelength_router/media_channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of media channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_channel_openconfig_wavelength_router__wavelength_router_media_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_channel_openconfig_wavelength_router__wavelength_router_media_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_wavelength_router__wavelength_router_media_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = OrderedDict([('channel', channel), ])


class yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each port
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/config/name (leafref)

    YANG Description: Reference to system-supplied name of the wavelength-router
port component.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the wavelength-router
port component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each port spectrum profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/state/name (leafref)

    YANG Description: Reference to system-supplied name of the wavelength-router
port component.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the wavelength-router
port component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/spectrum-power-profile/distribution/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for target spectrum power
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__target_power',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'spectrum-power-profile', 'distribution', 'config']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified target spectrum power
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified target spectrum power
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_target_power(self):
    """
    Getter method for target_power, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/target_power (decimal64)

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    return self.__target_power
      
  def _set_target_power(self, v, load=False):
    """
    Setter method for target_power, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config/target_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_power() directly.

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)""",
        })

    self.__target_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_power(self):
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=True)

  lower_frequency = __builtin__.property(_get_lower_frequency, _set_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency, _set_upper_frequency)
  target_power = __builtin__.property(_get_target_power, _set_target_power)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('target_power', target_power), ])


class yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/spectrum-power-profile/distribution/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for target spectrum power
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__target_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'spectrum-power-profile', 'distribution', 'state']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified target spectrum power
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified target spectrum power
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_power(self):
    """
    Getter method for target_power, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/target_power (decimal64)

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    return self.__target_power
      
  def _set_target_power(self, v, load=False):
    """
    Setter method for target_power, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state/target_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_power() directly.

    YANG Description: Target average power to achieve within the specified
spectrum
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)""",
        })

    self.__target_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_power(self):
    self.__target_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='decimal64', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  target_power = __builtin__.property(_get_target_power)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('target_power', target_power), ])


class yc_distribution_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/spectrum-power-profile/distribution. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of tuples describing the target spectrum power
distribution
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__config','__state',)

  _yang_name = 'distribution'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'spectrum-power-profile', 'distribution']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/lower_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/lower_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/upper_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/upper_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config (container)

    YANG Description: Configuration data for target spectrum power
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state (container)

    YANG Description: Operational state data for target spectrum power
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for target spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  lower_frequency = __builtin__.property(_get_lower_frequency, _set_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency, _set_upper_frequency)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('config', config), ('state', state), ])


class yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port/spectrum-power-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of values describing
the target spectrum powers
  """
  __slots__ = ('_path_helper', '_extmethods', '__distribution',)

  _yang_name = 'spectrum-power-profile'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__distribution = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port', 'spectrum-power-profile']

  def _get_distribution(self):
    """
    Getter method for distribution, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution (list)

    YANG Description: List of tuples describing the target spectrum power
distribution
    """
    return self.__distribution
      
  def _set_distribution(self, v, load=False):
    """
    Setter method for distribution, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile/distribution (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distribution is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distribution() directly.

    YANG Description: List of tuples describing the target spectrum power
distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distribution must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)""",
        })

    self.__distribution = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distribution(self):
    self.__distribution = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_distribution_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile_distribution, yang_name="distribution", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="distribution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

  distribution = __builtin__.property(_get_distribution, _set_distribution)


  _pyangbind_elements = OrderedDict([('distribution', distribution), ])


class yc_port_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of ports, keyed by port name
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__spectrum_power_profile',)

  _yang_name = 'port'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__spectrum_power_profile = YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles', 'port']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/name (leafref)

    YANG Description: References the port name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the port name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/config (container)

    YANG Description: Configuration data for each port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/state (container)

    YANG Description: Operational state data for each port spectrum profile.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each port spectrum profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_spectrum_power_profile(self):
    """
    Getter method for spectrum_power_profile, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile (container)

    YANG Description: Enclosing container for the list of values describing
the target spectrum powers
    """
    return self.__spectrum_power_profile
      
  def _set_spectrum_power_profile(self, v, load=False):
    """
    Setter method for spectrum_power_profile, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port/spectrum_power_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spectrum_power_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spectrum_power_profile() directly.

    YANG Description: Enclosing container for the list of values describing
the target spectrum powers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spectrum_power_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__spectrum_power_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spectrum_power_profile(self):
    self.__spectrum_power_profile = YANGDynClass(base=yc_spectrum_power_profile_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port_spectrum_power_profile, is_container='container', yang_name="spectrum-power-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  spectrum_power_profile = __builtin__.property(_get_spectrum_power_profile, _set_spectrum_power_profile)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('spectrum_power_profile', spectrum_power_profile), ])


class yc_port_spectrum_power_profiles_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router/port-spectrum-power-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for wavelength-router port spectrum
power profiles
  """
  __slots__ = ('_path_helper', '_extmethods', '__port',)

  _yang_name = 'port-spectrum-power-profiles'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=YANGListType("name",yc_port_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router', 'port-spectrum-power-profiles']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port (list)

    YANG Description: List of ports, keyed by port name
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles/port (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: List of ports, keyed by port name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_port_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_port_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=YANGListType("name",yc_port_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='list', is_config=True)

  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('port', port), ])


class yc_wavelength_router_openconfig_wavelength_router__wavelength_router(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /wavelength-router. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for wavelength router device
  """
  __slots__ = ('_path_helper', '_extmethods', '__media_channels','__port_spectrum_power_profiles',)

  _yang_name = 'wavelength-router'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__media_channels = YANGDynClass(base=yc_media_channels_openconfig_wavelength_router__wavelength_router_media_channels, is_container='container', yang_name="media-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    self.__port_spectrum_power_profiles = YANGDynClass(base=yc_port_spectrum_power_profiles_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles, is_container='container', yang_name="port-spectrum-power-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['wavelength-router']

  def _get_media_channels(self):
    """
    Getter method for media_channels, mapped from YANG variable /wavelength_router/media_channels (container)

    YANG Description: Enclosing container for media channel list
    """
    return self.__media_channels
      
  def _set_media_channels(self, v, load=False):
    """
    Setter method for media_channels, mapped from YANG variable /wavelength_router/media_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_media_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_media_channels() directly.

    YANG Description: Enclosing container for media channel list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_media_channels_openconfig_wavelength_router__wavelength_router_media_channels, is_container='container', yang_name="media-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """media_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_media_channels_openconfig_wavelength_router__wavelength_router_media_channels, is_container='container', yang_name="media-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__media_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_media_channels(self):
    self.__media_channels = YANGDynClass(base=yc_media_channels_openconfig_wavelength_router__wavelength_router_media_channels, is_container='container', yang_name="media-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)


  def _get_port_spectrum_power_profiles(self):
    """
    Getter method for port_spectrum_power_profiles, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles (container)

    YANG Description: Enclosing container for wavelength-router port spectrum
power profiles
    """
    return self.__port_spectrum_power_profiles
      
  def _set_port_spectrum_power_profiles(self, v, load=False):
    """
    Setter method for port_spectrum_power_profiles, mapped from YANG variable /wavelength_router/port_spectrum_power_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_spectrum_power_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_spectrum_power_profiles() directly.

    YANG Description: Enclosing container for wavelength-router port spectrum
power profiles
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_spectrum_power_profiles_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles, is_container='container', yang_name="port-spectrum-power-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_spectrum_power_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_spectrum_power_profiles_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles, is_container='container', yang_name="port-spectrum-power-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__port_spectrum_power_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_spectrum_power_profiles(self):
    self.__port_spectrum_power_profiles = YANGDynClass(base=yc_port_spectrum_power_profiles_openconfig_wavelength_router__wavelength_router_port_spectrum_power_profiles, is_container='container', yang_name="port-spectrum-power-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  media_channels = __builtin__.property(_get_media_channels, _set_media_channels)
  port_spectrum_power_profiles = __builtin__.property(_get_port_spectrum_power_profiles, _set_port_spectrum_power_profiles)


  _pyangbind_elements = OrderedDict([('media_channels', media_channels), ('port_spectrum_power_profiles', port_spectrum_power_profiles), ])


class openconfig_wavelength_router(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /openconfig-wavelength-router. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for an optical transport line system node, or ROADM (incl. CDC
ROADMs, WSS, Dynamic Gain Equalizer/DGE).

Nodes are modeled as a configurable switching element with
ingress and egress ports, as well as a number of add/drop ports
that can be set up to direct portions of the optical spectrum
to the appropriate degrees.

In relation to configuring target spectrum powers, there
are two, non-overlapping, configuration possibilities that are
supported.
1. Non-noise loaded wavelength router:
  - The target spectrum powers are configured on each media
    channel.
2. Noise-loaded wavelength router:
  - The target spectrum power values will be configured as a
    target spectrum power profile over the full spectrum instead
    of individual media channels.
  """
  __slots__ = ('_path_helper', '_extmethods', '__wavelength_router',)

  _yang_name = 'openconfig-wavelength-router'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wavelength_router = YANGDynClass(base=yc_wavelength_router_openconfig_wavelength_router__wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_wavelength_router(self):
    """
    Getter method for wavelength_router, mapped from YANG variable /wavelength_router (container)

    YANG Description: Top-level container for wavelength router device
    """
    return self.__wavelength_router
      
  def _set_wavelength_router(self, v, load=False):
    """
    Setter method for wavelength_router, mapped from YANG variable /wavelength_router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wavelength_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wavelength_router() directly.

    YANG Description: Top-level container for wavelength router device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_wavelength_router_openconfig_wavelength_router__wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wavelength_router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_wavelength_router_openconfig_wavelength_router__wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__wavelength_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wavelength_router(self):
    self.__wavelength_router = YANGDynClass(base=yc_wavelength_router_openconfig_wavelength_router__wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  wavelength_router = __builtin__.property(_get_wavelength_router, _set_wavelength_router)


  _pyangbind_elements = OrderedDict([('wavelength_router', wavelength_router), ])


class openconfig_transport_line_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-common - based on the path /openconfig-transport-line-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines common data elements for OpenConfig data
models for optical transport line system elements, such as
amplifiers and ROADMs (wavelength routers).
  """
  _pyangbind_elements = {}

  

class openconfig_transport_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-types - based on the path /openconfig-transport-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general type definitions and identities
for optical transport models.
  """
  _pyangbind_elements = {}

  

class yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__monitor_port',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    self.__monitor_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/config/name (leafref)

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)


  def _get_monitor_port(self):
    """
    Getter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/config/monitor_port (leafref)

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    return self.__monitor_port
      
  def _set_monitor_port(self, v, load=False):
    """
    Setter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/config/monitor_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor_port() directly.

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__monitor_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor_port(self):
    self.__monitor_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  monitor_port = __builtin__.property(_get_monitor_port, _set_monitor_port)


  _pyangbind_elements = OrderedDict([('name', name), ('monitor_port', monitor_port), ])


class yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__monitor_port',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    self.__monitor_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/state/name (leafref)

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_monitor_port(self):
    """
    Getter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/state/monitor_port (leafref)

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    return self.__monitor_port
      
  def _set_monitor_port(self, v, load=False):
    """
    Setter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/state/monitor_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor_port() directly.

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__monitor_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor_port(self):
    self.__monitor_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)
  monitor_port = __builtin__.property(_get_monitor_port)


  _pyangbind_elements = OrderedDict([('name', name), ('monitor_port', monitor_port), ])


class yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for spectrum power
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor', 'channels', 'channel', 'state']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified spectrum power
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified spectrum power
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_power(self):
    """
    Getter method for power, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/power (decimal64)

    YANG Description: Average measured optical power over the specified spectrum
    """
    return self.__power
      
  def _set_power(self, v, load=False):
    """
    Setter method for power, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power() directly.

    YANG Description: Average measured optical power over the specified spectrum
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='decimal64', is_config=False)""",
        })

    self.__power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power(self):
    self.__power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='decimal64', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  power = __builtin__.property(_get_power)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('power', power), ])


class yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of tuples describing the spectrum power distribution
  """
  __slots__ = ('_path_helper', '_extmethods', '__lower_frequency','__upper_frequency','__state',)

  _yang_name = 'channel'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor', 'channels', 'channel']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/lower_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/lower_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/upper_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/upper_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state (container)

    YANG Description: Operational state data for spectrum power
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for spectrum power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ('state', state), ])


class yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of values describing
the spectrum power distribution
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel',)

  _yang_name = 'channels'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor', 'channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel (list)

    YANG Description: List of tuples describing the spectrum power distribution
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of tuples describing the spectrum power distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = OrderedDict([('channel', channel), ])


class yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of channel monitors, keyed by channel monitor name.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__channels',)

  _yang_name = 'channel-monitor'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    self.__channels = YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors', 'channel-monitor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/name (leafref)

    YANG Description: References the optical channel monitor name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the optical channel monitor name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /channel_monitors/channel_monitor/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /channel_monitors/channel_monitor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /channel_monitors/channel_monitor/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /channel_monitors/channel_monitor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)


  def _get_channels(self):
    """
    Getter method for channels, mapped from YANG variable /channel_monitors/channel_monitor/channels (container)

    YANG Description: Enclosing container for the list of values describing
the spectrum power distribution
    """
    return self.__channels
      
  def _set_channels(self, v, load=False):
    """
    Setter method for channels, mapped from YANG variable /channel_monitors/channel_monitor/channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channels() directly.

    YANG Description: Enclosing container for the list of values describing
the spectrum power distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channels(self):
    self.__channels = YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  channels = __builtin__.property(_get_channels, _set_channels)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('channels', channels), ])


class yc_channel_monitors_openconfig_channel_monitor__channel_monitors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for optical channel monitors
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel_monitor',)

  _yang_name = 'channel-monitors'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitor = YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['channel-monitors']

  def _get_channel_monitor(self):
    """
    Getter method for channel_monitor, mapped from YANG variable /channel_monitors/channel_monitor (list)

    YANG Description: List of channel monitors, keyed by channel monitor name.
    """
    return self.__channel_monitor
      
  def _set_channel_monitor(self, v, load=False):
    """
    Setter method for channel_monitor, mapped from YANG variable /channel_monitors/channel_monitor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitor() directly.

    YANG Description: List of channel monitors, keyed by channel monitor name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)""",
        })

    self.__channel_monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitor(self):
    self.__channel_monitor = YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

  channel_monitor = __builtin__.property(_get_channel_monitor, _set_channel_monitor)


  _pyangbind_elements = OrderedDict([('channel_monitor', channel_monitor), ])


class openconfig_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /openconfig-channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes operational state data for an optical
channel monitor (OCM) for optical transport line system
elements such as wavelength routers (ROADMs) and amplifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel_monitors',)

  _yang_name = 'openconfig-channel-monitor'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitors = YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_channel_monitors(self):
    """
    Getter method for channel_monitors, mapped from YANG variable /channel_monitors (container)

    YANG Description: Top-level container for optical channel monitors
    """
    return self.__channel_monitors
      
  def _set_channel_monitors(self, v, load=False):
    """
    Setter method for channel_monitors, mapped from YANG variable /channel_monitors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitors() directly.

    YANG Description: Top-level container for optical channel monitors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channel_monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitors(self):
    self.__channel_monitors = YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  channel_monitors = __builtin__.property(_get_channel_monitors, _set_channel_monitors)


  _pyangbind_elements = OrderedDict([('channel_monitors', channel_monitors), ])


class yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the amplifier
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__target_gain','__min_gain','__max_gain','__target_gain_tilt','__gain_range','__amp_mode','__target_output_power','__max_output_power','__enabled','__fiber_type_profile',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__min_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__max_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__max_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/name (string)

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/type (identityref)

    YANG Description: Type of the amplifier
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_target_gain(self):
    """
    Getter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain (decimal64)

    YANG Description: Positive gain applied by the amplifier. This is used
when the amp-mode is in CONSTANT_GAIN or DYNAMIC_GAIN
mode to set the target gain that the amplifier should
achieve.
    """
    return self.__target_gain
      
  def _set_target_gain(self, v, load=False):
    """
    Setter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain() directly.

    YANG Description: Positive gain applied by the amplifier. This is used
when the amp-mode is in CONSTANT_GAIN or DYNAMIC_GAIN
mode to set the target gain that the amplifier should
achieve.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain(self):
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_min_gain(self):
    """
    Getter method for min_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/min_gain (decimal64)

    YANG Description: The minimum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from dropping below a desired threshold.
If left empty, the platform will apply a minimum gain based
on hardware specifications.
    """
    return self.__min_gain
      
  def _set_min_gain(self, v, load=False):
    """
    Setter method for min_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/min_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_gain() directly.

    YANG Description: The minimum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from dropping below a desired threshold.
If left empty, the platform will apply a minimum gain based
on hardware specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__min_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_gain(self):
    self.__min_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_max_gain(self):
    """
    Getter method for max_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/max_gain (decimal64)

    YANG Description: The maximum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from exceeding a desired threshold. If
left empty, the platform will apply a maximum gain based on
hardware specifications.
    """
    return self.__max_gain
      
  def _set_max_gain(self, v, load=False):
    """
    Setter method for max_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/max_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_gain() directly.

    YANG Description: The maximum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from exceeding a desired threshold. If
left empty, the platform will apply a maximum gain based on
hardware specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__max_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_gain(self):
    self.__max_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_target_gain_tilt(self):
    """
    Getter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain_tilt (decimal64)

    YANG Description: Gain tilt control
    """
    return self.__target_gain_tilt
      
  def _set_target_gain_tilt(self, v, load=False):
    """
    Setter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain_tilt (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain_tilt() directly.

    YANG Description: Gain tilt control
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain_tilt must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain_tilt(self):
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_gain_range(self):
    """
    Getter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/gain_range (identityref)

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    return self.__gain_range
      
  def _set_gain_range(self, v, load=False):
    """
    Setter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/gain_range (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gain_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gain_range() directly.

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gain_range must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__gain_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gain_range(self):
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_amp_mode(self):
    """
    Getter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/amp_mode (identityref)

    YANG Description: The operating mode of the amplifier
    """
    return self.__amp_mode
      
  def _set_amp_mode(self, v, load=False):
    """
    Setter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/amp_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amp_mode() directly.

    YANG Description: The operating mode of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amp_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__amp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amp_mode(self):
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_output_power (decimal64)

    YANG Description: Output optical power of the amplifier.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Output optical power of the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_max_output_power(self):
    """
    Getter method for max_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/max_output_power (decimal64)

    YANG Description: The maximum optical output power of the amplifier. This
may be used to prevent the output power from exceeding a
desired threshold.
    """
    return self.__max_output_power
      
  def _set_max_output_power(self, v, load=False):
    """
    Setter method for max_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/max_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_output_power() directly.

    YANG Description: The maximum optical output power of the amplifier. This
may be used to prevent the output power from exceeding a
desired threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__max_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_output_power(self):
    self.__max_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/enabled (boolean)

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)


  def _get_fiber_type_profile(self):
    """
    Getter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/fiber_type_profile (identityref)

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    return self.__fiber_type_profile
      
  def _set_fiber_type_profile(self, v, load=False):
    """
    Setter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/fiber_type_profile (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type_profile() directly.

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type_profile must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__fiber_type_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type_profile(self):
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  target_gain = __builtin__.property(_get_target_gain, _set_target_gain)
  min_gain = __builtin__.property(_get_min_gain, _set_min_gain)
  max_gain = __builtin__.property(_get_max_gain, _set_max_gain)
  target_gain_tilt = __builtin__.property(_get_target_gain_tilt, _set_target_gain_tilt)
  gain_range = __builtin__.property(_get_gain_range, _set_gain_range)
  amp_mode = __builtin__.property(_get_amp_mode, _set_amp_mode)
  target_output_power = __builtin__.property(_get_target_output_power, _set_target_output_power)
  max_output_power = __builtin__.property(_get_max_output_power, _set_max_output_power)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  fiber_type_profile = __builtin__.property(_get_fiber_type_profile, _set_fiber_type_profile)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('target_gain', target_gain), ('min_gain', min_gain), ('max_gain', max_gain), ('target_gain_tilt', target_gain_tilt), ('gain_range', gain_range), ('amp_mode', amp_mode), ('target_output_power', target_output_power), ('max_output_power', max_output_power), ('enabled', enabled), ('fiber_type_profile', fiber_type_profile), ])


class yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/actual-gain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'actual-gain'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'actual-gain']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/actual-gain-tilt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'actual-gain-tilt'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'actual-gain-tilt']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power-total'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'input-power-total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-c-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power-c-band'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'input-power-c-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-l-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power-l-band'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'input-power-l-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power-total'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'output-power-total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-c-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power-c-band'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'output-power-c-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-l-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power-l-band'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'output-power-l-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'laser-bias-current'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/optical-return-loss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-return-loss'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state', 'optical-return-loss']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the amplifier
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__target_gain','__min_gain','__max_gain','__target_gain_tilt','__gain_range','__amp_mode','__target_output_power','__max_output_power','__enabled','__fiber_type_profile','__component','__ingress_port','__egress_port','__actual_gain','__actual_gain_tilt','__input_power_total','__input_power_c_band','__input_power_l_band','__output_power_total','__output_power_c_band','__output_power_l_band','__laser_bias_current','__optical_return_loss',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__ingress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__egress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__actual_gain = YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__actual_gain_tilt = YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__input_power_total = YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__input_power_c_band = YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__input_power_l_band = YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__output_power_c_band = YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__output_power_l_band = YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/name (string)

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/type (identityref)

    YANG Description: Type of the amplifier
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:EDFA': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FORWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:BACKWARD_RAMAN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HYBRID': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_target_gain(self):
    """
    Getter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain (decimal64)

    YANG Description: Positive gain applied by the amplifier. This is used
when the amp-mode is in CONSTANT_GAIN or DYNAMIC_GAIN
mode to set the target gain that the amplifier should
achieve.
    """
    return self.__target_gain
      
  def _set_target_gain(self, v, load=False):
    """
    Setter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain() directly.

    YANG Description: Positive gain applied by the amplifier. This is used
when the amp-mode is in CONSTANT_GAIN or DYNAMIC_GAIN
mode to set the target gain that the amplifier should
achieve.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain(self):
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_gain(self):
    """
    Getter method for min_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/min_gain (decimal64)

    YANG Description: The minimum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from dropping below a desired threshold.
If left empty, the platform will apply a minimum gain based
on hardware specifications.
    """
    return self.__min_gain
      
  def _set_min_gain(self, v, load=False):
    """
    Setter method for min_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/min_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_gain() directly.

    YANG Description: The minimum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from dropping below a desired threshold.
If left empty, the platform will apply a minimum gain based
on hardware specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_gain(self):
    self.__min_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_gain(self):
    """
    Getter method for max_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/max_gain (decimal64)

    YANG Description: The maximum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from exceeding a desired threshold. If
left empty, the platform will apply a maximum gain based on
hardware specifications.
    """
    return self.__max_gain
      
  def _set_max_gain(self, v, load=False):
    """
    Setter method for max_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/max_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_gain() directly.

    YANG Description: The maximum allowed gain of the amplifier. This is used
when the amp-mode is in CONSTANT_POWER or DYNAMIC_GAIN mode
to prevent the gain from exceeding a desired threshold. If
left empty, the platform will apply a maximum gain based on
hardware specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_gain(self):
    self.__max_gain = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_target_gain_tilt(self):
    """
    Getter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain_tilt (decimal64)

    YANG Description: Gain tilt control
    """
    return self.__target_gain_tilt
      
  def _set_target_gain_tilt(self, v, load=False):
    """
    Setter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain_tilt (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain_tilt() directly.

    YANG Description: Gain tilt control
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain_tilt must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain_tilt(self):
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_gain_range(self):
    """
    Getter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/gain_range (identityref)

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    return self.__gain_range
      
  def _set_gain_range(self, v, load=False):
    """
    Setter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/gain_range (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gain_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gain_range() directly.

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gain_range must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__gain_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gain_range(self):
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LOW_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:MID_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:HIGH_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:FIXED_GAIN_RANGE': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_amp_mode(self):
    """
    Getter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/amp_mode (identityref)

    YANG Description: The operating mode of the amplifier
    """
    return self.__amp_mode
      
  def _set_amp_mode(self, v, load=False):
    """
    Setter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/amp_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amp_mode() directly.

    YANG Description: The operating mode of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amp_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__amp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amp_mode(self):
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_POWER': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:CONSTANT_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DYNAMIC_GAIN': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_output_power (decimal64)

    YANG Description: Output optical power of the amplifier.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Output optical power of the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_output_power(self):
    """
    Getter method for max_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/max_output_power (decimal64)

    YANG Description: The maximum optical output power of the amplifier. This
may be used to prevent the output power from exceeding a
desired threshold.
    """
    return self.__max_output_power
      
  def _set_max_output_power(self, v, load=False):
    """
    Setter method for max_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/max_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_output_power() directly.

    YANG Description: The maximum optical output power of the amplifier. This
may be used to prevent the output power from exceeding a
desired threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_output_power(self):
    self.__max_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/enabled (boolean)

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)


  def _get_fiber_type_profile(self):
    """
    Getter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/fiber_type_profile (identityref)

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    return self.__fiber_type_profile
      
  def _set_fiber_type_profile(self, v, load=False):
    """
    Setter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/fiber_type_profile (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type_profile() directly.

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type_profile must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__fiber_type_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type_profile(self):
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:DSF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:LEAF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:SSMF': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWC': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}, 'oc-opt-amp:TWRS': {'@module': 'openconfig-optical-amplifier', '@namespace': 'http://openconfig.net/yang/optical-amplfier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/component (leafref)

    YANG Description: Reference to the system-supplied physical component that
the amplifier gain block is contained within. Multiple
amplifier gain blocks may be contained within the same
physical component.
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/component (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: Reference to the system-supplied physical component that
the amplifier gain block is contained within. Multiple
amplifier gain blocks may be contained within the same
physical component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_ingress_port(self):
    """
    Getter method for ingress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/ingress_port (leafref)

    YANG Description: Reference to system-supplied name of the amplifier ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    return self.__ingress_port
      
  def _set_ingress_port(self, v, load=False):
    """
    Setter method for ingress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/ingress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_port() directly.

    YANG Description: Reference to system-supplied name of the amplifier ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__ingress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_port(self):
    self.__ingress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_egress_port(self):
    """
    Getter method for egress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/egress_port (leafref)

    YANG Description: Reference to system-supplied name of the amplifier egress
port. This leaf is only valid for ports of type EGRESS.
    """
    return self.__egress_port
      
  def _set_egress_port(self, v, load=False):
    """
    Setter method for egress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/egress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_port() directly.

    YANG Description: Reference to system-supplied name of the amplifier egress
port. This leaf is only valid for ports of type EGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__egress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_port(self):
    self.__egress_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_actual_gain(self):
    """
    Getter method for actual_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain (container)

    YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__actual_gain
      
  def _set_actual_gain(self, v, load=False):
    """
    Setter method for actual_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actual_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actual_gain() directly.

    YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actual_gain must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__actual_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actual_gain(self):
    self.__actual_gain = YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_actual_gain_tilt(self):
    """
    Getter method for actual_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt (container)

    YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__actual_gain_tilt
      
  def _set_actual_gain_tilt(self, v, load=False):
    """
    Setter method for actual_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actual_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actual_gain_tilt() directly.

    YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actual_gain_tilt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__actual_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actual_gain_tilt(self):
    self.__actual_gain_tilt = YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_total(self):
    """
    Getter method for input_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total (container)

    YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_total
      
  def _set_input_power_total(self, v, load=False):
    """
    Setter method for input_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_total() directly.

    YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_total(self):
    self.__input_power_total = YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_c_band(self):
    """
    Getter method for input_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band (container)

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_c_band
      
  def _set_input_power_c_band(self, v, load=False):
    """
    Setter method for input_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_c_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_c_band() directly.

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_c_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_c_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_c_band(self):
    self.__input_power_c_band = YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_l_band(self):
    """
    Getter method for input_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band (container)

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_l_band
      
  def _set_input_power_l_band(self, v, load=False):
    """
    Setter method for input_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_l_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_l_band() directly.

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_l_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_l_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_l_band(self):
    self.__input_power_l_band = YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_total(self):
    """
    Getter method for output_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total (container)

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_total
      
  def _set_output_power_total(self, v, load=False):
    """
    Setter method for output_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_total() directly.

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_total(self):
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_c_band(self):
    """
    Getter method for output_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band (container)

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_c_band
      
  def _set_output_power_c_band(self, v, load=False):
    """
    Setter method for output_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_c_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_c_band() directly.

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_c_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_c_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_c_band(self):
    self.__output_power_c_band = YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_l_band(self):
    """
    Getter method for output_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band (container)

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_l_band
      
  def _set_output_power_l_band(self, v, load=False):
    """
    Setter method for output_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_l_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_l_band() directly.

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_l_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_l_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_l_band(self):
    self.__output_power_l_band = YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_optical_return_loss(self):
    """
    Getter method for optical_return_loss, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss (container)

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
    """
    return self.__optical_return_loss
      
  def _set_optical_return_loss(self, v, load=False):
    """
    Setter method for optical_return_loss, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_return_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_return_loss() directly.

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_return_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__optical_return_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_return_loss(self):
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  target_gain = __builtin__.property(_get_target_gain)
  min_gain = __builtin__.property(_get_min_gain)
  max_gain = __builtin__.property(_get_max_gain)
  target_gain_tilt = __builtin__.property(_get_target_gain_tilt)
  gain_range = __builtin__.property(_get_gain_range)
  amp_mode = __builtin__.property(_get_amp_mode)
  target_output_power = __builtin__.property(_get_target_output_power)
  max_output_power = __builtin__.property(_get_max_output_power)
  enabled = __builtin__.property(_get_enabled)
  fiber_type_profile = __builtin__.property(_get_fiber_type_profile)
  component = __builtin__.property(_get_component)
  ingress_port = __builtin__.property(_get_ingress_port)
  egress_port = __builtin__.property(_get_egress_port)
  actual_gain = __builtin__.property(_get_actual_gain)
  actual_gain_tilt = __builtin__.property(_get_actual_gain_tilt)
  input_power_total = __builtin__.property(_get_input_power_total)
  input_power_c_band = __builtin__.property(_get_input_power_c_band)
  input_power_l_band = __builtin__.property(_get_input_power_l_band)
  output_power_total = __builtin__.property(_get_output_power_total)
  output_power_c_band = __builtin__.property(_get_output_power_c_band)
  output_power_l_band = __builtin__.property(_get_output_power_l_band)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  optical_return_loss = __builtin__.property(_get_optical_return_loss)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('target_gain', target_gain), ('min_gain', min_gain), ('max_gain', max_gain), ('target_gain_tilt', target_gain_tilt), ('gain_range', gain_range), ('amp_mode', amp_mode), ('target_output_power', target_output_power), ('max_output_power', max_output_power), ('enabled', enabled), ('fiber_type_profile', fiber_type_profile), ('component', component), ('ingress_port', ingress_port), ('egress_port', egress_port), ('actual_gain', actual_gain), ('actual_gain_tilt', actual_gain_tilt), ('input_power_total', input_power_total), ('input_power_c_band', input_power_c_band), ('input_power_l_band', input_power_l_band), ('output_power_total', output_power_total), ('output_power_c_band', output_power_c_band), ('output_power_l_band', output_power_l_band), ('laser_bias_current', laser_bias_current), ('optical_return_loss', optical_return_loss), ])


class yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of optical amplifiers present in the device
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'amplifier'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers', 'amplifier']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/name (leafref)

    YANG Description: Reference to the name of the amplifier
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the amplifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config (container)

    YANG Description: Configuration data for the amplifier
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state (container)

    YANG Description: Operational state data for the amplifier
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of amplifiers
  """
  __slots__ = ('_path_helper', '_extmethods', '__amplifier',)

  _yang_name = 'amplifiers'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__amplifier = YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'amplifiers']

  def _get_amplifier(self):
    """
    Getter method for amplifier, mapped from YANG variable /optical_amplifier/amplifiers/amplifier (list)

    YANG Description: List of optical amplifiers present in the device
    """
    return self.__amplifier
      
  def _set_amplifier(self, v, load=False):
    """
    Setter method for amplifier, mapped from YANG variable /optical_amplifier/amplifiers/amplifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amplifier() directly.

    YANG Description: List of optical amplifiers present in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amplifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)""",
        })

    self.__amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amplifier(self):
    self.__amplifier = YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

  amplifier = __builtin__.property(_get_amplifier, _set_amplifier)


  _pyangbind_elements = OrderedDict([('amplifier', amplifier), ])


class yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for OSCs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel', 'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config/interface (oc-if:base-interface-ref)

    YANG Description: Reference to an OSC interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to an OSC interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/input-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel', 'state', 'input-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/output-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel', 'state', 'output-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'laser-bias-current'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel', 'state', 'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for OSCs
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__input_power','__output_power','__laser_bias_current','__output_frequency',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__output_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-opt-types:frequency-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to an OSC interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to an OSC interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power (container)

    YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power (container)

    YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_frequency(self):
    """
    Getter method for output_frequency, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_frequency (oc-opt-types:frequency-type)

    YANG Description: The frequency in MHz of the individual physical channel
(e.g. ITU C50 - 195.0THz and would be reported as
195,000,000 MHz in this model). This attribute is not
configurable on most client ports.
    """
    return self.__output_frequency
      
  def _set_output_frequency(self, v, load=False):
    """
    Setter method for output_frequency, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_frequency() directly.

    YANG Description: The frequency in MHz of the individual physical channel
(e.g. ITU C50 - 195.0THz and would be reported as
195,000,000 MHz in this model). This attribute is not
configurable on most client ports.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__output_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_frequency(self):
    self.__output_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-opt-types:frequency-type', is_config=False)

  interface = __builtin__.property(_get_interface)
  input_power = __builtin__.property(_get_input_power)
  output_power = __builtin__.property(_get_output_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  output_frequency = __builtin__.property(_get_output_frequency)


  _pyangbind_elements = OrderedDict([('interface', interface), ('input_power', input_power), ('output_power', output_power), ('laser_bias_current', laser_bias_current), ('output_frequency', output_frequency), ])


class yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of supervisory channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__config','__state',)

  _yang_name = 'supervisory-channel'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels', 'supervisory-channel']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/interface (leafref)

    YANG Description: Reference to the interface of the supervisory channel
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to the interface of the supervisory channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config (container)

    YANG Description: Configuration data for OSCs
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for OSCs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state (container)

    YANG Description: Operational state data for OSCs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for OSCs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('interface', interface), ('config', config), ('state', state), ])


class yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of supervisory channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__supervisory_channel',)

  _yang_name = 'supervisory-channels'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supervisory_channel = YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier', 'supervisory-channels']

  def _get_supervisory_channel(self):
    """
    Getter method for supervisory_channel, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel (list)

    YANG Description: List of supervisory channels
    """
    return self.__supervisory_channel
      
  def _set_supervisory_channel(self, v, load=False):
    """
    Setter method for supervisory_channel, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supervisory_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supervisory_channel() directly.

    YANG Description: List of supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supervisory_channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)""",
        })

    self.__supervisory_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supervisory_channel(self):
    self.__supervisory_channel = YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

  supervisory_channel = __builtin__.property(_get_supervisory_channel, _set_supervisory_channel)


  _pyangbind_elements = OrderedDict([('supervisory_channel', supervisory_channel), ])


class yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for amplifiers and supervisory channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__amplifiers','__supervisory_channels',)

  _yang_name = 'optical-amplifier'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__amplifiers = YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__supervisory_channels = YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['optical-amplifier']

  def _get_amplifiers(self):
    """
    Getter method for amplifiers, mapped from YANG variable /optical_amplifier/amplifiers (container)

    YANG Description: Enclosing container for list of amplifiers
    """
    return self.__amplifiers
      
  def _set_amplifiers(self, v, load=False):
    """
    Setter method for amplifiers, mapped from YANG variable /optical_amplifier/amplifiers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amplifiers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amplifiers() directly.

    YANG Description: Enclosing container for list of amplifiers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amplifiers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__amplifiers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amplifiers(self):
    self.__amplifiers = YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_supervisory_channels(self):
    """
    Getter method for supervisory_channels, mapped from YANG variable /optical_amplifier/supervisory_channels (container)

    YANG Description: Enclosing container for list of supervisory channels
    """
    return self.__supervisory_channels
      
  def _set_supervisory_channels(self, v, load=False):
    """
    Setter method for supervisory_channels, mapped from YANG variable /optical_amplifier/supervisory_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supervisory_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supervisory_channels() directly.

    YANG Description: Enclosing container for list of supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supervisory_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__supervisory_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supervisory_channels(self):
    self.__supervisory_channels = YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  amplifiers = __builtin__.property(_get_amplifiers, _set_amplifiers)
  supervisory_channels = __builtin__.property(_get_supervisory_channels, _set_supervisory_channels)


  _pyangbind_elements = OrderedDict([('amplifiers', amplifiers), ('supervisory_channels', supervisory_channels), ])


class openconfig_optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /openconfig-optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical amplifiers, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_amplifier',)

  _yang_name = 'openconfig-optical-amplifier'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_amplifier = YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_amplifier(self):
    """
    Getter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    return self.__optical_amplifier
      
  def _set_optical_amplifier(self, v, load=False):
    """
    Setter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_amplifier() directly.

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_amplifier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__optical_amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_amplifier(self):
    self.__optical_amplifier = YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  optical_amplifier = __builtin__.property(_get_optical_amplifier, _set_optical_amplifier)


  _pyangbind_elements = OrderedDict([('optical_amplifier', optical_amplifier), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for an automatic protection
switch module
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revertive','__wait_to_restore_time','__hold_off_time','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__relative_switch_threshold','__relative_switch_threshold_offset','__force_to_port',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_wait_to_restore_time(self):
    """
    Getter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    return self.__wait_to_restore_time
      
  def _set_wait_to_restore_time(self, v, load=False):
    """
    Setter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_to_restore_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_to_restore_time() directly.

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_to_restore_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__wait_to_restore_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_to_restore_time(self):
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_hold_off_time(self):
    """
    Getter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    return self.__hold_off_time
      
  def _set_hold_off_time(self, v, load=False):
    """
    Setter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_off_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_off_time() directly.

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_off_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__hold_off_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_off_time(self):
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold(self):
    """
    Getter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    return self.__relative_switch_threshold
      
  def _set_relative_switch_threshold(self, v, load=False):
    """
    Setter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold() directly.

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold(self):
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold_offset(self):
    """
    Getter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    return self.__relative_switch_threshold_offset
      
  def _set_relative_switch_threshold_offset(self, v, load=False):
    """
    Setter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold_offset() directly.

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold_offset must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold_offset(self):
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_force_to_port(self):
    """
    Getter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    return self.__force_to_port
      
  def _set_force_to_port(self, v, load=False):
    """
    Setter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_force_to_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_force_to_port() directly.

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """force_to_port must be of a type compatible with enumeration""",
          'defined-type': "openconfig-transport-line-protection:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)""",
        })

    self.__force_to_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_force_to_port(self):
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  wait_to_restore_time = __builtin__.property(_get_wait_to_restore_time, _set_wait_to_restore_time)
  hold_off_time = __builtin__.property(_get_hold_off_time, _set_hold_off_time)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold, _set_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis, _set_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold, _set_secondary_switch_threshold)
  relative_switch_threshold = __builtin__.property(_get_relative_switch_threshold, _set_relative_switch_threshold)
  relative_switch_threshold_offset = __builtin__.property(_get_relative_switch_threshold_offset, _set_relative_switch_threshold_offset)
  force_to_port = __builtin__.property(_get_force_to_port, _set_force_to_port)


  _pyangbind_elements = OrderedDict([('name', name), ('revertive', revertive), ('wait_to_restore_time', wait_to_restore_time), ('hold_off_time', hold_off_time), ('primary_switch_threshold', primary_switch_threshold), ('primary_switch_hysteresis', primary_switch_hysteresis), ('secondary_switch_threshold', secondary_switch_threshold), ('relative_switch_threshold', relative_switch_threshold), ('relative_switch_threshold_offset', relative_switch_threshold_offset), ('force_to_port', force_to_port), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for an automatic protection
switch module
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revertive','__wait_to_restore_time','__hold_off_time','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__relative_switch_threshold','__relative_switch_threshold_offset','__force_to_port','__active_path',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=False)
    self.__active_path = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/state/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/state/revertive (boolean)

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/state/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_wait_to_restore_time(self):
    """
    Getter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/state/wait_to_restore_time (uint32)

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    return self.__wait_to_restore_time
      
  def _set_wait_to_restore_time(self, v, load=False):
    """
    Setter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/state/wait_to_restore_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_to_restore_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_to_restore_time() directly.

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_to_restore_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)""",
        })

    self.__wait_to_restore_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_to_restore_time(self):
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)


  def _get_hold_off_time(self):
    """
    Getter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/state/hold_off_time (uint32)

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    return self.__hold_off_time
      
  def _set_hold_off_time(self, v, load=False):
    """
    Setter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/state/hold_off_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_off_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_off_time() directly.

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_off_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)""",
        })

    self.__hold_off_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_off_time(self):
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=False)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_relative_switch_threshold(self):
    """
    Getter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/relative_switch_threshold (decimal64)

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    return self.__relative_switch_threshold
      
  def _set_relative_switch_threshold(self, v, load=False):
    """
    Setter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/relative_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold() directly.

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__relative_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold(self):
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_relative_switch_threshold_offset(self):
    """
    Getter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/state/relative_switch_threshold_offset (decimal64)

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    return self.__relative_switch_threshold_offset
      
  def _set_relative_switch_threshold_offset(self, v, load=False):
    """
    Setter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/state/relative_switch_threshold_offset (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold_offset() directly.

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold_offset must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__relative_switch_threshold_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold_offset(self):
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_force_to_port(self):
    """
    Getter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/state/force_to_port (enumeration)

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    return self.__force_to_port
      
  def _set_force_to_port(self, v, load=False):
    """
    Setter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/state/force_to_port (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_force_to_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_force_to_port() directly.

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """force_to_port must be of a type compatible with enumeration""",
          'defined-type': "openconfig-transport-line-protection:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=False)""",
        })

    self.__force_to_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_force_to_port(self):
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=False)


  def _get_active_path(self):
    """
    Getter method for active_path, mapped from YANG variable /aps/aps_modules/aps_module/state/active_path (identityref)

    YANG Description: Indicates which line path on the protection switch is
currently the active path connected to the common port
    """
    return self.__active_path
      
  def _set_active_path(self, v, load=False):
    """
    Setter method for active_path, mapped from YANG variable /aps/aps_modules/aps_module/state/active_path (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_path() directly.

    YANG Description: Indicates which line path on the protection switch is
currently the active path connected to the common port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_path must be of a type compatible with identityref""",
          'defined-type': "openconfig-transport-line-protection:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)""",
        })

    self.__active_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_path(self):
    self.__active_path = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:PRIMARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}, 'oc-line-protect:SECONDARY': {'@module': 'openconfig-transport-line-protection', '@namespace': 'http://openconfig.net/yang/optical-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)

  name = __builtin__.property(_get_name)
  revertive = __builtin__.property(_get_revertive)
  wait_to_restore_time = __builtin__.property(_get_wait_to_restore_time)
  hold_off_time = __builtin__.property(_get_hold_off_time)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold)
  relative_switch_threshold = __builtin__.property(_get_relative_switch_threshold)
  relative_switch_threshold_offset = __builtin__.property(_get_relative_switch_threshold_offset)
  force_to_port = __builtin__.property(_get_force_to_port)
  active_path = __builtin__.property(_get_active_path)


  _pyangbind_elements = OrderedDict([('name', name), ('revertive', revertive), ('wait_to_restore_time', wait_to_restore_time), ('hold_off_time', hold_off_time), ('primary_switch_threshold', primary_switch_threshold), ('primary_switch_hysteresis', primary_switch_hysteresis), ('secondary_switch_threshold', secondary_switch_threshold), ('relative_switch_threshold', relative_switch_threshold), ('relative_switch_threshold_offset', relative_switch_threshold_offset), ('force_to_port', force_to_port), ('active_path', active_path), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line primary input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-in', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-in', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line primary input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-in', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line primary
input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'line-primary-in'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config (container)

    YANG Description: Configuration data for the line primary input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line primary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state (container)

    YANG Description: State data for the line primary input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line primary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line primary output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-out', 'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-out', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line primary output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-out', 'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line primary
output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'line-primary-out'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-primary-out']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config (container)

    YANG Description: Configuration data for the line primary output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line primary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state (container)

    YANG Description: State data for the line primary output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line primary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line secondary input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-in', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-in', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line secondary input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-in', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line secondary
input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'line-secondary-in'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config (container)

    YANG Description: Configuration data for the line secondary input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line secondary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state (container)

    YANG Description: State data for the line secondary input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line secondary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line secondary output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-out', 'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-out', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line secondary output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-out', 'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line secondary
output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'line-secondary-out'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'line-secondary-out']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config (container)

    YANG Description: Configuration data for the line secondary output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line secondary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state (container)

    YANG Description: State data for the line secondary output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line secondary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line common input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-in', 'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-in', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line common input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-in', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line common
input port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'common-in'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config (container)

    YANG Description: Configuration data for the line common input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line common input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state (container)

    YANG Description: State data for the line common input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line common input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line common output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-output', 'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ])


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'optical-power'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-output', 'state', 'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line common output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-output', 'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = OrderedDict([('target_attenuation', target_attenuation), ('attenuation', attenuation), ('optical_power', optical_power), ])


class yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line common
output port
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'common-output'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports', 'common-output']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config (container)

    YANG Description: Configuration data for the line common output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line common output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state (container)

    YANG Description: State data for the line common output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line common output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level grouping for automatic protection switch ports
  """
  __slots__ = ('_path_helper', '_extmethods', '__line_primary_in','__line_primary_out','__line_secondary_in','__line_secondary_out','__common_in','__common_output',)

  _yang_name = 'ports'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__line_primary_in = YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_primary_out = YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_secondary_in = YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_secondary_out = YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__common_in = YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__common_output = YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'ports']

  def _get_line_primary_in(self):
    """
    Getter method for line_primary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in (container)

    YANG Description: Container for information related to the line primary
input port
    """
    return self.__line_primary_in
      
  def _set_line_primary_in(self, v, load=False):
    """
    Setter method for line_primary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_primary_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_primary_in() directly.

    YANG Description: Container for information related to the line primary
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_primary_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_primary_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_primary_in(self):
    self.__line_primary_in = YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_primary_out(self):
    """
    Getter method for line_primary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out (container)

    YANG Description: Container for information related to the line primary
output port
    """
    return self.__line_primary_out
      
  def _set_line_primary_out(self, v, load=False):
    """
    Setter method for line_primary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_primary_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_primary_out() directly.

    YANG Description: Container for information related to the line primary
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_primary_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_primary_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_primary_out(self):
    self.__line_primary_out = YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_secondary_in(self):
    """
    Getter method for line_secondary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in (container)

    YANG Description: Container for information related to the line secondary
input port
    """
    return self.__line_secondary_in
      
  def _set_line_secondary_in(self, v, load=False):
    """
    Setter method for line_secondary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_secondary_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_secondary_in() directly.

    YANG Description: Container for information related to the line secondary
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_secondary_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_secondary_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_secondary_in(self):
    self.__line_secondary_in = YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_secondary_out(self):
    """
    Getter method for line_secondary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out (container)

    YANG Description: Container for information related to the line secondary
output port
    """
    return self.__line_secondary_out
      
  def _set_line_secondary_out(self, v, load=False):
    """
    Setter method for line_secondary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_secondary_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_secondary_out() directly.

    YANG Description: Container for information related to the line secondary
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_secondary_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_secondary_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_secondary_out(self):
    self.__line_secondary_out = YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_common_in(self):
    """
    Getter method for common_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in (container)

    YANG Description: Container for information related to the line common
input port
    """
    return self.__common_in
      
  def _set_common_in(self, v, load=False):
    """
    Setter method for common_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_in() directly.

    YANG Description: Container for information related to the line common
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__common_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_in(self):
    self.__common_in = YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_common_output(self):
    """
    Getter method for common_output, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output (container)

    YANG Description: Container for information related to the line common
output port
    """
    return self.__common_output
      
  def _set_common_output(self, v, load=False):
    """
    Setter method for common_output, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_output() directly.

    YANG Description: Container for information related to the line common
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_output must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__common_output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_output(self):
    self.__common_output = YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  line_primary_in = __builtin__.property(_get_line_primary_in, _set_line_primary_in)
  line_primary_out = __builtin__.property(_get_line_primary_out, _set_line_primary_out)
  line_secondary_in = __builtin__.property(_get_line_secondary_in, _set_line_secondary_in)
  line_secondary_out = __builtin__.property(_get_line_secondary_out, _set_line_secondary_out)
  common_in = __builtin__.property(_get_common_in, _set_common_in)
  common_output = __builtin__.property(_get_common_output, _set_common_output)


  _pyangbind_elements = OrderedDict([('line_primary_in', line_primary_in), ('line_primary_out', line_primary_out), ('line_secondary_in', line_secondary_in), ('line_secondary_out', line_secondary_out), ('common_in', common_in), ('common_output', common_output), ])


class yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of automatic protection switch modules present
in the device
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__ports',)

  _yang_name = 'aps-module'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__ports = YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/name (leafref)

    YANG Description: Reference to the config name list key
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the config name list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/config (container)

    YANG Description: Configuration data for an automatic protection
switch module
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for an automatic protection
switch module
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/state (container)

    YANG Description: Operational state data for an automatic protection
switch module
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for an automatic protection
switch module
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_ports(self):
    """
    Getter method for ports, mapped from YANG variable /aps/aps_modules/aps_module/ports (container)

    YANG Description: Top level grouping for automatic protection switch ports
    """
    return self.__ports
      
  def _set_ports(self, v, load=False):
    """
    Setter method for ports, mapped from YANG variable /aps/aps_modules/aps_module/ports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ports() directly.

    YANG Description: Top level grouping for automatic protection switch ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ports(self):
    self.__ports = YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  ports = __builtin__.property(_get_ports, _set_ports)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('ports', ports), ])


class yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of automatic protection
      switch modules
  """
  __slots__ = ('_path_helper', '_extmethods', '__aps_module',)

  _yang_name = 'aps-modules'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps_module = YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules']

  def _get_aps_module(self):
    """
    Getter method for aps_module, mapped from YANG variable /aps/aps_modules/aps_module (list)

    YANG Description: List of automatic protection switch modules present
in the device
    """
    return self.__aps_module
      
  def _set_aps_module(self, v, load=False):
    """
    Setter method for aps_module, mapped from YANG variable /aps/aps_modules/aps_module (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps_module() directly.

    YANG Description: List of automatic protection switch modules present
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps_module must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)""",
        })

    self.__aps_module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps_module(self):
    self.__aps_module = YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)

  aps_module = __builtin__.property(_get_aps_module, _set_aps_module)


  _pyangbind_elements = OrderedDict([('aps_module', aps_module), ])


class yc_aps_openconfig_transport_line_protection__aps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level grouping for automatic protection switch data
  """
  __slots__ = ('_path_helper', '_extmethods', '__aps_modules',)

  _yang_name = 'aps'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps_modules = YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps']

  def _get_aps_modules(self):
    """
    Getter method for aps_modules, mapped from YANG variable /aps/aps_modules (container)

    YANG Description: Enclosing container for list of automatic protection
      switch modules
    """
    return self.__aps_modules
      
  def _set_aps_modules(self, v, load=False):
    """
    Setter method for aps_modules, mapped from YANG variable /aps/aps_modules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps_modules() directly.

    YANG Description: Enclosing container for list of automatic protection
      switch modules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps_modules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps_modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps_modules(self):
    self.__aps_modules = YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps_modules = __builtin__.property(_get_aps_modules, _set_aps_modules)


  _pyangbind_elements = OrderedDict([('aps_modules', aps_modules), ])


class openconfig_transport_line_protection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /openconfig-transport-line-protection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical line protection elements, deployed as part of a
transport line system. An Automatic Protection Switch (APS)
is typically installed in the same device as the amplifiers
and wave-router, however an APS can also be a standalone
device. In both scenarios, it serves the same purpose of
providing protection using two dark fiber pairs to ensure the
amplifiers can still receive a signal if one of the two fiber
pairs is broken. The APS port details and directionality are
shown below. The three major attributes, together with their
modifiers, define the behavior of the APS and can be prioritized
in the descending order as shown in the following table
  """
  __slots__ = ('_path_helper', '_extmethods', '__aps',)

  _yang_name = 'openconfig-transport-line-protection'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps = YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_aps(self):
    """
    Getter method for aps, mapped from YANG variable /aps (container)

    YANG Description: Top level grouping for automatic protection switch data
    """
    return self.__aps
      
  def _set_aps(self, v, load=False):
    """
    Setter method for aps, mapped from YANG variable /aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps() directly.

    YANG Description: Top level grouping for automatic protection switch data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps(self):
    self.__aps = YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps = __builtin__.property(_get_aps, _set_aps)


  _pyangbind_elements = OrderedDict([('aps', aps), ])


