# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for a maintenance domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__md_id','__level','__md_name_type','__none','__dns_like_name','__address','__unsigned_int','__char_string',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__md_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=True)
    self.__md_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__none = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__dns_like_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)
    self.__unsigned_int = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'config']

  def _get_md_id(self):
    """
    Getter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/md_id (oc-cfm-types:name-key-type)

    YANG Description: The unique identifier for a Maintenance Domain.
    """
    return self.__md_id
      
  def _set_md_id(self, v, load=False):
    """
    Setter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/md_id (oc-cfm-types:name-key-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md_id() directly.

    YANG Description: The unique identifier for a Maintenance Domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md_id must be of a type compatible with oc-cfm-types:name-key-type""",
          'defined-type': "oc-cfm-types:name-key-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)""",
        })

    self.__md_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md_id(self):
    self.__md_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/level (uint8)

    YANG Description: Level of the maintenance domain.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/level (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Level of the maintenance domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=True)


  def _get_md_name_type(self):
    """
    Getter method for md_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/md_name_type (enumeration)

    YANG Description: Type discriminator for the value  described in the md 'name' leaf.
    """
    return self.__md_name_type
      
  def _set_md_name_type(self, v, load=False):
    """
    Setter method for md_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/md_name_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md_name_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md_name_type() directly.

    YANG Description: Type discriminator for the value  described in the md 'name' leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md_name_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__md_name_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md_name_type(self):
    self.__md_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_none(self):
    """
    Getter method for none, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/none (boolean)

    YANG Description: No format specified, usually because there is not a
Maintenance Domain Name. The Maintenance Domain name
inserted in CFM protocol messages will be a zero length
OCTET string.
    """
    return self.__none
      
  def _set_none(self, v, load=False):
    """
    Setter method for none, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/none (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_none is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_none() directly.

    YANG Description: No format specified, usually because there is not a
Maintenance Domain Name. The Maintenance Domain name
inserted in CFM protocol messages will be a zero length
OCTET string.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """none must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__none = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_none(self):
    self.__none = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_dns_like_name(self):
    """
    Getter method for dns_like_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/dns_like_name (string)

    YANG Description: Domain name like string, globally unique text string
 derived from a DNS name.
    """
    return self.__dns_like_name
      
  def _set_dns_like_name(self, v, load=False):
    """
    Setter method for dns_like_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/dns_like_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_like_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_like_name() directly.

    YANG Description: Domain name like string, globally unique text string
 derived from a DNS name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_like_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__dns_like_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_like_name(self):
    self.__dns_like_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/address (oc-yang:mac-address)

    YANG Description: The MAC address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The MAC address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)


  def _get_unsigned_int(self):
    """
    Getter method for unsigned_int, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/unsigned_int (uint16)

    YANG Description: The additional 2-octet (unsigned) integer.
    """
    return self.__unsigned_int
      
  def _set_unsigned_int(self, v, load=False):
    """
    Setter method for unsigned_int, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/unsigned_int (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsigned_int is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsigned_int() directly.

    YANG Description: The additional 2-octet (unsigned) integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsigned_int must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__unsigned_int = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsigned_int(self):
    self.__unsigned_int = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_char_string(self):
    """
    Getter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/char_string (string)

    YANG Description: The character string name of the Maintenance Domain.
    """
    return self.__char_string
      
  def _set_char_string(self, v, load=False):
    """
    Setter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config/char_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_char_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_char_string() directly.

    YANG Description: The character string name of the Maintenance Domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """char_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__char_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_char_string(self):
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)

  md_id = __builtin__.property(_get_md_id, _set_md_id)
  level = __builtin__.property(_get_level, _set_level)
  md_name_type = __builtin__.property(_get_md_name_type, _set_md_name_type)
  none = __builtin__.property(_get_none, _set_none)
  dns_like_name = __builtin__.property(_get_dns_like_name, _set_dns_like_name)
  address = __builtin__.property(_get_address, _set_address)
  unsigned_int = __builtin__.property(_get_unsigned_int, _set_unsigned_int)
  char_string = __builtin__.property(_get_char_string, _set_char_string)


  _pyangbind_elements = OrderedDict([('md_id', md_id), ('level', level), ('md_name_type', md_name_type), ('none', none), ('dns_like_name', dns_like_name), ('address', address), ('unsigned_int', unsigned_int), ('char_string', char_string), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational data for a maintenance domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__md_id','__level','__md_name_type','__none','__dns_like_name','__address','__unsigned_int','__char_string',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__md_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=False)
    self.__md_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__none = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__dns_like_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)
    self.__unsigned_int = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'state']

  def _get_md_id(self):
    """
    Getter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/md_id (oc-cfm-types:name-key-type)

    YANG Description: The unique identifier for a Maintenance Domain.
    """
    return self.__md_id
      
  def _set_md_id(self, v, load=False):
    """
    Setter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/md_id (oc-cfm-types:name-key-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md_id() directly.

    YANG Description: The unique identifier for a Maintenance Domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md_id must be of a type compatible with oc-cfm-types:name-key-type""",
          'defined-type': "oc-cfm-types:name-key-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)""",
        })

    self.__md_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md_id(self):
    self.__md_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/level (uint8)

    YANG Description: Level of the maintenance domain.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/level (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Level of the maintenance domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=False)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint8', is_config=False)


  def _get_md_name_type(self):
    """
    Getter method for md_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/md_name_type (enumeration)

    YANG Description: Type discriminator for the value  described in the md 'name' leaf.
    """
    return self.__md_name_type
      
  def _set_md_name_type(self, v, load=False):
    """
    Setter method for md_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/md_name_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md_name_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md_name_type() directly.

    YANG Description: Type discriminator for the value  described in the md 'name' leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md_name_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__md_name_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md_name_type(self):
    self.__md_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'DOMAIN_NAME': {}, 'MAC_ADDRESS_AND_UINT': {}, 'CHARACTER_STRING': {}},), is_leaf=True, yang_name="md-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_none(self):
    """
    Getter method for none, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/none (boolean)

    YANG Description: No format specified, usually because there is not a
Maintenance Domain Name. The Maintenance Domain name
inserted in CFM protocol messages will be a zero length
OCTET string.
    """
    return self.__none
      
  def _set_none(self, v, load=False):
    """
    Setter method for none, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/none (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_none is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_none() directly.

    YANG Description: No format specified, usually because there is not a
Maintenance Domain Name. The Maintenance Domain name
inserted in CFM protocol messages will be a zero length
OCTET string.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """none must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__none = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_none(self):
    self.__none = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="none", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_dns_like_name(self):
    """
    Getter method for dns_like_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/dns_like_name (string)

    YANG Description: Domain name like string, globally unique text string
 derived from a DNS name.
    """
    return self.__dns_like_name
      
  def _set_dns_like_name(self, v, load=False):
    """
    Setter method for dns_like_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/dns_like_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_like_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_like_name() directly.

    YANG Description: Domain name like string, globally unique text string
 derived from a DNS name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_like_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__dns_like_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_like_name(self):
    self.__dns_like_name = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'length': ['1..43']}), is_leaf=True, yang_name="dns-like-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/address (oc-yang:mac-address)

    YANG Description: The MAC address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The MAC address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)


  def _get_unsigned_int(self):
    """
    Getter method for unsigned_int, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/unsigned_int (uint16)

    YANG Description: The additional 2-octet (unsigned) integer.
    """
    return self.__unsigned_int
      
  def _set_unsigned_int(self, v, load=False):
    """
    Setter method for unsigned_int, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/unsigned_int (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsigned_int is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsigned_int() directly.

    YANG Description: The additional 2-octet (unsigned) integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsigned_int must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__unsigned_int = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsigned_int(self):
    self.__unsigned_int = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_char_string(self):
    """
    Getter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/char_string (string)

    YANG Description: The character string name of the Maintenance Domain.
    """
    return self.__char_string
      
  def _set_char_string(self, v, load=False):
    """
    Setter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state/char_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_char_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_char_string() directly.

    YANG Description: The character string name of the Maintenance Domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """char_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__char_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_char_string(self):
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..43']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)

  md_id = __builtin__.property(_get_md_id)
  level = __builtin__.property(_get_level)
  md_name_type = __builtin__.property(_get_md_name_type)
  none = __builtin__.property(_get_none)
  dns_like_name = __builtin__.property(_get_dns_like_name)
  address = __builtin__.property(_get_address)
  unsigned_int = __builtin__.property(_get_unsigned_int)
  char_string = __builtin__.property(_get_char_string)


  _pyangbind_elements = OrderedDict([('md_id', md_id), ('level', level), ('md_name_type', md_name_type), ('none', none), ('dns_like_name', dns_like_name), ('address', address), ('unsigned_int', unsigned_int), ('char_string', char_string), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for a maintenance association.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ma_id','__group_name','__ma_name_type','__primary_vid','__char_string','__unsigned_int16','__vpn_oui','__vpn_index','__ccm_interval','__loss_threshold',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ma_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)
    self.__group_name = YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    self.__ma_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__primary_vid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    self.__unsigned_int16 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__vpn_oui = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    self.__vpn_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    self.__ccm_interval = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__loss_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'config']

  def _get_ma_id(self):
    """
    Getter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ma_id (oc-cfm-types:name-key-type)

    YANG Description: Key of the Maintenance Association list of entries.
    """
    return self.__ma_id
      
  def _set_ma_id(self, v, load=False):
    """
    Setter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ma_id (oc-cfm-types:name-key-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ma_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ma_id() directly.

    YANG Description: Key of the Maintenance Association list of entries.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ma_id must be of a type compatible with oc-cfm-types:name-key-type""",
          'defined-type': "oc-cfm-types:name-key-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)""",
        })

    self.__ma_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ma_id(self):
    self.__ma_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=True)


  def _get_group_name(self):
    """
    Getter method for group_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/group_name (string)

    YANG Description: Optional Bridge Group or Cross-connect Group name, if
Service Type is BridgeDomain or
CrossConnect
    """
    return self.__group_name
      
  def _set_group_name(self, v, load=False):
    """
    Setter method for group_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/group_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_name() directly.

    YANG Description: Optional Bridge Group or Cross-connect Group name, if
Service Type is BridgeDomain or
CrossConnect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_name(self):
    self.__group_name = YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)


  def _get_ma_name_type(self):
    """
    Getter method for ma_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ma_name_type (enumeration)

    YANG Description: Name type discriminator for the 'name' leaf.
    """
    return self.__ma_name_type
      
  def _set_ma_name_type(self, v, load=False):
    """
    Setter method for ma_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ma_name_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ma_name_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ma_name_type() directly.

    YANG Description: Name type discriminator for the 'name' leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ma_name_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__ma_name_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ma_name_type(self):
    self.__ma_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_primary_vid(self):
    """
    Getter method for primary_vid, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/primary_vid (oc-vlan-types:vlan-id)

    YANG Description: Primary VLAN ID. 12 bits represented in a 2-octet integer.
    """
    return self.__primary_vid
      
  def _set_primary_vid(self, v, load=False):
    """
    Setter method for primary_vid, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/primary_vid (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_vid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_vid() directly.

    YANG Description: Primary VLAN ID. 12 bits represented in a 2-octet integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_vid must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__primary_vid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_vid(self):
    self.__primary_vid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_char_string(self):
    """
    Getter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/char_string (string)

    YANG Description: RFC2579 DisplayString, except that the character codes 0-31
(decimal) are not used.
    """
    return self.__char_string
      
  def _set_char_string(self, v, load=False):
    """
    Setter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/char_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_char_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_char_string() directly.

    YANG Description: RFC2579 DisplayString, except that the character codes 0-31
(decimal) are not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """char_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__char_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_char_string(self):
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)


  def _get_unsigned_int16(self):
    """
    Getter method for unsigned_int16, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/unsigned_int16 (uint16)

    YANG Description: 2-octet integer.
    """
    return self.__unsigned_int16
      
  def _set_unsigned_int16(self, v, load=False):
    """
    Setter method for unsigned_int16, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/unsigned_int16 (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsigned_int16 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsigned_int16() directly.

    YANG Description: 2-octet integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsigned_int16 must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__unsigned_int16 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsigned_int16(self):
    self.__unsigned_int16 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_vpn_oui(self):
    """
    Getter method for vpn_oui, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/vpn_oui (uint32)

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
 Unique Identifier followed by 4 octet VPN index identifying
 VPN according to the OUI. 3 octet VPN authority
 Organizationally Unique Identifier.
    """
    return self.__vpn_oui
      
  def _set_vpn_oui(self, v, load=False):
    """
    Setter method for vpn_oui, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/vpn_oui (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_oui() directly.

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
 Unique Identifier followed by 4 octet VPN index identifying
 VPN according to the OUI. 3 octet VPN authority
 Organizationally Unique Identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_oui must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__vpn_oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_oui(self):
    self.__vpn_oui = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)


  def _get_vpn_index(self):
    """
    Getter method for vpn_index, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/vpn_index (uint32)

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
Unique Identifier followed by 4 octet VPN index identifying
VPN according to the OUI.
vpn-index is a 4 octet index identifying VPNaccording to the OUI.
    """
    return self.__vpn_index
      
  def _set_vpn_index(self, v, load=False):
    """
    Setter method for vpn_index, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/vpn_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_index() directly.

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
Unique Identifier followed by 4 octet VPN index identifying
VPN according to the OUI.
vpn-index is a 4 octet index identifying VPNaccording to the OUI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__vpn_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_index(self):
    self.__vpn_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)


  def _get_ccm_interval(self):
    """
    Getter method for ccm_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ccm_interval (enumeration)

    YANG Description: CCM transmission interval.
    """
    return self.__ccm_interval
      
  def _set_ccm_interval(self, v, load=False):
    """
    Setter method for ccm_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/ccm_interval (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ccm_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ccm_interval() directly.

    YANG Description: CCM transmission interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ccm_interval must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__ccm_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ccm_interval(self):
    self.__ccm_interval = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_loss_threshold(self):
    """
    Getter method for loss_threshold, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/loss_threshold (uint16)

    YANG Description: number of consecutive loss frames to trigger a loss event.
    """
    return self.__loss_threshold
      
  def _set_loss_threshold(self, v, load=False):
    """
    Setter method for loss_threshold, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config/loss_threshold (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loss_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loss_threshold() directly.

    YANG Description: number of consecutive loss frames to trigger a loss event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loss_threshold must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__loss_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loss_threshold(self):
    self.__loss_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)

  ma_id = __builtin__.property(_get_ma_id, _set_ma_id)
  group_name = __builtin__.property(_get_group_name, _set_group_name)
  ma_name_type = __builtin__.property(_get_ma_name_type, _set_ma_name_type)
  primary_vid = __builtin__.property(_get_primary_vid, _set_primary_vid)
  char_string = __builtin__.property(_get_char_string, _set_char_string)
  unsigned_int16 = __builtin__.property(_get_unsigned_int16, _set_unsigned_int16)
  vpn_oui = __builtin__.property(_get_vpn_oui, _set_vpn_oui)
  vpn_index = __builtin__.property(_get_vpn_index, _set_vpn_index)
  ccm_interval = __builtin__.property(_get_ccm_interval, _set_ccm_interval)
  loss_threshold = __builtin__.property(_get_loss_threshold, _set_loss_threshold)


  _pyangbind_elements = OrderedDict([('ma_id', ma_id), ('group_name', group_name), ('ma_name_type', ma_name_type), ('primary_vid', primary_vid), ('char_string', char_string), ('unsigned_int16', unsigned_int16), ('vpn_oui', vpn_oui), ('vpn_index', vpn_index), ('ccm_interval', ccm_interval), ('loss_threshold', loss_threshold), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational data for a maintenance association.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ma_id','__group_name','__ma_name_type','__primary_vid','__char_string','__unsigned_int16','__vpn_oui','__vpn_index','__ccm_interval','__loss_threshold',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ma_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)
    self.__group_name = YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    self.__ma_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__primary_vid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    self.__unsigned_int16 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__vpn_oui = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__vpn_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__ccm_interval = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__loss_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'state']

  def _get_ma_id(self):
    """
    Getter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ma_id (oc-cfm-types:name-key-type)

    YANG Description: Key of the Maintenance Association list of entries.
    """
    return self.__ma_id
      
  def _set_ma_id(self, v, load=False):
    """
    Setter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ma_id (oc-cfm-types:name-key-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ma_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ma_id() directly.

    YANG Description: Key of the Maintenance Association list of entries.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ma_id must be of a type compatible with oc-cfm-types:name-key-type""",
          'defined-type': "oc-cfm-types:name-key-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)""",
        })

    self.__ma_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ma_id(self):
    self.__ma_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-zA-Z\\-_.]*', 'length': ['1..255']}), is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:name-key-type', is_config=False)


  def _get_group_name(self):
    """
    Getter method for group_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/group_name (string)

    YANG Description: Optional Bridge Group or Cross-connect Group name, if
Service Type is BridgeDomain or
CrossConnect
    """
    return self.__group_name
      
  def _set_group_name(self, v, load=False):
    """
    Setter method for group_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/group_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_name() directly.

    YANG Description: Optional Bridge Group or Cross-connect Group name, if
Service Type is BridgeDomain or
CrossConnect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_name(self):
    self.__group_name = YANGDynClass(base=str, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)


  def _get_ma_name_type(self):
    """
    Getter method for ma_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ma_name_type (enumeration)

    YANG Description: Name type discriminator for the 'name' leaf.
    """
    return self.__ma_name_type
      
  def _set_ma_name_type(self, v, load=False):
    """
    Setter method for ma_name_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ma_name_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ma_name_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ma_name_type() directly.

    YANG Description: Name type discriminator for the 'name' leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ma_name_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__ma_name_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ma_name_type(self):
    self.__ma_name_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'PRIMARY_VID': {}, 'CHARACTER_STRING': {}, 'UINT16': {}, 'RFC2685_VPN_ID': {}},), is_leaf=True, yang_name="ma-name-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_primary_vid(self):
    """
    Getter method for primary_vid, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/primary_vid (oc-vlan-types:vlan-id)

    YANG Description: Primary VLAN ID. 12 bits represented in a 2-octet integer.
    """
    return self.__primary_vid
      
  def _set_primary_vid(self, v, load=False):
    """
    Setter method for primary_vid, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/primary_vid (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_vid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_vid() directly.

    YANG Description: Primary VLAN ID. 12 bits represented in a 2-octet integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_vid must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__primary_vid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_vid(self):
    self.__primary_vid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..4094']}), is_leaf=True, yang_name="primary-vid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_char_string(self):
    """
    Getter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/char_string (string)

    YANG Description: RFC2579 DisplayString, except that the character codes 0-31
(decimal) are not used.
    """
    return self.__char_string
      
  def _set_char_string(self, v, load=False):
    """
    Setter method for char_string, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/char_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_char_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_char_string() directly.

    YANG Description: RFC2579 DisplayString, except that the character codes 0-31
(decimal) are not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """char_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__char_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_char_string(self):
    self.__char_string = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[ -~]*', 'length': ['1..45']}), is_leaf=True, yang_name="char-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)


  def _get_unsigned_int16(self):
    """
    Getter method for unsigned_int16, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/unsigned_int16 (uint16)

    YANG Description: 2-octet integer.
    """
    return self.__unsigned_int16
      
  def _set_unsigned_int16(self, v, load=False):
    """
    Setter method for unsigned_int16, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/unsigned_int16 (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsigned_int16 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsigned_int16() directly.

    YANG Description: 2-octet integer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsigned_int16 must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__unsigned_int16 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsigned_int16(self):
    self.__unsigned_int16 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="unsigned-int16", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_vpn_oui(self):
    """
    Getter method for vpn_oui, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/vpn_oui (uint32)

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
 Unique Identifier followed by 4 octet VPN index identifying
 VPN according to the OUI. 3 octet VPN authority
 Organizationally Unique Identifier.
    """
    return self.__vpn_oui
      
  def _set_vpn_oui(self, v, load=False):
    """
    Setter method for vpn_oui, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/vpn_oui (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_oui() directly.

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
 Unique Identifier followed by 4 octet VPN index identifying
 VPN according to the OUI. 3 octet VPN authority
 Organizationally Unique Identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_oui must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__vpn_oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_oui(self):
    self.__vpn_oui = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="vpn-oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_vpn_index(self):
    """
    Getter method for vpn_index, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/vpn_index (uint32)

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
Unique Identifier followed by 4 octet VPN index identifying
VPN according to the OUI.
vpn-index is a 4 octet index identifying VPNaccording to the OUI.
    """
    return self.__vpn_index
      
  def _set_vpn_index(self, v, load=False):
    """
    Setter method for vpn_index, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/vpn_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_index() directly.

    YANG Description: RFC2685 VPN ID. 3 octet VPN authority Organizationally
Unique Identifier followed by 4 octet VPN index identifying
VPN according to the OUI.
vpn-index is a 4 octet index identifying VPNaccording to the OUI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__vpn_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_index(self):
    self.__vpn_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vpn-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_ccm_interval(self):
    """
    Getter method for ccm_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ccm_interval (enumeration)

    YANG Description: CCM transmission interval.
    """
    return self.__ccm_interval
      
  def _set_ccm_interval(self, v, load=False):
    """
    Setter method for ccm_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/ccm_interval (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ccm_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ccm_interval() directly.

    YANG Description: CCM transmission interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ccm_interval must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__ccm_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ccm_interval(self):
    self.__ccm_interval = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'300MS': {}, '1S': {}, '10S': {}},), is_leaf=True, yang_name="ccm-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_loss_threshold(self):
    """
    Getter method for loss_threshold, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/loss_threshold (uint16)

    YANG Description: number of consecutive loss frames to trigger a loss event.
    """
    return self.__loss_threshold
      
  def _set_loss_threshold(self, v, load=False):
    """
    Setter method for loss_threshold, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state/loss_threshold (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loss_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loss_threshold() directly.

    YANG Description: number of consecutive loss frames to trigger a loss event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loss_threshold must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__loss_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loss_threshold(self):
    self.__loss_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="loss-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)

  ma_id = __builtin__.property(_get_ma_id)
  group_name = __builtin__.property(_get_group_name)
  ma_name_type = __builtin__.property(_get_ma_name_type)
  primary_vid = __builtin__.property(_get_primary_vid)
  char_string = __builtin__.property(_get_char_string)
  unsigned_int16 = __builtin__.property(_get_unsigned_int16)
  vpn_oui = __builtin__.property(_get_vpn_oui)
  vpn_index = __builtin__.property(_get_vpn_index)
  ccm_interval = __builtin__.property(_get_ccm_interval)
  loss_threshold = __builtin__.property(_get_loss_threshold)


  _pyangbind_elements = OrderedDict([('ma_id', ma_id), ('group_name', group_name), ('ma_name_type', ma_name_type), ('primary_vid', primary_vid), ('char_string', char_string), ('unsigned_int16', unsigned_int16), ('vpn_oui', vpn_oui), ('vpn_index', vpn_index), ('ccm_interval', ccm_interval), ('loss_threshold', loss_threshold), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for a MEP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ccm_enabled','__lowest_priority_defect','__fng_alarm_time','__fng_reset_time','__local_mep_id','__interface','__include_mep_port_status_in_tlv','__include_mep_interface_status_in_tlv','__direction','__auto_discovery',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ccm_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__lowest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=True)
    self.__fng_alarm_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__fng_reset_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__local_mep_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__include_mep_port_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__include_mep_interface_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__auto_discovery = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'config']

  def _get_ccm_enabled(self):
    """
    Getter method for ccm_enabled, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/ccm_enabled (boolean)

    YANG Description: Indicates whether the MEP can generate CCMs. If TRUE, the
MEP will generate CCM PDUs.
    """
    return self.__ccm_enabled
      
  def _set_ccm_enabled(self, v, load=False):
    """
    Setter method for ccm_enabled, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/ccm_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ccm_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ccm_enabled() directly.

    YANG Description: Indicates whether the MEP can generate CCMs. If TRUE, the
MEP will generate CCM PDUs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ccm_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__ccm_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ccm_enabled(self):
    self.__ccm_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_lowest_priority_defect(self):
    """
    Getter method for lowest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/lowest_priority_defect (oc-cfm-types:lowest-alarm-priority-type)

    YANG Description: The lowest priority defect that is allowed to generate
fault alarms.
    """
    return self.__lowest_priority_defect
      
  def _set_lowest_priority_defect(self, v, load=False):
    """
    Setter method for lowest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/lowest_priority_defect (oc-cfm-types:lowest-alarm-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowest_priority_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowest_priority_defect() directly.

    YANG Description: The lowest priority defect that is allowed to generate
fault alarms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowest_priority_defect must be of a type compatible with oc-cfm-types:lowest-alarm-priority-type""",
          'defined-type': "oc-cfm-types:lowest-alarm-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=True)""",
        })

    self.__lowest_priority_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowest_priority_defect(self):
    self.__lowest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=True)


  def _get_fng_alarm_time(self):
    """
    Getter method for fng_alarm_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/fng_alarm_time (uint16)

    YANG Description: The time that defect must be present before a Fault Alarm
is issued.
    """
    return self.__fng_alarm_time
      
  def _set_fng_alarm_time(self, v, load=False):
    """
    Setter method for fng_alarm_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/fng_alarm_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_alarm_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_alarm_time() directly.

    YANG Description: The time that defect must be present before a Fault Alarm
is issued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_alarm_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__fng_alarm_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_alarm_time(self):
    self.__fng_alarm_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_fng_reset_time(self):
    """
    Getter method for fng_reset_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/fng_reset_time (uint16)

    YANG Description: The time that defects must be absent before resetting a
Fault Alarm.
    """
    return self.__fng_reset_time
      
  def _set_fng_reset_time(self, v, load=False):
    """
    Setter method for fng_reset_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/fng_reset_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_reset_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_reset_time() directly.

    YANG Description: The time that defects must be absent before resetting a
Fault Alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_reset_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__fng_reset_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_reset_time(self):
    self.__fng_reset_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_local_mep_id(self):
    """
    Getter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/local_mep_id (oc-cfm-types:mep-id-type)

    YANG Description: The identifier of a Local MEP.  Unique per given  MA 
    """
    return self.__local_mep_id
      
  def _set_local_mep_id(self, v, load=False):
    """
    Setter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/local_mep_id (oc-cfm-types:mep-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_mep_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_mep_id() directly.

    YANG Description: The identifier of a Local MEP.  Unique per given  MA 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_mep_id must be of a type compatible with oc-cfm-types:mep-id-type""",
          'defined-type': "oc-cfm-types:mep-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)""",
        })

    self.__local_mep_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_mep_id(self):
    self.__local_mep_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/interface (leafref)

    YANG Description: Interface directly associated with the MEP id.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Interface directly associated with the MEP id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_include_mep_port_status_in_tlv(self):
    """
    Getter method for include_mep_port_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/include_mep_port_status_in_tlv (boolean)

    YANG Description: Indicates whether a Port Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Port Status
TLV is to be included. A value of 'false' indicates that the
Port Status TLV is not to be included.
    """
    return self.__include_mep_port_status_in_tlv
      
  def _set_include_mep_port_status_in_tlv(self, v, load=False):
    """
    Setter method for include_mep_port_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/include_mep_port_status_in_tlv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_mep_port_status_in_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_mep_port_status_in_tlv() directly.

    YANG Description: Indicates whether a Port Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Port Status
TLV is to be included. A value of 'false' indicates that the
Port Status TLV is not to be included.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_mep_port_status_in_tlv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__include_mep_port_status_in_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_mep_port_status_in_tlv(self):
    self.__include_mep_port_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_include_mep_interface_status_in_tlv(self):
    """
    Getter method for include_mep_interface_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/include_mep_interface_status_in_tlv (boolean)

    YANG Description: Indicates whether a Interface Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Interface Status TLV
is to be included. A value of 'false' indicates that the Interface
Status TLV is not to be included.
    """
    return self.__include_mep_interface_status_in_tlv
      
  def _set_include_mep_interface_status_in_tlv(self, v, load=False):
    """
    Setter method for include_mep_interface_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/include_mep_interface_status_in_tlv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_mep_interface_status_in_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_mep_interface_status_in_tlv() directly.

    YANG Description: Indicates whether a Interface Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Interface Status TLV
is to be included. A value of 'false' indicates that the Interface
Status TLV is not to be included.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_mep_interface_status_in_tlv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__include_mep_interface_status_in_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_mep_interface_status_in_tlv(self):
    self.__include_mep_interface_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_direction(self):
    """
    Getter method for direction, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/direction (enumeration)

    YANG Description: The direction in which the MEP faces on the Bridge/Xconnect
Port. Example, up or down.
    """
    return self.__direction
      
  def _set_direction(self, v, load=False):
    """
    Setter method for direction, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/direction (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction in which the MEP faces on the Bridge/Xconnect
Port. Example, up or down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """direction must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_direction(self):
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_auto_discovery(self):
    """
    Getter method for auto_discovery, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/auto_discovery (boolean)

    YANG Description: A boolean value to enable or disable auto-discovery.
users must configure explicitly true or false.
If unset, then its implementation specific.
    """
    return self.__auto_discovery
      
  def _set_auto_discovery(self, v, load=False):
    """
    Setter method for auto_discovery, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config/auto_discovery (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_discovery() directly.

    YANG Description: A boolean value to enable or disable auto-discovery.
users must configure explicitly true or false.
If unset, then its implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_discovery must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_discovery(self):
    self.__auto_discovery = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)

  ccm_enabled = __builtin__.property(_get_ccm_enabled, _set_ccm_enabled)
  lowest_priority_defect = __builtin__.property(_get_lowest_priority_defect, _set_lowest_priority_defect)
  fng_alarm_time = __builtin__.property(_get_fng_alarm_time, _set_fng_alarm_time)
  fng_reset_time = __builtin__.property(_get_fng_reset_time, _set_fng_reset_time)
  local_mep_id = __builtin__.property(_get_local_mep_id, _set_local_mep_id)
  interface = __builtin__.property(_get_interface, _set_interface)
  include_mep_port_status_in_tlv = __builtin__.property(_get_include_mep_port_status_in_tlv, _set_include_mep_port_status_in_tlv)
  include_mep_interface_status_in_tlv = __builtin__.property(_get_include_mep_interface_status_in_tlv, _set_include_mep_interface_status_in_tlv)
  direction = __builtin__.property(_get_direction, _set_direction)
  auto_discovery = __builtin__.property(_get_auto_discovery, _set_auto_discovery)


  _pyangbind_elements = OrderedDict([('ccm_enabled', ccm_enabled), ('lowest_priority_defect', lowest_priority_defect), ('fng_alarm_time', fng_alarm_time), ('fng_reset_time', fng_reset_time), ('local_mep_id', local_mep_id), ('interface', interface), ('include_mep_port_status_in_tlv', include_mep_port_status_in_tlv), ('include_mep_interface_status_in_tlv', include_mep_interface_status_in_tlv), ('direction', direction), ('auto_discovery', auto_discovery), ])


class yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of mep-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mep_ccm_sequence_errors','__mep_ccms_sent',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mep_ccm_sequence_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__mep_ccms_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'state', 'counters']

  def _get_mep_ccm_sequence_errors(self):
    """
    Getter method for mep_ccm_sequence_errors, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters/mep_ccm_sequence_errors (oc-yang:counter64)

    YANG Description: The total number of out-of-sequence CCMs received from
all remote MEPs.
    """
    return self.__mep_ccm_sequence_errors
      
  def _set_mep_ccm_sequence_errors(self, v, load=False):
    """
    Setter method for mep_ccm_sequence_errors, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters/mep_ccm_sequence_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_ccm_sequence_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_ccm_sequence_errors() directly.

    YANG Description: The total number of out-of-sequence CCMs received from
all remote MEPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_ccm_sequence_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mep_ccm_sequence_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_ccm_sequence_errors(self):
    self.__mep_ccm_sequence_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_mep_ccms_sent(self):
    """
    Getter method for mep_ccms_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters/mep_ccms_sent (oc-yang:counter64)

    YANG Description: Total number of CCMs transmitted by the local MEP
    """
    return self.__mep_ccms_sent
      
  def _set_mep_ccms_sent(self, v, load=False):
    """
    Setter method for mep_ccms_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters/mep_ccms_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_ccms_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_ccms_sent() directly.

    YANG Description: Total number of CCMs transmitted by the local MEP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_ccms_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mep_ccms_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_ccms_sent(self):
    self.__mep_ccms_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  mep_ccm_sequence_errors = __builtin__.property(_get_mep_ccm_sequence_errors)
  mep_ccms_sent = __builtin__.property(_get_mep_ccms_sent)


  _pyangbind_elements = OrderedDict([('mep_ccm_sequence_errors', mep_ccm_sequence_errors), ('mep_ccms_sent', mep_ccms_sent), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description:  Operational tate data for a MEP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ccm_enabled','__lowest_priority_defect','__fng_alarm_time','__fng_reset_time','__local_mep_id','__interface','__include_mep_port_status_in_tlv','__include_mep_interface_status_in_tlv','__direction','__auto_discovery','__oper_state','__interface_state','__fng_state','__highest_priority_defect','__mep_defects','__present_rdi','__config_errors_detected','__error_ccm_last_failure','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ccm_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__lowest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=False)
    self.__fng_alarm_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__fng_reset_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__local_mep_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=False)
    self.__include_mep_port_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__include_mep_interface_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__auto_discovery = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__oper_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)
    self.__interface_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)
    self.__fng_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)
    self.__highest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)
    self.__mep_defects = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)
    self.__present_rdi = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__config_errors_detected = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)
    self.__error_ccm_last_failure = YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'state']

  def _get_ccm_enabled(self):
    """
    Getter method for ccm_enabled, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/ccm_enabled (boolean)

    YANG Description: Indicates whether the MEP can generate CCMs. If TRUE, the
MEP will generate CCM PDUs.
    """
    return self.__ccm_enabled
      
  def _set_ccm_enabled(self, v, load=False):
    """
    Setter method for ccm_enabled, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/ccm_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ccm_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ccm_enabled() directly.

    YANG Description: Indicates whether the MEP can generate CCMs. If TRUE, the
MEP will generate CCM PDUs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ccm_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__ccm_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ccm_enabled(self):
    self.__ccm_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ccm-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_lowest_priority_defect(self):
    """
    Getter method for lowest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/lowest_priority_defect (oc-cfm-types:lowest-alarm-priority-type)

    YANG Description: The lowest priority defect that is allowed to generate
fault alarms.
    """
    return self.__lowest_priority_defect
      
  def _set_lowest_priority_defect(self, v, load=False):
    """
    Setter method for lowest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/lowest_priority_defect (oc-cfm-types:lowest-alarm-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowest_priority_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowest_priority_defect() directly.

    YANG Description: The lowest priority defect that is allowed to generate
fault alarms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowest_priority_defect must be of a type compatible with oc-cfm-types:lowest-alarm-priority-type""",
          'defined-type': "oc-cfm-types:lowest-alarm-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=False)""",
        })

    self.__lowest_priority_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowest_priority_defect(self):
    self.__lowest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL_DEF': {'value': 1}, 'MAC_REMOTE_ERROR_XCON': {'value': 2}, 'REMOTE_ERROR_XCON': {'value': 3}, 'ERROR_XCON': {'value': 4}, 'XCON': {'value': 5}, 'NO_XCON': {'value': 6}},), default=str("MAC_REMOTE_ERROR_XCON"), is_leaf=True, yang_name="lowest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:lowest-alarm-priority-type', is_config=False)


  def _get_fng_alarm_time(self):
    """
    Getter method for fng_alarm_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_alarm_time (uint16)

    YANG Description: The time that defect must be present before a Fault Alarm
is issued.
    """
    return self.__fng_alarm_time
      
  def _set_fng_alarm_time(self, v, load=False):
    """
    Setter method for fng_alarm_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_alarm_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_alarm_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_alarm_time() directly.

    YANG Description: The time that defect must be present before a Fault Alarm
is issued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_alarm_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__fng_alarm_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_alarm_time(self):
    self.__fng_alarm_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(2500), is_leaf=True, yang_name="fng-alarm-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_fng_reset_time(self):
    """
    Getter method for fng_reset_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_reset_time (uint16)

    YANG Description: The time that defects must be absent before resetting a
Fault Alarm.
    """
    return self.__fng_reset_time
      
  def _set_fng_reset_time(self, v, load=False):
    """
    Setter method for fng_reset_time, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_reset_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_reset_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_reset_time() directly.

    YANG Description: The time that defects must be absent before resetting a
Fault Alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_reset_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__fng_reset_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_reset_time(self):
    self.__fng_reset_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2500..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10000), is_leaf=True, yang_name="fng-reset-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_local_mep_id(self):
    """
    Getter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/local_mep_id (oc-cfm-types:mep-id-type)

    YANG Description: The identifier of a Local MEP.  Unique per given  MA 
    """
    return self.__local_mep_id
      
  def _set_local_mep_id(self, v, load=False):
    """
    Setter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/local_mep_id (oc-cfm-types:mep-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_mep_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_mep_id() directly.

    YANG Description: The identifier of a Local MEP.  Unique per given  MA 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_mep_id must be of a type compatible with oc-cfm-types:mep-id-type""",
          'defined-type': "oc-cfm-types:mep-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)""",
        })

    self.__local_mep_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_mep_id(self):
    self.__local_mep_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/interface (leafref)

    YANG Description: Interface directly associated with the MEP id.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Interface directly associated with the MEP id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=str, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=False)


  def _get_include_mep_port_status_in_tlv(self):
    """
    Getter method for include_mep_port_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/include_mep_port_status_in_tlv (boolean)

    YANG Description: Indicates whether a Port Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Port Status
TLV is to be included. A value of 'false' indicates that the
Port Status TLV is not to be included.
    """
    return self.__include_mep_port_status_in_tlv
      
  def _set_include_mep_port_status_in_tlv(self, v, load=False):
    """
    Setter method for include_mep_port_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/include_mep_port_status_in_tlv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_mep_port_status_in_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_mep_port_status_in_tlv() directly.

    YANG Description: Indicates whether a Port Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Port Status
TLV is to be included. A value of 'false' indicates that the
Port Status TLV is not to be included.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_mep_port_status_in_tlv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__include_mep_port_status_in_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_mep_port_status_in_tlv(self):
    self.__include_mep_port_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-port-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_include_mep_interface_status_in_tlv(self):
    """
    Getter method for include_mep_interface_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/include_mep_interface_status_in_tlv (boolean)

    YANG Description: Indicates whether a Interface Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Interface Status TLV
is to be included. A value of 'false' indicates that the Interface
Status TLV is not to be included.
    """
    return self.__include_mep_interface_status_in_tlv
      
  def _set_include_mep_interface_status_in_tlv(self, v, load=False):
    """
    Setter method for include_mep_interface_status_in_tlv, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/include_mep_interface_status_in_tlv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_mep_interface_status_in_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_mep_interface_status_in_tlv() directly.

    YANG Description: Indicates whether a Interface Status TLV is included in CCM frame
transmission. A value of 'true' indicates that the Interface Status TLV
is to be included. A value of 'false' indicates that the Interface
Status TLV is not to be included.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_mep_interface_status_in_tlv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__include_mep_interface_status_in_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_mep_interface_status_in_tlv(self):
    self.__include_mep_interface_status_in_tlv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="include-mep-interface-status-in-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_direction(self):
    """
    Getter method for direction, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/direction (enumeration)

    YANG Description: The direction in which the MEP faces on the Bridge/Xconnect
Port. Example, up or down.
    """
    return self.__direction
      
  def _set_direction(self, v, load=False):
    """
    Setter method for direction, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/direction (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction in which the MEP faces on the Bridge/Xconnect
Port. Example, up or down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """direction must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_direction(self):
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DOWN': {'value': 1}, 'UP': {'value': 2}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_auto_discovery(self):
    """
    Getter method for auto_discovery, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/auto_discovery (boolean)

    YANG Description: A boolean value to enable or disable auto-discovery.
users must configure explicitly true or false.
If unset, then its implementation specific.
    """
    return self.__auto_discovery
      
  def _set_auto_discovery(self, v, load=False):
    """
    Setter method for auto_discovery, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/auto_discovery (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_discovery() directly.

    YANG Description: A boolean value to enable or disable auto-discovery.
users must configure explicitly true or false.
If unset, then its implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_discovery must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_discovery(self):
    self.__auto_discovery = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_oper_state(self):
    """
    Getter method for oper_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/oper_state (oc-cfm-types:operational-state-type)

    YANG Description: Operational state of the MEP.
    """
    return self.__oper_state
      
  def _set_oper_state(self, v, load=False):
    """
    Setter method for oper_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/oper_state (oc-cfm-types:operational-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_state() directly.

    YANG Description: Operational state of the MEP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_state must be of a type compatible with oc-cfm-types:operational-state-type""",
          'defined-type': "oc-cfm-types:operational-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)""",
        })

    self.__oper_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_state(self):
    self.__oper_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)


  def _get_interface_state(self):
    """
    Getter method for interface_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/interface_state (oc-cfm-types:interface-status-type)

    YANG Description: The state of the interface last reported by the local MEP in the TLV.
    """
    return self.__interface_state
      
  def _set_interface_state(self, v, load=False):
    """
    Setter method for interface_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/interface_state (oc-cfm-types:interface-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_state() directly.

    YANG Description: The state of the interface last reported by the local MEP in the TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_state must be of a type compatible with oc-cfm-types:interface-status-type""",
          'defined-type': "oc-cfm-types:interface-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)""",
        })

    self.__interface_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_state(self):
    self.__interface_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)


  def _get_fng_state(self):
    """
    Getter method for fng_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_state (oc-cfm-types:fng-state-type)

    YANG Description: The current state of the MEP Fault Notification Generator
state machine.
    """
    return self.__fng_state
      
  def _set_fng_state(self, v, load=False):
    """
    Setter method for fng_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/fng_state (oc-cfm-types:fng-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_state() directly.

    YANG Description: The current state of the MEP Fault Notification Generator
state machine.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_state must be of a type compatible with oc-cfm-types:fng-state-type""",
          'defined-type': "oc-cfm-types:fng-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)""",
        })

    self.__fng_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_state(self):
    self.__fng_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)


  def _get_highest_priority_defect(self):
    """
    Getter method for highest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/highest_priority_defect (oc-cfm-types:highest-defect-priority-type)

    YANG Description: The highest priority defect that has been present since
the MEPs Fault Notification Generator state machine was
last in the FNG_RESET state.
    """
    return self.__highest_priority_defect
      
  def _set_highest_priority_defect(self, v, load=False):
    """
    Setter method for highest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/highest_priority_defect (oc-cfm-types:highest-defect-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_highest_priority_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_highest_priority_defect() directly.

    YANG Description: The highest priority defect that has been present since
the MEPs Fault Notification Generator state machine was
last in the FNG_RESET state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """highest_priority_defect must be of a type compatible with oc-cfm-types:highest-defect-priority-type""",
          'defined-type': "oc-cfm-types:highest-defect-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)""",
        })

    self.__highest_priority_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_highest_priority_defect(self):
    self.__highest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)


  def _get_mep_defects(self):
    """
    Getter method for mep_defects, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/mep_defects (oc-cfm-types:mep-defects-type)

    YANG Description: Vector of boolean error conditions.
Multiple defects can be present at the same time.
    """
    return self.__mep_defects
      
  def _set_mep_defects(self, v, load=False):
    """
    Setter method for mep_defects, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/mep_defects (oc-cfm-types:mep-defects-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_defects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_defects() directly.

    YANG Description: Vector of boolean error conditions.
Multiple defects can be present at the same time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_defects must be of a type compatible with oc-cfm-types:mep-defects-type""",
          'defined-type': "oc-cfm-types:mep-defects-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)""",
        })

    self.__mep_defects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_defects(self):
    self.__mep_defects = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)


  def _get_present_rdi(self):
    """
    Getter method for present_rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/present_rdi (boolean)

    YANG Description: A boolean value indicating the state of the RDI bit in CCMs
transmitted by this MEP. present-rdi is true if and only if one or more
of the variables someRMEPCCMdefect, someMACstatusDefect, errorCCMdefect,
or xconCCMdefect is true, and if the corresponding priority of that
variable, from mep-defects above, is greater than or equal to the
value of the variable lowestAlarmPri.
    """
    return self.__present_rdi
      
  def _set_present_rdi(self, v, load=False):
    """
    Setter method for present_rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/present_rdi (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_present_rdi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_present_rdi() directly.

    YANG Description: A boolean value indicating the state of the RDI bit in CCMs
transmitted by this MEP. present-rdi is true if and only if one or more
of the variables someRMEPCCMdefect, someMACstatusDefect, errorCCMdefect,
or xconCCMdefect is true, and if the corresponding priority of that
variable, from mep-defects above, is greater than or equal to the
value of the variable lowestAlarmPri.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """present_rdi must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__present_rdi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_present_rdi(self):
    self.__present_rdi = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_config_errors_detected(self):
    """
    Getter method for config_errors_detected, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/config_errors_detected (oc-cfm-types:config-error-type)

    YANG Description: Vector of enums of config error detected. i.e. [cfm-leak]
    """
    return self.__config_errors_detected
      
  def _set_config_errors_detected(self, v, load=False):
    """
    Setter method for config_errors_detected, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/config_errors_detected (oc-cfm-types:config-error-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_errors_detected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_errors_detected() directly.

    YANG Description: Vector of enums of config error detected. i.e. [cfm-leak]
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_errors_detected must be of a type compatible with oc-cfm-types:config-error-type""",
          'defined-type': "oc-cfm-types:config-error-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)""",
        })

    self.__config_errors_detected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_errors_detected(self):
    self.__config_errors_detected = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)


  def _get_error_ccm_last_failure(self):
    """
    Getter method for error_ccm_last_failure, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/error_ccm_last_failure (binary)

    YANG Description: The last received CCM that triggered a def-error-ccm
 fault.
    """
    return self.__error_ccm_last_failure
      
  def _set_error_ccm_last_failure(self, v, load=False):
    """
    Setter method for error_ccm_last_failure, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/error_ccm_last_failure (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_ccm_last_failure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_ccm_last_failure() directly.

    YANG Description: The last received CCM that triggered a def-error-ccm
 fault.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_ccm_last_failure must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)""",
        })

    self.__error_ccm_last_failure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_ccm_last_failure(self):
    self.__error_ccm_last_failure = YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters (container)

    YANG Description: A collection of mep-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of mep-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  ccm_enabled = __builtin__.property(_get_ccm_enabled)
  lowest_priority_defect = __builtin__.property(_get_lowest_priority_defect)
  fng_alarm_time = __builtin__.property(_get_fng_alarm_time)
  fng_reset_time = __builtin__.property(_get_fng_reset_time)
  local_mep_id = __builtin__.property(_get_local_mep_id)
  interface = __builtin__.property(_get_interface)
  include_mep_port_status_in_tlv = __builtin__.property(_get_include_mep_port_status_in_tlv)
  include_mep_interface_status_in_tlv = __builtin__.property(_get_include_mep_interface_status_in_tlv)
  direction = __builtin__.property(_get_direction)
  auto_discovery = __builtin__.property(_get_auto_discovery)
  oper_state = __builtin__.property(_get_oper_state)
  interface_state = __builtin__.property(_get_interface_state)
  fng_state = __builtin__.property(_get_fng_state)
  highest_priority_defect = __builtin__.property(_get_highest_priority_defect)
  mep_defects = __builtin__.property(_get_mep_defects)
  present_rdi = __builtin__.property(_get_present_rdi)
  config_errors_detected = __builtin__.property(_get_config_errors_detected)
  error_ccm_last_failure = __builtin__.property(_get_error_ccm_last_failure)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('ccm_enabled', ccm_enabled), ('lowest_priority_defect', lowest_priority_defect), ('fng_alarm_time', fng_alarm_time), ('fng_reset_time', fng_reset_time), ('local_mep_id', local_mep_id), ('interface', interface), ('include_mep_port_status_in_tlv', include_mep_port_status_in_tlv), ('include_mep_interface_status_in_tlv', include_mep_interface_status_in_tlv), ('direction', direction), ('auto_discovery', auto_discovery), ('oper_state', oper_state), ('interface_state', interface_state), ('fng_state', fng_state), ('highest_priority_defect', highest_priority_defect), ('mep_defects', mep_defects), ('present_rdi', present_rdi), ('config_errors_detected', config_errors_detected), ('error_ccm_last_failure', error_ccm_last_failure), ('counters', counters), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Associated performance Measurement profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'config']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/config/profile_name (string)

    YANG Description: A unique profile name identifying the profile
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/config/profile_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: A unique profile name identifying the profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)

  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ])


class yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/state/loss-measurement-state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of loss-measurement-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__slm_sent','__slm_received','__slr_sent','__slr_received',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'state', 'loss-measurement-state', 'counters']

  def _get_slm_sent(self):
    """
    Getter method for slm_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slm_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slm_sent
      
  def _set_slm_sent(self, v, load=False):
    """
    Setter method for slm_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slm_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slm_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slm_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slm_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slm_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slm_sent(self):
    self.__slm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slm_received(self):
    """
    Getter method for slm_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slm_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slm_received
      
  def _set_slm_received(self, v, load=False):
    """
    Setter method for slm_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slm_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slm_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slm_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slm_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slm_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slm_received(self):
    self.__slm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slr_sent(self):
    """
    Getter method for slr_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slr_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slr_sent
      
  def _set_slr_sent(self, v, load=False):
    """
    Setter method for slr_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slr_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slr_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slr_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slr_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slr_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slr_sent(self):
    self.__slr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slr_received(self):
    """
    Getter method for slr_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slr_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slr_received
      
  def _set_slr_received(self, v, load=False):
    """
    Setter method for slr_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters/slr_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slr_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slr_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slr_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slr_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slr_received(self):
    self.__slr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  slm_sent = __builtin__.property(_get_slm_sent)
  slm_received = __builtin__.property(_get_slm_received)
  slr_sent = __builtin__.property(_get_slr_sent)
  slr_received = __builtin__.property(_get_slr_received)


  _pyangbind_elements = OrderedDict([('slm_sent', slm_sent), ('slm_received', slm_received), ('slr_sent', slr_sent), ('slr_received', slr_received), ])


class yc_loss_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/state/loss-measurement-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loss measurement state container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__far_end_min_frame_loss_ratio','__far_end_max_frame_loss_ratio','__far_end_average_frame_loss_ratio','__near_end_min_frame_loss_ratio','__near_end_max_frame_loss_ratio','__near_end_average_frame_loss_ratio','__counters',)

  _yang_name = 'loss-measurement-state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__far_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__far_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__far_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'state', 'loss-measurement-state']

  def _get_far_end_min_frame_loss_ratio(self):
    """
    Getter method for far_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_min_frame_loss_ratio (uint32)

    YANG Description: This object contains the minimum one-way availability flr in the
egress direction (source --> destination),
from among the set of availability flr values
calculated by the MEP in this Measurement Interval. There is
one availability flr value for each 'delta_t' time period
within the Measurement Interval, as specified in MEF 10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_min_frame_loss_ratio
      
  def _set_far_end_min_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_min_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_min_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_min_frame_loss_ratio() directly.

    YANG Description: This object contains the minimum one-way availability flr in the
egress direction (source --> destination),
from among the set of availability flr values
calculated by the MEP in this Measurement Interval. There is
one availability flr value for each 'delta_t' time period
within the Measurement Interval, as specified in MEF 10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_min_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_min_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_min_frame_loss_ratio(self):
    self.__far_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_far_end_max_frame_loss_ratio(self):
    """
    Getter method for far_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_max_frame_loss_ratio (uint32)

    YANG Description: This object contains the maximum one-way availability flr in the
forward direction (source --> destination),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_max_frame_loss_ratio
      
  def _set_far_end_max_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_max_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_max_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_max_frame_loss_ratio() directly.

    YANG Description: This object contains the maximum one-way availability flr in the
forward direction (source --> destination),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_max_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_max_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_max_frame_loss_ratio(self):
    self.__far_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_far_end_average_frame_loss_ratio(self):
    """
    Getter method for far_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_average_frame_loss_ratio (uint32)

    YANG Description: This object contains the average one-way availability flr in the
forward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_average_frame_loss_ratio
      
  def _set_far_end_average_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/far_end_average_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_average_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_average_frame_loss_ratio() directly.

    YANG Description: This object contains the average one-way availability flr in the
forward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_average_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_average_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_average_frame_loss_ratio(self):
    self.__far_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_min_frame_loss_ratio(self):
    """
    Getter method for near_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_min_frame_loss_ratio (uint32)

    YANG Description: This object contains the minimum one-way availability flr in the
backward direction (destination --> source),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_min_frame_loss_ratio
      
  def _set_near_end_min_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_min_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_min_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_min_frame_loss_ratio() directly.

    YANG Description: This object contains the minimum one-way availability flr in the
backward direction (destination --> source),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_min_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_min_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_min_frame_loss_ratio(self):
    self.__near_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_max_frame_loss_ratio(self):
    """
    Getter method for near_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_max_frame_loss_ratio (uint32)

    YANG Description: This object contains the maximum one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).
Service OAM Performance Monitoring YANG Module
MEF 39

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_max_frame_loss_ratio
      
  def _set_near_end_max_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_max_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_max_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_max_frame_loss_ratio() directly.

    YANG Description: This object contains the maximum one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).
Service OAM Performance Monitoring YANG Module
MEF 39

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_max_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_max_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_max_frame_loss_ratio(self):
    self.__near_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_average_frame_loss_ratio(self):
    """
    Getter method for near_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_average_frame_loss_ratio (uint32)

    YANG Description: This object contains the average one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_average_frame_loss_ratio
      
  def _set_near_end_average_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/near_end_average_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_average_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_average_frame_loss_ratio() directly.

    YANG Description: This object contains the average one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_average_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_average_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_average_frame_loss_ratio(self):
    self.__near_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters (container)

    YANG Description: A collection of loss-measurement-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of loss-measurement-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  far_end_min_frame_loss_ratio = __builtin__.property(_get_far_end_min_frame_loss_ratio)
  far_end_max_frame_loss_ratio = __builtin__.property(_get_far_end_max_frame_loss_ratio)
  far_end_average_frame_loss_ratio = __builtin__.property(_get_far_end_average_frame_loss_ratio)
  near_end_min_frame_loss_ratio = __builtin__.property(_get_near_end_min_frame_loss_ratio)
  near_end_max_frame_loss_ratio = __builtin__.property(_get_near_end_max_frame_loss_ratio)
  near_end_average_frame_loss_ratio = __builtin__.property(_get_near_end_average_frame_loss_ratio)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('far_end_min_frame_loss_ratio', far_end_min_frame_loss_ratio), ('far_end_max_frame_loss_ratio', far_end_max_frame_loss_ratio), ('far_end_average_frame_loss_ratio', far_end_average_frame_loss_ratio), ('near_end_min_frame_loss_ratio', near_end_min_frame_loss_ratio), ('near_end_max_frame_loss_ratio', near_end_max_frame_loss_ratio), ('near_end_average_frame_loss_ratio', near_end_average_frame_loss_ratio), ('counters', counters), ])


class yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/state/delay-measurement-state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of delay-measurement-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dmm_sent','__dmm_received','__dmr_sent','__dmr_received',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dmm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'state', 'delay-measurement-state', 'counters']

  def _get_dmm_sent(self):
    """
    Getter method for dmm_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmm_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmm_sent
      
  def _set_dmm_sent(self, v, load=False):
    """
    Setter method for dmm_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmm_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmm_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmm_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmm_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmm_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmm_sent(self):
    self.__dmm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmm_received(self):
    """
    Getter method for dmm_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmm_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmm_received
      
  def _set_dmm_received(self, v, load=False):
    """
    Setter method for dmm_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmm_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmm_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmm_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmm_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmm_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmm_received(self):
    self.__dmm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmr_sent(self):
    """
    Getter method for dmr_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmr_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmr_sent
      
  def _set_dmr_sent(self, v, load=False):
    """
    Setter method for dmr_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmr_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmr_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmr_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmr_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmr_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmr_sent(self):
    self.__dmr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmr_received(self):
    """
    Getter method for dmr_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmr_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmr_received
      
  def _set_dmr_received(self, v, load=False):
    """
    Setter method for dmr_received, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters/dmr_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmr_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmr_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmr_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmr_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmr_received(self):
    self.__dmr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  dmm_sent = __builtin__.property(_get_dmm_sent)
  dmm_received = __builtin__.property(_get_dmm_received)
  dmr_sent = __builtin__.property(_get_dmr_sent)
  dmr_received = __builtin__.property(_get_dmr_received)


  _pyangbind_elements = OrderedDict([('dmm_sent', dmm_sent), ('dmm_received', dmm_received), ('dmr_sent', dmr_sent), ('dmr_received', dmr_received), ])


class yc_delay_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/state/delay-measurement-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Delay measurement state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_delay_two_way_min','__frame_delay_two_way_max','__frame_delay_two_way_average','__frame_delay_two_way_stddev','__counters',)

  _yang_name = 'delay-measurement-state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_delay_two_way_min = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_max = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_average = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_stddev = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'state', 'delay-measurement-state']

  def _get_frame_delay_two_way_min(self):
    """
    Getter method for frame_delay_two_way_min, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_min (uint32)

    YANG Description: This object contains the minimum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted
or dm1-received.
    """
    return self.__frame_delay_two_way_min
      
  def _set_frame_delay_two_way_min(self, v, load=False):
    """
    Setter method for frame_delay_two_way_min, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_min (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_min() directly.

    YANG Description: This object contains the minimum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted
or dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_min must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_min(self):
    self.__frame_delay_two_way_min = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_max(self):
    """
    Getter method for frame_delay_two_way_max, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_max (uint32)

    YANG Description: This object contains the maximum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    return self.__frame_delay_two_way_max
      
  def _set_frame_delay_two_way_max(self, v, load=False):
    """
    Setter method for frame_delay_two_way_max, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_max (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_max() directly.

    YANG Description: This object contains the maximum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_max must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_max(self):
    self.__frame_delay_two_way_max = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_average(self):
    """
    Getter method for frame_delay_two_way_average, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_average (uint32)

    YANG Description: This object contains the average two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted or
dm1-received.
    """
    return self.__frame_delay_two_way_average
      
  def _set_frame_delay_two_way_average(self, v, load=False):
    """
    Setter method for frame_delay_two_way_average, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_average (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_average is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_average() directly.

    YANG Description: This object contains the average two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_average must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_average = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_average(self):
    self.__frame_delay_two_way_average = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_stddev(self):
    """
    Getter method for frame_delay_two_way_stddev, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_stddev (uint32)

    YANG Description: This object contains the standard deviation of two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    return self.__frame_delay_two_way_stddev
      
  def _set_frame_delay_two_way_stddev(self, v, load=False):
    """
    Setter method for frame_delay_two_way_stddev, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/frame_delay_two_way_stddev (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_stddev is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_stddev() directly.

    YANG Description: This object contains the standard deviation of two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_stddev must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_stddev = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_stddev(self):
    self.__frame_delay_two_way_stddev = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters (container)

    YANG Description: A collection of delay-measurement-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of delay-measurement-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  frame_delay_two_way_min = __builtin__.property(_get_frame_delay_two_way_min)
  frame_delay_two_way_max = __builtin__.property(_get_frame_delay_two_way_max)
  frame_delay_two_way_average = __builtin__.property(_get_frame_delay_two_way_average)
  frame_delay_two_way_stddev = __builtin__.property(_get_frame_delay_two_way_stddev)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('frame_delay_two_way_min', frame_delay_two_way_min), ('frame_delay_two_way_max', frame_delay_two_way_max), ('frame_delay_two_way_average', frame_delay_two_way_average), ('frame_delay_two_way_stddev', frame_delay_two_way_stddev), ('counters', counters), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational data for loss measurement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__enable','__measurement_type','__protocol_type','__frame_size','__measurement_interval','__repetition_period','__intervals_archived','__packets_per_meaurement_period','__burst_interval','__packet_per_burst','__loss_measurement_state','__delay_measurement_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__loss_measurement_state = YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__delay_measurement_state = YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile', 'state']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/profile_name (string)

    YANG Description: Name of the measurement profile.
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/profile_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Name of the measurement profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/enable (boolean)

    YANG Description: Enable or disable measurement.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable or disable measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_measurement_type(self):
    """
    Getter method for measurement_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/measurement_type (enumeration)

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    return self.__measurement_type
      
  def _set_measurement_type(self, v, load=False):
    """
    Setter method for measurement_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/measurement_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_type() directly.

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__measurement_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_type(self):
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_protocol_type(self):
    """
    Getter method for protocol_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/protocol_type (enumeration)

    YANG Description: protocol type.
    """
    return self.__protocol_type
      
  def _set_protocol_type(self, v, load=False):
    """
    Setter method for protocol_type, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/protocol_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_type() directly.

    YANG Description: protocol type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__protocol_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_type(self):
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_frame_size(self):
    """
    Getter method for frame_size, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/frame_size (uint16)

    YANG Description: Probe Frame size for measurement.
    """
    return self.__frame_size
      
  def _set_frame_size(self, v, load=False):
    """
    Setter method for frame_size, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/frame_size (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_size() directly.

    YANG Description: Probe Frame size for measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_size must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__frame_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_size(self):
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_measurement_interval(self):
    """
    Getter method for measurement_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/measurement_interval (uint32)

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    return self.__measurement_interval
      
  def _set_measurement_interval(self, v, load=False):
    """
    Setter method for measurement_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/measurement_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_interval() directly.

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__measurement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_interval(self):
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_repetition_period(self):
    """
    Getter method for repetition_period, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/repetition_period (uint32)

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    return self.__repetition_period
      
  def _set_repetition_period(self, v, load=False):
    """
    Setter method for repetition_period, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/repetition_period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repetition_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repetition_period() directly.

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repetition_period must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__repetition_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repetition_period(self):
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_intervals_archived(self):
    """
    Getter method for intervals_archived, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/intervals_archived (uint16)

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    return self.__intervals_archived
      
  def _set_intervals_archived(self, v, load=False):
    """
    Setter method for intervals_archived, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/intervals_archived (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intervals_archived is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intervals_archived() directly.

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intervals_archived must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__intervals_archived = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intervals_archived(self):
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_packets_per_meaurement_period(self):
    """
    Getter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/packets_per_meaurement_period (uint16)

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    return self.__packets_per_meaurement_period
      
  def _set_packets_per_meaurement_period(self, v, load=False):
    """
    Setter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/packets_per_meaurement_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets_per_meaurement_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets_per_meaurement_period() directly.

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets_per_meaurement_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__packets_per_meaurement_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets_per_meaurement_period(self):
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_burst_interval(self):
    """
    Getter method for burst_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/burst_interval (uint32)

    YANG Description: Interval between bursts within a measurement interval.
    """
    return self.__burst_interval
      
  def _set_burst_interval(self, v, load=False):
    """
    Setter method for burst_interval, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/burst_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_burst_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_burst_interval() directly.

    YANG Description: Interval between bursts within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """burst_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__burst_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_burst_interval(self):
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_packet_per_burst(self):
    """
    Getter method for packet_per_burst, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/packet_per_burst (uint32)

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    return self.__packet_per_burst
      
  def _set_packet_per_burst(self, v, load=False):
    """
    Setter method for packet_per_burst, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/packet_per_burst (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_per_burst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_per_burst() directly.

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_per_burst must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__packet_per_burst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_per_burst(self):
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_loss_measurement_state(self):
    """
    Getter method for loss_measurement_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state (container)

    YANG Description: Loss measurement state container.
    """
    return self.__loss_measurement_state
      
  def _set_loss_measurement_state(self, v, load=False):
    """
    Setter method for loss_measurement_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/loss_measurement_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loss_measurement_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loss_measurement_state() directly.

    YANG Description: Loss measurement state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loss_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loss_measurement_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__loss_measurement_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loss_measurement_state(self):
    self.__loss_measurement_state = YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_delay_measurement_state(self):
    """
    Getter method for delay_measurement_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state (container)

    YANG Description: Delay measurement state.
    """
    return self.__delay_measurement_state
      
  def _set_delay_measurement_state(self, v, load=False):
    """
    Setter method for delay_measurement_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state/delay_measurement_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_measurement_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_measurement_state() directly.

    YANG Description: Delay measurement state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_delay_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_measurement_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__delay_measurement_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_measurement_state(self):
    self.__delay_measurement_state = YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  profile_name = __builtin__.property(_get_profile_name)
  enable = __builtin__.property(_get_enable)
  measurement_type = __builtin__.property(_get_measurement_type)
  protocol_type = __builtin__.property(_get_protocol_type)
  frame_size = __builtin__.property(_get_frame_size)
  measurement_interval = __builtin__.property(_get_measurement_interval)
  repetition_period = __builtin__.property(_get_repetition_period)
  intervals_archived = __builtin__.property(_get_intervals_archived)
  packets_per_meaurement_period = __builtin__.property(_get_packets_per_meaurement_period)
  burst_interval = __builtin__.property(_get_burst_interval)
  packet_per_burst = __builtin__.property(_get_packet_per_burst)
  loss_measurement_state = __builtin__.property(_get_loss_measurement_state)
  delay_measurement_state = __builtin__.property(_get_delay_measurement_state)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('enable', enable), ('measurement_type', measurement_type), ('protocol_type', protocol_type), ('frame_size', frame_size), ('measurement_interval', measurement_interval), ('repetition_period', repetition_period), ('intervals_archived', intervals_archived), ('packets_per_meaurement_period', packets_per_meaurement_period), ('burst_interval', burst_interval), ('packet_per_burst', packet_per_burst), ('loss_measurement_state', loss_measurement_state), ('delay_measurement_state', delay_measurement_state), ])


class yc_pm_profile_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles/pm-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description:  Measurement profile name and state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__config','__state',)

  _yang_name = 'pm-profile'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles', 'pm-profile']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/profile_name (leafref)

    YANG Description: A unique profile name identifying the profile
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/profile_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: A unique profile name identifying the profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/config (container)

    YANG Description: Associated performance Measurement profile.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Associated performance Measurement profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state (container)

    YANG Description: Operational data for loss measurement.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational data for loss measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('config', config), ('state', state), ])


class yc_pm_profiles_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/pm-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container includes configuration and state objects for the Frame Loss
Measurement & Delay Measurement functions defined in [Y.1731] and [MEF SOAM PM IA].
  """
  __slots__ = ('_path_helper', '_extmethods', '__pm_profile',)

  _yang_name = 'pm-profiles'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__pm_profile = YANGDynClass(base=YANGListType("profile_name",yc_pm_profile_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile, yang_name="pm-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="pm-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'pm-profiles']

  def _get_pm_profile(self):
    """
    Getter method for pm_profile, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile (list)

    YANG Description:  Measurement profile name and state.
    """
    return self.__pm_profile
      
  def _set_pm_profile(self, v, load=False):
    """
    Setter method for pm_profile, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles/pm_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pm_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pm_profile() directly.

    YANG Description:  Measurement profile name and state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile_name",yc_pm_profile_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile, yang_name="pm-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="pm-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pm_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile_name",yc_pm_profile_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile, yang_name="pm-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="pm-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__pm_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pm_profile(self):
    self.__pm_profile = YANGDynClass(base=YANGListType("profile_name",yc_pm_profile_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles_pm_profile, yang_name="pm-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="pm-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  pm_profile = __builtin__.property(_get_pm_profile, _set_pm_profile)


  _pyangbind_elements = OrderedDict([('pm_profile', pm_profile), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/rdi/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: rdi config for a mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transmit_on_defect',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transmit_on_defect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'rdi', 'config']

  def _get_transmit_on_defect(self):
    """
    Getter method for transmit_on_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/config/transmit_on_defect (boolean)

    YANG Description: Transmit RDI when a defect is detected.
    """
    return self.__transmit_on_defect
      
  def _set_transmit_on_defect(self, v, load=False):
    """
    Setter method for transmit_on_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/config/transmit_on_defect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_on_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_on_defect() directly.

    YANG Description: Transmit RDI when a defect is detected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_on_defect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__transmit_on_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_on_defect(self):
    self.__transmit_on_defect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)

  transmit_on_defect = __builtin__.property(_get_transmit_on_defect, _set_transmit_on_defect)


  _pyangbind_elements = OrderedDict([('transmit_on_defect', transmit_on_defect), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/rdi/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: rdi state for a mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transmit_on_defect',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transmit_on_defect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'rdi', 'state']

  def _get_transmit_on_defect(self):
    """
    Getter method for transmit_on_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/state/transmit_on_defect (boolean)

    YANG Description: Transmit RDI when a defect is detected.
    """
    return self.__transmit_on_defect
      
  def _set_transmit_on_defect(self, v, load=False):
    """
    Setter method for transmit_on_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/state/transmit_on_defect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_on_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_on_defect() directly.

    YANG Description: Transmit RDI when a defect is detected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_on_defect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__transmit_on_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_on_defect(self):
    self.__transmit_on_defect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transmit-on-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)

  transmit_on_defect = __builtin__.property(_get_transmit_on_defect)


  _pyangbind_elements = OrderedDict([('transmit_on_defect', transmit_on_defect), ])


class yc_rdi_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/rdi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: rdi config for a mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'rdi'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'rdi']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/config (container)

    YANG Description: rdi config for a mep.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: rdi config for a mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/state (container)

    YANG Description: rdi state for a mep.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: rdi state for a mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/link-loss-forwarding/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable propagation of the remote
attachment-circuit link state to the
localattachment-circuit link state
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__damping_timer','__action',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__damping_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=True)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'link-loss-forwarding', 'config']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/enable (boolean)

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
local attachment-circuit link state
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
local attachment-circuit link state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_damping_timer(self):
    """
    Getter method for damping_timer, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/damping_timer (uint64)

    YANG Description: The damping timer is the amount of time that the local
attachment-circuit link state will be held in the down state
after the remote attachment-circuit link state has been
detected to be up. The damping timer is used to prevent
flapping of the local attachment-circuit link state.
    """
    return self.__damping_timer
      
  def _set_damping_timer(self, v, load=False):
    """
    Setter method for damping_timer, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/damping_timer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damping_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damping_timer() directly.

    YANG Description: The damping timer is the amount of time that the local
attachment-circuit link state will be held in the down state
after the remote attachment-circuit link state has been
detected to be up. The damping timer is used to prevent
flapping of the local attachment-circuit link state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damping_timer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=True)""",
        })

    self.__damping_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damping_timer(self):
    self.__damping_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/action (enumeration)

    YANG Description: Action to take on link loss.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Action to take on link loss.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  damping_timer = __builtin__.property(_get_damping_timer, _set_damping_timer)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('enable', enable), ('damping_timer', damping_timer), ('action', action), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/link-loss-forwarding/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: link loss forwarding state for a mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__damping_timer','__action',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__damping_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=False)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'link-loss-forwarding', 'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/enable (boolean)

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
local attachment-circuit link state
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
local attachment-circuit link state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_damping_timer(self):
    """
    Getter method for damping_timer, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/damping_timer (uint64)

    YANG Description: The damping timer is the amount of time that the local
attachment-circuit link state will be held in the down state
after the remote attachment-circuit link state has been
detected to be up. The damping timer is used to prevent
flapping of the local attachment-circuit link state.
    """
    return self.__damping_timer
      
  def _set_damping_timer(self, v, load=False):
    """
    Setter method for damping_timer, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/damping_timer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damping_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damping_timer() directly.

    YANG Description: The damping timer is the amount of time that the local
attachment-circuit link state will be held in the down state
after the remote attachment-circuit link state has been
detected to be up. The damping timer is used to prevent
flapping of the local attachment-circuit link state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damping_timer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=False)""",
        })

    self.__damping_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damping_timer(self):
    self.__damping_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="damping-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint64', is_config=False)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/action (enumeration)

    YANG Description: Action to take on link loss.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Action to take on link loss.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SHUTDOWN': {}, 'ALARM': {}, 'DISABLE_ROUTING': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)

  enable = __builtin__.property(_get_enable)
  damping_timer = __builtin__.property(_get_damping_timer)
  action = __builtin__.property(_get_action)


  _pyangbind_elements = OrderedDict([('enable', enable), ('damping_timer', damping_timer), ('action', action), ])


class yc_link_loss_forwarding_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/link-loss-forwarding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: link loss forwarding config for a mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'link-loss-forwarding'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'link-loss-forwarding']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config (container)

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
localattachment-circuit link state
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Enable propagation of the remote
attachment-circuit link state to the
localattachment-circuit link state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state (container)

    YANG Description: link loss forwarding state for a mep.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: link loss forwarding state for a mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/remote-meps/remote-mep/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for a remote mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__mac_address',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'remote-meps', 'remote-mep', 'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config/id (oc-cfm-types:mep-id-type)

    YANG Description: Remote MEP IDs in full mesh.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config/id (oc-cfm-types:mep-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Remote MEP IDs in full mesh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-cfm-types:mep-id-type""",
          'defined-type': "oc-cfm-types:mep-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config/mac_address (oc-yang:mac-address)

    YANG Description: Remote MEP IDs in full mesh.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config/mac_address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Remote MEP IDs in full mesh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)


  _pyangbind_elements = OrderedDict([('id', id), ('mac_address', mac_address), ])


class yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/remote-meps/remote-mep/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of mep-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mep_ccm_sequence_errors','__mep_ccms_sent',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mep_ccm_sequence_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__mep_ccms_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'remote-meps', 'remote-mep', 'state', 'counters']

  def _get_mep_ccm_sequence_errors(self):
    """
    Getter method for mep_ccm_sequence_errors, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters/mep_ccm_sequence_errors (oc-yang:counter64)

    YANG Description: The total number of out-of-sequence CCMs received from
all remote MEPs.
    """
    return self.__mep_ccm_sequence_errors
      
  def _set_mep_ccm_sequence_errors(self, v, load=False):
    """
    Setter method for mep_ccm_sequence_errors, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters/mep_ccm_sequence_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_ccm_sequence_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_ccm_sequence_errors() directly.

    YANG Description: The total number of out-of-sequence CCMs received from
all remote MEPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_ccm_sequence_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mep_ccm_sequence_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_ccm_sequence_errors(self):
    self.__mep_ccm_sequence_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccm-sequence-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_mep_ccms_sent(self):
    """
    Getter method for mep_ccms_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters/mep_ccms_sent (oc-yang:counter64)

    YANG Description: Total number of CCMs transmitted by the local MEP
    """
    return self.__mep_ccms_sent
      
  def _set_mep_ccms_sent(self, v, load=False):
    """
    Setter method for mep_ccms_sent, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters/mep_ccms_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_ccms_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_ccms_sent() directly.

    YANG Description: Total number of CCMs transmitted by the local MEP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_ccms_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mep_ccms_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_ccms_sent(self):
    self.__mep_ccms_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mep-ccms-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  mep_ccm_sequence_errors = __builtin__.property(_get_mep_ccm_sequence_errors)
  mep_ccms_sent = __builtin__.property(_get_mep_ccms_sent)


  _pyangbind_elements = OrderedDict([('mep_ccm_sequence_errors', mep_ccm_sequence_errors), ('mep_ccms_sent', mep_ccms_sent), ])


class yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/remote-meps/remote-mep/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational data for a remote mep.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__mac_address','__oper_state','__interface_state','__fng_state','__highest_priority_defect','__mep_defects','__present_rdi','__config_errors_detected','__error_ccm_last_failure','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)
    self.__oper_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)
    self.__interface_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)
    self.__fng_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)
    self.__highest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)
    self.__mep_defects = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)
    self.__present_rdi = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__config_errors_detected = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)
    self.__error_ccm_last_failure = YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'remote-meps', 'remote-mep', 'state']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/id (oc-cfm-types:mep-id-type)

    YANG Description: Remote MEP IDs in full mesh.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/id (oc-cfm-types:mep-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Remote MEP IDs in full mesh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-cfm-types:mep-id-type""",
          'defined-type': "oc-cfm-types:mep-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..8191']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-id-type', is_config=False)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/mac_address (oc-yang:mac-address)

    YANG Description: Remote MEP IDs in full mesh.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/mac_address (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Remote MEP IDs in full mesh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:mac-address', is_config=False)


  def _get_oper_state(self):
    """
    Getter method for oper_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/oper_state (oc-cfm-types:operational-state-type)

    YANG Description: Operational state of the MEP.
    """
    return self.__oper_state
      
  def _set_oper_state(self, v, load=False):
    """
    Setter method for oper_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/oper_state (oc-cfm-types:operational-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_state() directly.

    YANG Description: Operational state of the MEP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_state must be of a type compatible with oc-cfm-types:operational-state-type""",
          'defined-type': "oc-cfm-types:operational-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)""",
        })

    self.__oper_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_state(self):
    self.__oper_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ENABLED': {}, 'DISABLED': {}, 'UNKNOWN': {}},), is_leaf=True, yang_name="oper-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:operational-state-type', is_config=False)


  def _get_interface_state(self):
    """
    Getter method for interface_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/interface_state (oc-cfm-types:interface-status-type)

    YANG Description: The state of the interface last reported by the local MEP in the TLV.
    """
    return self.__interface_state
      
  def _set_interface_state(self, v, load=False):
    """
    Setter method for interface_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/interface_state (oc-cfm-types:interface-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_state() directly.

    YANG Description: The state of the interface last reported by the local MEP in the TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_state must be of a type compatible with oc-cfm-types:interface-status-type""",
          'defined-type': "oc-cfm-types:interface-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)""",
        })

    self.__interface_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_state(self):
    self.__interface_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NO_STATUS_TLV': {}, 'UP': {}, 'DOWN': {}, 'TESTING': {}, 'UNKNOWN': {}, 'DORMANT': {}, 'NOT_PRESENT': {}, 'LOWER_LAYER_DOWN': {}},), is_leaf=True, yang_name="interface-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:interface-status-type', is_config=False)


  def _get_fng_state(self):
    """
    Getter method for fng_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/fng_state (oc-cfm-types:fng-state-type)

    YANG Description: The current state of the MEP Fault Notification Generator
state machine.
    """
    return self.__fng_state
      
  def _set_fng_state(self, v, load=False):
    """
    Setter method for fng_state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/fng_state (oc-cfm-types:fng-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fng_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fng_state() directly.

    YANG Description: The current state of the MEP Fault Notification Generator
state machine.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fng_state must be of a type compatible with oc-cfm-types:fng-state-type""",
          'defined-type': "oc-cfm-types:fng-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)""",
        })

    self.__fng_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fng_state(self):
    self.__fng_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FNG_RESET': {'value': 1}, 'FNG_DEFECT': {'value': 2}, 'FNG_REPORT_DEFECT': {'value': 3}, 'FNG_DEFECT_REPORTED': {'value': 4}, 'FNG_DEFECT_CLEARING': {'value': 5}},), default=str("FNG_RESET"), is_leaf=True, yang_name="fng-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:fng-state-type', is_config=False)


  def _get_highest_priority_defect(self):
    """
    Getter method for highest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/highest_priority_defect (oc-cfm-types:highest-defect-priority-type)

    YANG Description: The highest priority defect that has been present since
the MEPs Fault Notification Generator state machine was
last in the FNG_RESET state.
    """
    return self.__highest_priority_defect
      
  def _set_highest_priority_defect(self, v, load=False):
    """
    Setter method for highest_priority_defect, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/highest_priority_defect (oc-cfm-types:highest-defect-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_highest_priority_defect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_highest_priority_defect() directly.

    YANG Description: The highest priority defect that has been present since
the MEPs Fault Notification Generator state machine was
last in the FNG_RESET state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """highest_priority_defect must be of a type compatible with oc-cfm-types:highest-defect-priority-type""",
          'defined-type': "oc-cfm-types:highest-defect-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)""",
        })

    self.__highest_priority_defect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_highest_priority_defect(self):
    self.__highest_priority_defect = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {'value': 0}, 'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},), is_leaf=True, yang_name="highest-priority-defect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:highest-defect-priority-type', is_config=False)


  def _get_mep_defects(self):
    """
    Getter method for mep_defects, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/mep_defects (oc-cfm-types:mep-defects-type)

    YANG Description: Vector of boolean error conditions.
Multiple defects can be present at the same time.
    """
    return self.__mep_defects
      
  def _set_mep_defects(self, v, load=False):
    """
    Setter method for mep_defects, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/mep_defects (oc-cfm-types:mep-defects-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_defects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_defects() directly.

    YANG Description: Vector of boolean error conditions.
Multiple defects can be present at the same time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_defects must be of a type compatible with oc-cfm-types:mep-defects-type""",
          'defined-type': "oc-cfm-types:mep-defects-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)""",
        })

    self.__mep_defects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_defects(self):
    self.__mep_defects = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEF_RDI_CCM': {'value': 1}, 'DEF_MAC_STATUS': {'value': 2}, 'DEF_REMOTE_CCM': {'value': 3}, 'DEF_ERROR_CCM': {'value': 4}, 'DEF_XCON_CCM': {'value': 5}},)), is_leaf=False, yang_name="mep-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:mep-defects-type', is_config=False)


  def _get_present_rdi(self):
    """
    Getter method for present_rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/present_rdi (boolean)

    YANG Description: A boolean value indicating the state of the RDI bit in CCMs
transmitted by this MEP. present-rdi is true if and only if one or more
of the variables someRMEPCCMdefect, someMACstatusDefect, errorCCMdefect,
or xconCCMdefect is true, and if the corresponding priority of that
variable, from mep-defects above, is greater than or equal to the
value of the variable lowestAlarmPri.
    """
    return self.__present_rdi
      
  def _set_present_rdi(self, v, load=False):
    """
    Setter method for present_rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/present_rdi (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_present_rdi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_present_rdi() directly.

    YANG Description: A boolean value indicating the state of the RDI bit in CCMs
transmitted by this MEP. present-rdi is true if and only if one or more
of the variables someRMEPCCMdefect, someMACstatusDefect, errorCCMdefect,
or xconCCMdefect is true, and if the corresponding priority of that
variable, from mep-defects above, is greater than or equal to the
value of the variable lowestAlarmPri.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """present_rdi must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__present_rdi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_present_rdi(self):
    self.__present_rdi = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="present-rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_config_errors_detected(self):
    """
    Getter method for config_errors_detected, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/config_errors_detected (oc-cfm-types:config-error-type)

    YANG Description: Vector of enums of config error detected. i.e. [cfm-leak]
    """
    return self.__config_errors_detected
      
  def _set_config_errors_detected(self, v, load=False):
    """
    Setter method for config_errors_detected, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/config_errors_detected (oc-cfm-types:config-error-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_errors_detected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_errors_detected() directly.

    YANG Description: Vector of enums of config error detected. i.e. [cfm-leak]
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_errors_detected must be of a type compatible with oc-cfm-types:config-error-type""",
          'defined-type': "oc-cfm-types:config-error-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)""",
        })

    self.__config_errors_detected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_errors_detected(self):
    self.__config_errors_detected = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'CFM_LEAK': {}, 'CONFLICTING_VIDS': {}, 'EXCESSIVE_LEVELS': {}, 'OVERLAPPED_LEVELS': {}},)), is_leaf=False, yang_name="config-errors-detected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-cfm-types:config-error-type', is_config=False)


  def _get_error_ccm_last_failure(self):
    """
    Getter method for error_ccm_last_failure, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/error_ccm_last_failure (binary)

    YANG Description: The last received CCM that triggered a def-error-ccm
 fault.
    """
    return self.__error_ccm_last_failure
      
  def _set_error_ccm_last_failure(self, v, load=False):
    """
    Setter method for error_ccm_last_failure, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/error_ccm_last_failure (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_ccm_last_failure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_ccm_last_failure() directly.

    YANG Description: The last received CCM that triggered a def-error-ccm
 fault.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_ccm_last_failure must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)""",
        })

    self.__error_ccm_last_failure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_ccm_last_failure(self):
    self.__error_ccm_last_failure = YANGDynClass(base=RestrictedClassType(base_type=YANGBinary, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="error-ccm-last-failure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='binary', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters (container)

    YANG Description: A collection of mep-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of mep-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id)
  mac_address = __builtin__.property(_get_mac_address)
  oper_state = __builtin__.property(_get_oper_state)
  interface_state = __builtin__.property(_get_interface_state)
  fng_state = __builtin__.property(_get_fng_state)
  highest_priority_defect = __builtin__.property(_get_highest_priority_defect)
  mep_defects = __builtin__.property(_get_mep_defects)
  present_rdi = __builtin__.property(_get_present_rdi)
  config_errors_detected = __builtin__.property(_get_config_errors_detected)
  error_ccm_last_failure = __builtin__.property(_get_error_ccm_last_failure)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('id', id), ('mac_address', mac_address), ('oper_state', oper_state), ('interface_state', interface_state), ('fng_state', fng_state), ('highest_priority_defect', highest_priority_defect), ('mep_defects', mep_defects), ('present_rdi', present_rdi), ('config_errors_detected', config_errors_detected), ('error_ccm_last_failure', error_ccm_last_failure), ('counters', counters), ])


class yc_remote_mep_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/remote-meps/remote-mep. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Remote meps associated to a local mep
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__config','__state',)

  _yang_name = 'remote-mep'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'remote-meps', 'remote-mep']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/id (leafref)

    YANG Description: Remote mep id.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Remote mep id.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config (container)

    YANG Description: Configuration data for a remote mep.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for a remote mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state (container)

    YANG Description: Operational data for a remote mep.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational data for a remote mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id, _set_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('id', id), ('config', config), ('state', state), ])


class yc_remote_meps_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint/remote-meps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Remote meps associated to a local mep
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_mep',)

  _yang_name = 'remote-meps'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_mep = YANGDynClass(base=YANGListType("id",yc_remote_mep_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep, yang_name="remote-mep", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="remote-mep", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint', 'remote-meps']

  def _get_remote_mep(self):
    """
    Getter method for remote_mep, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep (list)

    YANG Description: Remote meps associated to a local mep
    """
    return self.__remote_mep
      
  def _set_remote_mep(self, v, load=False):
    """
    Setter method for remote_mep, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps/remote_mep (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_mep is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_mep() directly.

    YANG Description: Remote meps associated to a local mep
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_remote_mep_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep, yang_name="remote-mep", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="remote-mep", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_mep must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_remote_mep_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep, yang_name="remote-mep", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="remote-mep", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__remote_mep = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_mep(self):
    self.__remote_mep = YANGDynClass(base=YANGListType("id",yc_remote_mep_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps_remote_mep, yang_name="remote-mep", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="remote-mep", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  remote_mep = __builtin__.property(_get_remote_mep, _set_remote_mep)


  _pyangbind_elements = OrderedDict([('remote_mep', remote_mep), ])


class yc_mep_endpoint_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints/mep-endpoint. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: collection of full mesh MEPs under the maintenance association.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_mep_id','__config','__state','__pm_profiles','__rdi','__link_loss_forwarding','__remote_meps',)

  _yang_name = 'mep-endpoint'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_mep_id = YANGDynClass(base=str, is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__pm_profiles = YANGDynClass(base=yc_pm_profiles_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles, is_container='container', yang_name="pm-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__rdi = YANGDynClass(base=yc_rdi_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi, is_container='container', yang_name="rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__link_loss_forwarding = YANGDynClass(base=yc_link_loss_forwarding_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding, is_container='container', yang_name="link-loss-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__remote_meps = YANGDynClass(base=yc_remote_meps_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps, is_container='container', yang_name="remote-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints', 'mep-endpoint']

  def _get_local_mep_id(self):
    """
    Getter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/local_mep_id (leafref)

    YANG Description: Local MEP identifier.
    """
    return self.__local_mep_id
      
  def _set_local_mep_id(self, v, load=False):
    """
    Setter method for local_mep_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/local_mep_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_mep_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_mep_id() directly.

    YANG Description: Local MEP identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_mep_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__local_mep_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_mep_id(self):
    self.__local_mep_id = YANGDynClass(base=str, is_leaf=True, yang_name="local-mep-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config (container)

    YANG Description: Configuration data for a MEP.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for a MEP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state (container)

    YANG Description:  Operational tate data for a MEP.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description:  Operational tate data for a MEP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_pm_profiles(self):
    """
    Getter method for pm_profiles, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles (container)

    YANG Description: This container includes configuration and state objects for the Frame Loss
Measurement & Delay Measurement functions defined in [Y.1731] and [MEF SOAM PM IA].
    """
    return self.__pm_profiles
      
  def _set_pm_profiles(self, v, load=False):
    """
    Setter method for pm_profiles, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/pm_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pm_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pm_profiles() directly.

    YANG Description: This container includes configuration and state objects for the Frame Loss
Measurement & Delay Measurement functions defined in [Y.1731] and [MEF SOAM PM IA].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pm_profiles_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles, is_container='container', yang_name="pm-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pm_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pm_profiles_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles, is_container='container', yang_name="pm-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__pm_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pm_profiles(self):
    self.__pm_profiles = YANGDynClass(base=yc_pm_profiles_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_pm_profiles, is_container='container', yang_name="pm-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_rdi(self):
    """
    Getter method for rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi (container)

    YANG Description: rdi config for a mep.
    """
    return self.__rdi
      
  def _set_rdi(self, v, load=False):
    """
    Setter method for rdi, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/rdi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdi() directly.

    YANG Description: rdi config for a mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rdi_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi, is_container='container', yang_name="rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rdi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rdi_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi, is_container='container', yang_name="rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__rdi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rdi(self):
    self.__rdi = YANGDynClass(base=yc_rdi_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_rdi, is_container='container', yang_name="rdi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_link_loss_forwarding(self):
    """
    Getter method for link_loss_forwarding, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding (container)

    YANG Description: link loss forwarding config for a mep.
    """
    return self.__link_loss_forwarding
      
  def _set_link_loss_forwarding(self, v, load=False):
    """
    Setter method for link_loss_forwarding, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/link_loss_forwarding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_loss_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_loss_forwarding() directly.

    YANG Description: link loss forwarding config for a mep.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_link_loss_forwarding_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding, is_container='container', yang_name="link-loss-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_loss_forwarding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_link_loss_forwarding_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding, is_container='container', yang_name="link-loss-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__link_loss_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_loss_forwarding(self):
    self.__link_loss_forwarding = YANGDynClass(base=yc_link_loss_forwarding_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_link_loss_forwarding, is_container='container', yang_name="link-loss-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_remote_meps(self):
    """
    Getter method for remote_meps, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps (container)

    YANG Description: Remote meps associated to a local mep
    """
    return self.__remote_meps
      
  def _set_remote_meps(self, v, load=False):
    """
    Setter method for remote_meps, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint/remote_meps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_meps() directly.

    YANG Description: Remote meps associated to a local mep
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_meps_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps, is_container='container', yang_name="remote-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_meps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_meps_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps, is_container='container', yang_name="remote-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__remote_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_meps(self):
    self.__remote_meps = YANGDynClass(base=yc_remote_meps_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint_remote_meps, is_container='container', yang_name="remote-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

  local_mep_id = __builtin__.property(_get_local_mep_id, _set_local_mep_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  pm_profiles = __builtin__.property(_get_pm_profiles, _set_pm_profiles)
  rdi = __builtin__.property(_get_rdi, _set_rdi)
  link_loss_forwarding = __builtin__.property(_get_link_loss_forwarding, _set_link_loss_forwarding)
  remote_meps = __builtin__.property(_get_remote_meps, _set_remote_meps)


  _pyangbind_elements = OrderedDict([('local_mep_id', local_mep_id), ('config', config), ('state', state), ('pm_profiles', pm_profiles), ('rdi', rdi), ('link_loss_forwarding', link_loss_forwarding), ('remote_meps', remote_meps), ])


class yc_mep_endpoints_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association/mep-endpoints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for full mesh MEPs under the maintenance association.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mep_endpoint',)

  _yang_name = 'mep-endpoints'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mep_endpoint = YANGDynClass(base=YANGListType("local_mep_id",yc_mep_endpoint_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint, yang_name="mep-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='local-mep-id', extensions=None), is_container='list', yang_name="mep-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association', 'mep-endpoints']

  def _get_mep_endpoint(self):
    """
    Getter method for mep_endpoint, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint (list)

    YANG Description: collection of full mesh MEPs under the maintenance association.
    """
    return self.__mep_endpoint
      
  def _set_mep_endpoint(self, v, load=False):
    """
    Setter method for mep_endpoint, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints/mep_endpoint (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_endpoint() directly.

    YANG Description: collection of full mesh MEPs under the maintenance association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("local_mep_id",yc_mep_endpoint_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint, yang_name="mep-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='local-mep-id', extensions=None), is_container='list', yang_name="mep-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_endpoint must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("local_mep_id",yc_mep_endpoint_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint, yang_name="mep-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='local-mep-id', extensions=None), is_container='list', yang_name="mep-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__mep_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_endpoint(self):
    self.__mep_endpoint = YANGDynClass(base=YANGListType("local_mep_id",yc_mep_endpoint_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints_mep_endpoint, yang_name="mep-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='local-mep-id', extensions=None), is_container='list', yang_name="mep-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  mep_endpoint = __builtin__.property(_get_mep_endpoint, _set_mep_endpoint)


  _pyangbind_elements = OrderedDict([('mep_endpoint', mep_endpoint), ])


class yc_maintenance_association_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations/maintenance-association. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Collection of maintenance associations within a maintenance domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ma_id','__config','__state','__mep_endpoints',)

  _yang_name = 'maintenance-association'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ma_id = YANGDynClass(base=str, is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__mep_endpoints = YANGDynClass(base=yc_mep_endpoints_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints, is_container='container', yang_name="mep-endpoints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations', 'maintenance-association']

  def _get_ma_id(self):
    """
    Getter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/ma_id (leafref)

    YANG Description: Key of the Maintenance Association list of entries.
    """
    return self.__ma_id
      
  def _set_ma_id(self, v, load=False):
    """
    Setter method for ma_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/ma_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ma_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ma_id() directly.

    YANG Description: Key of the Maintenance Association list of entries.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ma_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__ma_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ma_id(self):
    self.__ma_id = YANGDynClass(base=str, is_leaf=True, yang_name="ma-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config (container)

    YANG Description: Configuration data for a maintenance association.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for a maintenance association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state (container)

    YANG Description: Operational data for a maintenance association.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational data for a maintenance association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_mep_endpoints(self):
    """
    Getter method for mep_endpoints, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints (container)

    YANG Description: Container for full mesh MEPs under the maintenance association.
    """
    return self.__mep_endpoints
      
  def _set_mep_endpoints(self, v, load=False):
    """
    Setter method for mep_endpoints, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association/mep_endpoints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mep_endpoints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mep_endpoints() directly.

    YANG Description: Container for full mesh MEPs under the maintenance association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mep_endpoints_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints, is_container='container', yang_name="mep-endpoints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mep_endpoints must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mep_endpoints_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints, is_container='container', yang_name="mep-endpoints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__mep_endpoints = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mep_endpoints(self):
    self.__mep_endpoints = YANGDynClass(base=yc_mep_endpoints_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association_mep_endpoints, is_container='container', yang_name="mep-endpoints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

  ma_id = __builtin__.property(_get_ma_id, _set_ma_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  mep_endpoints = __builtin__.property(_get_mep_endpoints, _set_mep_endpoints)


  _pyangbind_elements = OrderedDict([('ma_id', ma_id), ('config', config), ('state', state), ('mep_endpoints', mep_endpoints), ])


class yc_maintenance_associations_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain/maintenance-associations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Collection of maintenance associations within a
maintenance domain.Provides configuration and operational data
for the Maintenance Associations. A Maintenance Association is a set
of MEPs, each configured with the same MAID and MD level,
established to verify the integrity of a single service
instance. A Maintenance Association can be thought of as a
full mesh of Maintenance Entities among a set of MEPs so
configured.
  """
  __slots__ = ('_path_helper', '_extmethods', '__maintenance_association',)

  _yang_name = 'maintenance-associations'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maintenance_association = YANGDynClass(base=YANGListType("ma_id",yc_maintenance_association_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association, yang_name="maintenance-association", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ma-id', extensions=None), is_container='list', yang_name="maintenance-association", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain', 'maintenance-associations']

  def _get_maintenance_association(self):
    """
    Getter method for maintenance_association, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association (list)

    YANG Description: Collection of maintenance associations within a maintenance domain.
    """
    return self.__maintenance_association
      
  def _set_maintenance_association(self, v, load=False):
    """
    Setter method for maintenance_association, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations/maintenance_association (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maintenance_association is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maintenance_association() directly.

    YANG Description: Collection of maintenance associations within a maintenance domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ma_id",yc_maintenance_association_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association, yang_name="maintenance-association", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ma-id', extensions=None), is_container='list', yang_name="maintenance-association", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maintenance_association must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ma_id",yc_maintenance_association_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association, yang_name="maintenance-association", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ma-id', extensions=None), is_container='list', yang_name="maintenance-association", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__maintenance_association = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maintenance_association(self):
    self.__maintenance_association = YANGDynClass(base=YANGListType("ma_id",yc_maintenance_association_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations_maintenance_association, yang_name="maintenance-association", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ma-id', extensions=None), is_container='list', yang_name="maintenance-association", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  maintenance_association = __builtin__.property(_get_maintenance_association, _set_maintenance_association)


  _pyangbind_elements = OrderedDict([('maintenance_association', maintenance_association), ])


class yc_maintenance_domain_openconfig_oam__oam_cfm_domains_maintenance_domain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains/maintenance-domain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Maintenance Domain managed object is required in order to create
an MA with a MAID that includes that Maintenance Domains Name. From
this Maintenance Domain managed object, all Maintenance
Association managed objects associated with that Maintenance
Domain managed object can be accessed, and thus controlled.
  """
  __slots__ = ('_path_helper', '_extmethods', '__md_id','__config','__state','__maintenance_associations',)

  _yang_name = 'maintenance-domain'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__md_id = YANGDynClass(base=str, is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__maintenance_associations = YANGDynClass(base=yc_maintenance_associations_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations, is_container='container', yang_name="maintenance-associations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains', 'maintenance-domain']

  def _get_md_id(self):
    """
    Getter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/md_id (leafref)

    YANG Description: A unique maintenance domain name identifying the domain
    """
    return self.__md_id
      
  def _set_md_id(self, v, load=False):
    """
    Setter method for md_id, mapped from YANG variable /oam/cfm/domains/maintenance_domain/md_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md_id() directly.

    YANG Description: A unique maintenance domain name identifying the domain
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__md_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md_id(self):
    self.__md_id = YANGDynClass(base=str, is_leaf=True, yang_name="md-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config (container)

    YANG Description: Configuration data for a maintenance domain.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/domains/maintenance_domain/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for a maintenance domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_domains_maintenance_domain_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state (container)

    YANG Description: Operational data for a maintenance domain.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/domains/maintenance_domain/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational data for a maintenance domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_domains_maintenance_domain_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_maintenance_associations(self):
    """
    Getter method for maintenance_associations, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations (container)

    YANG Description: Collection of maintenance associations within a
maintenance domain.Provides configuration and operational data
for the Maintenance Associations. A Maintenance Association is a set
of MEPs, each configured with the same MAID and MD level,
established to verify the integrity of a single service
instance. A Maintenance Association can be thought of as a
full mesh of Maintenance Entities among a set of MEPs so
configured.
    """
    return self.__maintenance_associations
      
  def _set_maintenance_associations(self, v, load=False):
    """
    Setter method for maintenance_associations, mapped from YANG variable /oam/cfm/domains/maintenance_domain/maintenance_associations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maintenance_associations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maintenance_associations() directly.

    YANG Description: Collection of maintenance associations within a
maintenance domain.Provides configuration and operational data
for the Maintenance Associations. A Maintenance Association is a set
of MEPs, each configured with the same MAID and MD level,
established to verify the integrity of a single service
instance. A Maintenance Association can be thought of as a
full mesh of Maintenance Entities among a set of MEPs so
configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_maintenance_associations_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations, is_container='container', yang_name="maintenance-associations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maintenance_associations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_maintenance_associations_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations, is_container='container', yang_name="maintenance-associations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__maintenance_associations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maintenance_associations(self):
    self.__maintenance_associations = YANGDynClass(base=yc_maintenance_associations_openconfig_oam__oam_cfm_domains_maintenance_domain_maintenance_associations, is_container='container', yang_name="maintenance-associations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

  md_id = __builtin__.property(_get_md_id, _set_md_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  maintenance_associations = __builtin__.property(_get_maintenance_associations, _set_maintenance_associations)


  _pyangbind_elements = OrderedDict([('md_id', md_id), ('config', config), ('state', state), ('maintenance_associations', maintenance_associations), ])


class yc_domains_openconfig_oam__oam_cfm_domains(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/domains. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Container for CFM maintenance domain state and Configuration
on the local system
  """
  __slots__ = ('_path_helper', '_extmethods', '__maintenance_domain',)

  _yang_name = 'domains'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maintenance_domain = YANGDynClass(base=YANGListType("md_id",yc_maintenance_domain_openconfig_oam__oam_cfm_domains_maintenance_domain, yang_name="maintenance-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='md-id', extensions=None), is_container='list', yang_name="maintenance-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'domains']

  def _get_maintenance_domain(self):
    """
    Getter method for maintenance_domain, mapped from YANG variable /oam/cfm/domains/maintenance_domain (list)

    YANG Description: A Maintenance Domain managed object is required in order to create
an MA with a MAID that includes that Maintenance Domains Name. From
this Maintenance Domain managed object, all Maintenance
Association managed objects associated with that Maintenance
Domain managed object can be accessed, and thus controlled.
    """
    return self.__maintenance_domain
      
  def _set_maintenance_domain(self, v, load=False):
    """
    Setter method for maintenance_domain, mapped from YANG variable /oam/cfm/domains/maintenance_domain (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maintenance_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maintenance_domain() directly.

    YANG Description: A Maintenance Domain managed object is required in order to create
an MA with a MAID that includes that Maintenance Domains Name. From
this Maintenance Domain managed object, all Maintenance
Association managed objects associated with that Maintenance
Domain managed object can be accessed, and thus controlled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("md_id",yc_maintenance_domain_openconfig_oam__oam_cfm_domains_maintenance_domain, yang_name="maintenance-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='md-id', extensions=None), is_container='list', yang_name="maintenance-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maintenance_domain must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("md_id",yc_maintenance_domain_openconfig_oam__oam_cfm_domains_maintenance_domain, yang_name="maintenance-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='md-id', extensions=None), is_container='list', yang_name="maintenance-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__maintenance_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maintenance_domain(self):
    self.__maintenance_domain = YANGDynClass(base=YANGListType("md_id",yc_maintenance_domain_openconfig_oam__oam_cfm_domains_maintenance_domain, yang_name="maintenance-domain", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='md-id', extensions=None), is_container='list', yang_name="maintenance-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  maintenance_domain = __builtin__.property(_get_maintenance_domain, _set_maintenance_domain)


  _pyangbind_elements = OrderedDict([('maintenance_domain', maintenance_domain), ])


class yc_state_openconfig_oam__oam_cfm_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational data for CFM.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_meps','__local_meps_operational','__cfm_domains','__cfm_services','__down_meps','__up_meps','__disabled_misconfigured','__disabled_operational_errors','__disabled_out_of_resources','__peer_meps','__operational_peer_meps','__peer_meps_with_defects','__peer_meps_timed_out',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__local_meps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__cfm_domains = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__cfm_services = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__down_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="down-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__up_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__disabled_misconfigured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-misconfigured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__disabled_operational_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-operational-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__disabled_out_of_resources = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-out-of-resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__peer_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__operational_peer_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="operational-peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__peer_meps_with_defects = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-with-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__peer_meps_timed_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-timed-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'state']

  def _get_local_meps(self):
    """
    Getter method for local_meps, mapped from YANG variable /oam/cfm/state/local_meps (uint32)

    YANG Description: The total number of local-meps configured on the local system.
    """
    return self.__local_meps
      
  def _set_local_meps(self, v, load=False):
    """
    Setter method for local_meps, mapped from YANG variable /oam/cfm/state/local_meps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_meps() directly.

    YANG Description: The total number of local-meps configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_meps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__local_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_meps(self):
    self.__local_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_local_meps_operational(self):
    """
    Getter method for local_meps_operational, mapped from YANG variable /oam/cfm/state/local_meps_operational (uint32)

    YANG Description: The total number of local-meps operational on the local system.
    """
    return self.__local_meps_operational
      
  def _set_local_meps_operational(self, v, load=False):
    """
    Setter method for local_meps_operational, mapped from YANG variable /oam/cfm/state/local_meps_operational (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_meps_operational is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_meps_operational() directly.

    YANG Description: The total number of local-meps operational on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_meps_operational must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__local_meps_operational = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_meps_operational(self):
    self.__local_meps_operational = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-meps-operational", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_cfm_domains(self):
    """
    Getter method for cfm_domains, mapped from YANG variable /oam/cfm/state/cfm_domains (uint32)

    YANG Description: The total number cfm domains configured on the local system.
    """
    return self.__cfm_domains
      
  def _set_cfm_domains(self, v, load=False):
    """
    Setter method for cfm_domains, mapped from YANG variable /oam/cfm/state/cfm_domains (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfm_domains is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfm_domains() directly.

    YANG Description: The total number cfm domains configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfm_domains must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__cfm_domains = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfm_domains(self):
    self.__cfm_domains = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_cfm_services(self):
    """
    Getter method for cfm_services, mapped from YANG variable /oam/cfm/state/cfm_services (uint32)

    YANG Description: The total number cfm services configured on the local system.
    """
    return self.__cfm_services
      
  def _set_cfm_services(self, v, load=False):
    """
    Setter method for cfm_services, mapped from YANG variable /oam/cfm/state/cfm_services (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfm_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfm_services() directly.

    YANG Description: The total number cfm services configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfm_services must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__cfm_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfm_services(self):
    self.__cfm_services = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cfm-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_down_meps(self):
    """
    Getter method for down_meps, mapped from YANG variable /oam/cfm/state/down_meps (uint32)

    YANG Description: The total number cfm down meps configured on the local system.
    """
    return self.__down_meps
      
  def _set_down_meps(self, v, load=False):
    """
    Setter method for down_meps, mapped from YANG variable /oam/cfm/state/down_meps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down_meps() directly.

    YANG Description: The total number cfm down meps configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="down-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down_meps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="down-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__down_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down_meps(self):
    self.__down_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="down-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_up_meps(self):
    """
    Getter method for up_meps, mapped from YANG variable /oam/cfm/state/up_meps (uint32)

    YANG Description: The total number cfm down meps configured on the local system.
    """
    return self.__up_meps
      
  def _set_up_meps(self, v, load=False):
    """
    Setter method for up_meps, mapped from YANG variable /oam/cfm/state/up_meps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_meps() directly.

    YANG Description: The total number cfm down meps configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_meps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__up_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_meps(self):
    self.__up_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_disabled_misconfigured(self):
    """
    Getter method for disabled_misconfigured, mapped from YANG variable /oam/cfm/state/disabled_misconfigured (uint32)

    YANG Description: The total number of disabled cfm  down meps configured on the local system.
    """
    return self.__disabled_misconfigured
      
  def _set_disabled_misconfigured(self, v, load=False):
    """
    Setter method for disabled_misconfigured, mapped from YANG variable /oam/cfm/state/disabled_misconfigured (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disabled_misconfigured is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disabled_misconfigured() directly.

    YANG Description: The total number of disabled cfm  down meps configured on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-misconfigured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disabled_misconfigured must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-misconfigured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__disabled_misconfigured = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disabled_misconfigured(self):
    self.__disabled_misconfigured = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-misconfigured", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_disabled_operational_errors(self):
    """
    Getter method for disabled_operational_errors, mapped from YANG variable /oam/cfm/state/disabled_operational_errors (uint32)

    YANG Description: The total number cfm operational errors on the local system.
    """
    return self.__disabled_operational_errors
      
  def _set_disabled_operational_errors(self, v, load=False):
    """
    Setter method for disabled_operational_errors, mapped from YANG variable /oam/cfm/state/disabled_operational_errors (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disabled_operational_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disabled_operational_errors() directly.

    YANG Description: The total number cfm operational errors on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-operational-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disabled_operational_errors must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-operational-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__disabled_operational_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disabled_operational_errors(self):
    self.__disabled_operational_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-operational-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_disabled_out_of_resources(self):
    """
    Getter method for disabled_out_of_resources, mapped from YANG variable /oam/cfm/state/disabled_out_of_resources (uint32)

    YANG Description: The total number cfm endpoints disabled due to lack of resources on the local system.
    """
    return self.__disabled_out_of_resources
      
  def _set_disabled_out_of_resources(self, v, load=False):
    """
    Setter method for disabled_out_of_resources, mapped from YANG variable /oam/cfm/state/disabled_out_of_resources (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disabled_out_of_resources is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disabled_out_of_resources() directly.

    YANG Description: The total number cfm endpoints disabled due to lack of resources on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-out-of-resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disabled_out_of_resources must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-out-of-resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__disabled_out_of_resources = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disabled_out_of_resources(self):
    self.__disabled_out_of_resources = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="disabled-out-of-resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_peer_meps(self):
    """
    Getter method for peer_meps, mapped from YANG variable /oam/cfm/state/peer_meps (uint32)

    YANG Description: The total number cfm peer meps configured.
    """
    return self.__peer_meps
      
  def _set_peer_meps(self, v, load=False):
    """
    Setter method for peer_meps, mapped from YANG variable /oam/cfm/state/peer_meps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_meps() directly.

    YANG Description: The total number cfm peer meps configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_meps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__peer_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_meps(self):
    self.__peer_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_operational_peer_meps(self):
    """
    Getter method for operational_peer_meps, mapped from YANG variable /oam/cfm/state/operational_peer_meps (uint32)

    YANG Description: The total number cfm peer meps operational.
    """
    return self.__operational_peer_meps
      
  def _set_operational_peer_meps(self, v, load=False):
    """
    Setter method for operational_peer_meps, mapped from YANG variable /oam/cfm/state/operational_peer_meps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_peer_meps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_peer_meps() directly.

    YANG Description: The total number cfm peer meps operational.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="operational-peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_peer_meps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="operational-peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__operational_peer_meps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_peer_meps(self):
    self.__operational_peer_meps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="operational-peer-meps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_peer_meps_with_defects(self):
    """
    Getter method for peer_meps_with_defects, mapped from YANG variable /oam/cfm/state/peer_meps_with_defects (uint32)

    YANG Description: The total number cfm peer meps with defects.
    """
    return self.__peer_meps_with_defects
      
  def _set_peer_meps_with_defects(self, v, load=False):
    """
    Setter method for peer_meps_with_defects, mapped from YANG variable /oam/cfm/state/peer_meps_with_defects (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_meps_with_defects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_meps_with_defects() directly.

    YANG Description: The total number cfm peer meps with defects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-with-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_meps_with_defects must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-with-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__peer_meps_with_defects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_meps_with_defects(self):
    self.__peer_meps_with_defects = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-with-defects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_peer_meps_timed_out(self):
    """
    Getter method for peer_meps_timed_out, mapped from YANG variable /oam/cfm/state/peer_meps_timed_out (uint32)

    YANG Description: The total number cfm peer meps timed out.
    """
    return self.__peer_meps_timed_out
      
  def _set_peer_meps_timed_out(self, v, load=False):
    """
    Setter method for peer_meps_timed_out, mapped from YANG variable /oam/cfm/state/peer_meps_timed_out (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_meps_timed_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_meps_timed_out() directly.

    YANG Description: The total number cfm peer meps timed out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-timed-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_meps_timed_out must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-timed-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__peer_meps_timed_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_meps_timed_out(self):
    self.__peer_meps_timed_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-meps-timed-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)

  local_meps = __builtin__.property(_get_local_meps)
  local_meps_operational = __builtin__.property(_get_local_meps_operational)
  cfm_domains = __builtin__.property(_get_cfm_domains)
  cfm_services = __builtin__.property(_get_cfm_services)
  down_meps = __builtin__.property(_get_down_meps)
  up_meps = __builtin__.property(_get_up_meps)
  disabled_misconfigured = __builtin__.property(_get_disabled_misconfigured)
  disabled_operational_errors = __builtin__.property(_get_disabled_operational_errors)
  disabled_out_of_resources = __builtin__.property(_get_disabled_out_of_resources)
  peer_meps = __builtin__.property(_get_peer_meps)
  operational_peer_meps = __builtin__.property(_get_operational_peer_meps)
  peer_meps_with_defects = __builtin__.property(_get_peer_meps_with_defects)
  peer_meps_timed_out = __builtin__.property(_get_peer_meps_timed_out)


  _pyangbind_elements = OrderedDict([('local_meps', local_meps), ('local_meps_operational', local_meps_operational), ('cfm_domains', cfm_domains), ('cfm_services', cfm_services), ('down_meps', down_meps), ('up_meps', up_meps), ('disabled_misconfigured', disabled_misconfigured), ('disabled_operational_errors', disabled_operational_errors), ('disabled_out_of_resources', disabled_out_of_resources), ('peer_meps', peer_meps), ('operational_peer_meps', operational_peer_meps), ('peer_meps_with_defects', peer_meps_with_defects), ('peer_meps_timed_out', peer_meps_timed_out), ])


class yc_config_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for Performance measurement profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__enable','__measurement_type','__protocol_type','__frame_size','__measurement_interval','__repetition_period','__intervals_archived','__packets_per_meaurement_period','__burst_interval','__packet_per_burst',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'config']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/profile_name (string)

    YANG Description: Name of the measurement profile.
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/profile_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Name of the measurement profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=True)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/enable (boolean)

    YANG Description: Enable or disable measurement.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable or disable measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=True)


  def _get_measurement_type(self):
    """
    Getter method for measurement_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/measurement_type (enumeration)

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    return self.__measurement_type
      
  def _set_measurement_type(self, v, load=False):
    """
    Setter method for measurement_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/measurement_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_type() directly.

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__measurement_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_type(self):
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_protocol_type(self):
    """
    Getter method for protocol_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/protocol_type (enumeration)

    YANG Description: protocol type.
    """
    return self.__protocol_type
      
  def _set_protocol_type(self, v, load=False):
    """
    Setter method for protocol_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/protocol_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_type() directly.

    YANG Description: protocol type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)""",
        })

    self.__protocol_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_type(self):
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=True)


  def _get_frame_size(self):
    """
    Getter method for frame_size, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/frame_size (uint16)

    YANG Description: Probe Frame size for measurement.
    """
    return self.__frame_size
      
  def _set_frame_size(self, v, load=False):
    """
    Setter method for frame_size, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/frame_size (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_size() directly.

    YANG Description: Probe Frame size for measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_size must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__frame_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_size(self):
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_measurement_interval(self):
    """
    Getter method for measurement_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/measurement_interval (uint32)

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    return self.__measurement_interval
      
  def _set_measurement_interval(self, v, load=False):
    """
    Setter method for measurement_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/measurement_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_interval() directly.

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__measurement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_interval(self):
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)


  def _get_repetition_period(self):
    """
    Getter method for repetition_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/repetition_period (uint32)

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    return self.__repetition_period
      
  def _set_repetition_period(self, v, load=False):
    """
    Setter method for repetition_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/repetition_period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repetition_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repetition_period() directly.

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repetition_period must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__repetition_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repetition_period(self):
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)


  def _get_intervals_archived(self):
    """
    Getter method for intervals_archived, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/intervals_archived (uint16)

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    return self.__intervals_archived
      
  def _set_intervals_archived(self, v, load=False):
    """
    Setter method for intervals_archived, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/intervals_archived (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intervals_archived is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intervals_archived() directly.

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intervals_archived must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__intervals_archived = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intervals_archived(self):
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_packets_per_meaurement_period(self):
    """
    Getter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/packets_per_meaurement_period (uint16)

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    return self.__packets_per_meaurement_period
      
  def _set_packets_per_meaurement_period(self, v, load=False):
    """
    Setter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/packets_per_meaurement_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets_per_meaurement_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets_per_meaurement_period() directly.

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets_per_meaurement_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)""",
        })

    self.__packets_per_meaurement_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets_per_meaurement_period(self):
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=True)


  def _get_burst_interval(self):
    """
    Getter method for burst_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/burst_interval (uint32)

    YANG Description: Interval between bursts within a measurement interval.
    """
    return self.__burst_interval
      
  def _set_burst_interval(self, v, load=False):
    """
    Setter method for burst_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/burst_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_burst_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_burst_interval() directly.

    YANG Description: Interval between bursts within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """burst_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__burst_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_burst_interval(self):
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)


  def _get_packet_per_burst(self):
    """
    Getter method for packet_per_burst, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/packet_per_burst (uint32)

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    return self.__packet_per_burst
      
  def _set_packet_per_burst(self, v, load=False):
    """
    Setter method for packet_per_burst, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config/packet_per_burst (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_per_burst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_per_burst() directly.

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_per_burst must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)""",
        })

    self.__packet_per_burst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_per_burst(self):
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=True)

  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)
  enable = __builtin__.property(_get_enable, _set_enable)
  measurement_type = __builtin__.property(_get_measurement_type, _set_measurement_type)
  protocol_type = __builtin__.property(_get_protocol_type, _set_protocol_type)
  frame_size = __builtin__.property(_get_frame_size, _set_frame_size)
  measurement_interval = __builtin__.property(_get_measurement_interval, _set_measurement_interval)
  repetition_period = __builtin__.property(_get_repetition_period, _set_repetition_period)
  intervals_archived = __builtin__.property(_get_intervals_archived, _set_intervals_archived)
  packets_per_meaurement_period = __builtin__.property(_get_packets_per_meaurement_period, _set_packets_per_meaurement_period)
  burst_interval = __builtin__.property(_get_burst_interval, _set_burst_interval)
  packet_per_burst = __builtin__.property(_get_packet_per_burst, _set_packet_per_burst)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('enable', enable), ('measurement_type', measurement_type), ('protocol_type', protocol_type), ('frame_size', frame_size), ('measurement_interval', measurement_interval), ('repetition_period', repetition_period), ('intervals_archived', intervals_archived), ('packets_per_meaurement_period', packets_per_meaurement_period), ('burst_interval', burst_interval), ('packet_per_burst', packet_per_burst), ])


class yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/state/loss-measurement-state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of loss-measurement-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__slm_sent','__slm_received','__slr_sent','__slr_received',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__slr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'state', 'loss-measurement-state', 'counters']

  def _get_slm_sent(self):
    """
    Getter method for slm_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slm_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slm_sent
      
  def _set_slm_sent(self, v, load=False):
    """
    Setter method for slm_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slm_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slm_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slm_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slm_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slm_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slm_sent(self):
    self.__slm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slm_received(self):
    """
    Getter method for slm_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slm_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slm_received
      
  def _set_slm_received(self, v, load=False):
    """
    Setter method for slm_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slm_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slm_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slm_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slm_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slm_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slm_received(self):
    self.__slm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slr_sent(self):
    """
    Getter method for slr_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slr_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slr_sent
      
  def _set_slr_sent(self, v, load=False):
    """
    Setter method for slr_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slr_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slr_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slr_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slr_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slr_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slr_sent(self):
    self.__slr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_slr_received(self):
    """
    Getter method for slr_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slr_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__slr_received
      
  def _set_slr_received(self, v, load=False):
    """
    Setter method for slr_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters/slr_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slr_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slr_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slr_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__slr_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slr_received(self):
    self.__slr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="slr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  slm_sent = __builtin__.property(_get_slm_sent)
  slm_received = __builtin__.property(_get_slm_received)
  slr_sent = __builtin__.property(_get_slr_sent)
  slr_received = __builtin__.property(_get_slr_received)


  _pyangbind_elements = OrderedDict([('slm_sent', slm_sent), ('slm_received', slm_received), ('slr_sent', slr_sent), ('slr_received', slr_received), ])


class yc_loss_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/state/loss-measurement-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Loss measurement state container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__far_end_min_frame_loss_ratio','__far_end_max_frame_loss_ratio','__far_end_average_frame_loss_ratio','__near_end_min_frame_loss_ratio','__near_end_max_frame_loss_ratio','__near_end_average_frame_loss_ratio','__counters',)

  _yang_name = 'loss-measurement-state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__far_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__far_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__far_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__near_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'state', 'loss-measurement-state']

  def _get_far_end_min_frame_loss_ratio(self):
    """
    Getter method for far_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_min_frame_loss_ratio (uint32)

    YANG Description: This object contains the minimum one-way availability flr in the
egress direction (source --> destination),
from among the set of availability flr values
calculated by the MEP in this Measurement Interval. There is
one availability flr value for each 'delta_t' time period
within the Measurement Interval, as specified in MEF 10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_min_frame_loss_ratio
      
  def _set_far_end_min_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_min_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_min_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_min_frame_loss_ratio() directly.

    YANG Description: This object contains the minimum one-way availability flr in the
egress direction (source --> destination),
from among the set of availability flr values
calculated by the MEP in this Measurement Interval. There is
one availability flr value for each 'delta_t' time period
within the Measurement Interval, as specified in MEF 10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_min_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_min_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_min_frame_loss_ratio(self):
    self.__far_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_far_end_max_frame_loss_ratio(self):
    """
    Getter method for far_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_max_frame_loss_ratio (uint32)

    YANG Description: This object contains the maximum one-way availability flr in the
forward direction (source --> destination),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_max_frame_loss_ratio
      
  def _set_far_end_max_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_max_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_max_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_max_frame_loss_ratio() directly.

    YANG Description: This object contains the maximum one-way availability flr in the
forward direction (source --> destination),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_max_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_max_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_max_frame_loss_ratio(self):
    self.__far_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_far_end_average_frame_loss_ratio(self):
    """
    Getter method for far_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_average_frame_loss_ratio (uint32)

    YANG Description: This object contains the average one-way availability flr in the
forward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__far_end_average_frame_loss_ratio
      
  def _set_far_end_average_frame_loss_ratio(self, v, load=False):
    """
    Setter method for far_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/far_end_average_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end_average_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end_average_frame_loss_ratio() directly.

    YANG Description: This object contains the average one-way availability flr in the
forward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end_average_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__far_end_average_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end_average_frame_loss_ratio(self):
    self.__far_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="far-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_min_frame_loss_ratio(self):
    """
    Getter method for near_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_min_frame_loss_ratio (uint32)

    YANG Description: This object contains the minimum one-way availability flr in the
backward direction (destination --> source),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_min_frame_loss_ratio
      
  def _set_near_end_min_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_min_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_min_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_min_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_min_frame_loss_ratio() directly.

    YANG Description: This object contains the minimum one-way availability flr in the
backward direction (destination --> source),
from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_min_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_min_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_min_frame_loss_ratio(self):
    self.__near_end_min_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-min-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_max_frame_loss_ratio(self):
    """
    Getter method for near_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_max_frame_loss_ratio (uint32)

    YANG Description: This object contains the maximum one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).
Service OAM Performance Monitoring YANG Module
MEF 39

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_max_frame_loss_ratio
      
  def _set_near_end_max_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_max_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_max_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_max_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_max_frame_loss_ratio() directly.

    YANG Description: This object contains the maximum one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).
Service OAM Performance Monitoring YANG Module
MEF 39

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_max_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_max_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_max_frame_loss_ratio(self):
    self.__near_end_max_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-max-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_near_end_average_frame_loss_ratio(self):
    """
    Getter method for near_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_average_frame_loss_ratio (uint32)

    YANG Description: This object contains the average one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    return self.__near_end_average_frame_loss_ratio
      
  def _set_near_end_average_frame_loss_ratio(self, v, load=False):
    """
    Setter method for near_end_average_frame_loss_ratio, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/near_end_average_frame_loss_ratio (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_near_end_average_frame_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_near_end_average_frame_loss_ratio() directly.

    YANG Description: This object contains the average one-way availability flr in the
backward direction, from among the set of availability flr
values calculated by the MEP in this Measurement Interval.
There is one availability flr value for each 'delta_t' time
period within the Measurement Interval, as specified in MEF
10.2.1.

The flr value is a ratio that is expressed as a percent with a
value of 0 (ratio 0.00) through 100000 (ratio 1.00).

Units are in milli-percent, where 1 indicates 0.001 percent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """near_end_average_frame_loss_ratio must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__near_end_average_frame_loss_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_near_end_average_frame_loss_ratio(self):
    self.__near_end_average_frame_loss_ratio = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..100000']}), is_leaf=True, yang_name="near-end-average-frame-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters (container)

    YANG Description: A collection of loss-measurement-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of loss-measurement-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  far_end_min_frame_loss_ratio = __builtin__.property(_get_far_end_min_frame_loss_ratio)
  far_end_max_frame_loss_ratio = __builtin__.property(_get_far_end_max_frame_loss_ratio)
  far_end_average_frame_loss_ratio = __builtin__.property(_get_far_end_average_frame_loss_ratio)
  near_end_min_frame_loss_ratio = __builtin__.property(_get_near_end_min_frame_loss_ratio)
  near_end_max_frame_loss_ratio = __builtin__.property(_get_near_end_max_frame_loss_ratio)
  near_end_average_frame_loss_ratio = __builtin__.property(_get_near_end_average_frame_loss_ratio)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('far_end_min_frame_loss_ratio', far_end_min_frame_loss_ratio), ('far_end_max_frame_loss_ratio', far_end_max_frame_loss_ratio), ('far_end_average_frame_loss_ratio', far_end_average_frame_loss_ratio), ('near_end_min_frame_loss_ratio', near_end_min_frame_loss_ratio), ('near_end_max_frame_loss_ratio', near_end_max_frame_loss_ratio), ('near_end_average_frame_loss_ratio', near_end_average_frame_loss_ratio), ('counters', counters), ])


class yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/state/delay-measurement-state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of delay-measurement-related statistics objects.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dmm_sent','__dmm_received','__dmr_sent','__dmr_received',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dmm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    self.__dmr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'state', 'delay-measurement-state', 'counters']

  def _get_dmm_sent(self):
    """
    Getter method for dmm_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmm_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmm_sent
      
  def _set_dmm_sent(self, v, load=False):
    """
    Setter method for dmm_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmm_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmm_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmm_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmm_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmm_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmm_sent(self):
    self.__dmm_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmm_received(self):
    """
    Getter method for dmm_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmm_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmm_received
      
  def _set_dmm_received(self, v, load=False):
    """
    Setter method for dmm_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmm_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmm_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmm_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmm_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmm_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmm_received(self):
    self.__dmm_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmm-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmr_sent(self):
    """
    Getter method for dmr_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmr_sent (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmr_sent
      
  def _set_dmr_sent(self, v, load=False):
    """
    Setter method for dmr_sent, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmr_sent (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmr_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmr_sent() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmr_sent must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmr_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmr_sent(self):
    self.__dmr_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)


  def _get_dmr_received(self):
    """
    Getter method for dmr_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmr_received (oc-yang:counter64)

    YANG Description: slm Probes sent.
    """
    return self.__dmr_received
      
  def _set_dmr_received(self, v, load=False):
    """
    Setter method for dmr_received, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters/dmr_received (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmr_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmr_received() directly.

    YANG Description: slm Probes sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmr_received must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__dmr_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmr_received(self):
    self.__dmr_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dmr-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='oc-yang:counter64', is_config=False)

  dmm_sent = __builtin__.property(_get_dmm_sent)
  dmm_received = __builtin__.property(_get_dmm_received)
  dmr_sent = __builtin__.property(_get_dmr_sent)
  dmr_received = __builtin__.property(_get_dmr_received)


  _pyangbind_elements = OrderedDict([('dmm_sent', dmm_sent), ('dmm_received', dmm_received), ('dmr_sent', dmr_sent), ('dmr_received', dmr_received), ])


class yc_delay_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/state/delay-measurement-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Delay measurement state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_delay_two_way_min','__frame_delay_two_way_max','__frame_delay_two_way_average','__frame_delay_two_way_stddev','__counters',)

  _yang_name = 'delay-measurement-state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_delay_two_way_min = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_max = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_average = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__frame_delay_two_way_stddev = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'state', 'delay-measurement-state']

  def _get_frame_delay_two_way_min(self):
    """
    Getter method for frame_delay_two_way_min, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_min (uint32)

    YANG Description: This object contains the minimum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted
or dm1-received.
    """
    return self.__frame_delay_two_way_min
      
  def _set_frame_delay_two_way_min(self, v, load=False):
    """
    Setter method for frame_delay_two_way_min, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_min (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_min() directly.

    YANG Description: This object contains the minimum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted
or dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_min must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_min(self):
    self.__frame_delay_two_way_min = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_max(self):
    """
    Getter method for frame_delay_two_way_max, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_max (uint32)

    YANG Description: This object contains the maximum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    return self.__frame_delay_two_way_max
      
  def _set_frame_delay_two_way_max(self, v, load=False):
    """
    Setter method for frame_delay_two_way_max, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_max (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_max() directly.

    YANG Description: This object contains the maximum two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_max must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_max(self):
    self.__frame_delay_two_way_max = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_average(self):
    """
    Getter method for frame_delay_two_way_average, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_average (uint32)

    YANG Description: This object contains the average two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted or
dm1-received.
    """
    return self.__frame_delay_two_way_average
      
  def _set_frame_delay_two_way_average(self, v, load=False):
    """
    Setter method for frame_delay_two_way_average, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_average (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_average is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_average() directly.

    YANG Description: This object contains the average two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1-transmitted or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_average must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_average = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_average(self):
    self.__frame_delay_two_way_average = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-average", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_frame_delay_two_way_stddev(self):
    """
    Getter method for frame_delay_two_way_stddev, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_stddev (uint32)

    YANG Description: This object contains the standard deviation of two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    return self.__frame_delay_two_way_stddev
      
  def _set_frame_delay_two_way_stddev(self, v, load=False):
    """
    Setter method for frame_delay_two_way_stddev, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/frame_delay_two_way_stddev (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_delay_two_way_stddev is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_delay_two_way_stddev() directly.

    YANG Description: This object contains the standard deviation of two-way frame delay calculated by this
MEP for this Measurement Interval.

This object is undefined if measurement-type is dm1DmTx or
dm1-received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_delay_two_way_stddev must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__frame_delay_two_way_stddev = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_delay_two_way_stddev(self):
    self.__frame_delay_two_way_stddev = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frame-delay-two-way-stddev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters (container)

    YANG Description: A collection of delay-measurement-related statistics objects.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of delay-measurement-related statistics objects.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  frame_delay_two_way_min = __builtin__.property(_get_frame_delay_two_way_min)
  frame_delay_two_way_max = __builtin__.property(_get_frame_delay_two_way_max)
  frame_delay_two_way_average = __builtin__.property(_get_frame_delay_two_way_average)
  frame_delay_two_way_stddev = __builtin__.property(_get_frame_delay_two_way_stddev)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('frame_delay_two_way_min', frame_delay_two_way_min), ('frame_delay_two_way_max', frame_delay_two_way_max), ('frame_delay_two_way_average', frame_delay_two_way_average), ('frame_delay_two_way_stddev', frame_delay_two_way_stddev), ('counters', counters), ])


class yc_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistical data for performance measurement profiles.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__enable','__measurement_type','__protocol_type','__frame_size','__measurement_interval','__repetition_period','__intervals_archived','__packets_per_meaurement_period','__burst_interval','__packet_per_burst','__loss_measurement_state','__delay_measurement_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    self.__loss_measurement_state = YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__delay_measurement_state = YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile', 'state']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/profile_name (string)

    YANG Description: Name of the measurement profile.
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/profile_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Name of the measurement profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='string', is_config=False)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/enable (boolean)

    YANG Description: Enable or disable measurement.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable or disable measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='boolean', is_config=False)


  def _get_measurement_type(self):
    """
    Getter method for measurement_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/measurement_type (enumeration)

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    return self.__measurement_type
      
  def _set_measurement_type(self, v, load=False):
    """
    Setter method for measurement_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/measurement_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_type() directly.

    YANG Description: This object specifies what type of Performance Measurement will be
performed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__measurement_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_type(self):
    self.__measurement_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LMM': {}, 'SLM': {}, 'DMM': {}, 'CCM': {}},), default=str("SLM"), is_leaf=True, yang_name="measurement-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_protocol_type(self):
    """
    Getter method for protocol_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/protocol_type (enumeration)

    YANG Description: protocol type.
    """
    return self.__protocol_type
      
  def _set_protocol_type(self, v, load=False):
    """
    Setter method for protocol_type, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/protocol_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_type() directly.

    YANG Description: protocol type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-oam-cfm:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)""",
        })

    self.__protocol_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_type(self):
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'SINGLE_ENDED': {}, 'DUAL_ENDED': {}},), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='enumeration', is_config=False)


  def _get_frame_size(self):
    """
    Getter method for frame_size, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/frame_size (uint16)

    YANG Description: Probe Frame size for measurement.
    """
    return self.__frame_size
      
  def _set_frame_size(self, v, load=False):
    """
    Setter method for frame_size, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/frame_size (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_size() directly.

    YANG Description: Probe Frame size for measurement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_size must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__frame_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_size(self):
    self.__frame_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="frame-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_measurement_interval(self):
    """
    Getter method for measurement_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/measurement_interval (uint32)

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    return self.__measurement_interval
      
  def _set_measurement_interval(self, v, load=False):
    """
    Setter method for measurement_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/measurement_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_measurement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_measurement_interval() directly.

    YANG Description: This object specifies the Measurement Interval for FLR statistics, in
minutes.
A Measurement Interval of 15 minutes needs to be supported,
other intervals may be supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """measurement_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__measurement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_measurement_interval(self):
    self.__measurement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..525600']}), is_leaf=True, yang_name="measurement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_repetition_period(self):
    """
    Getter method for repetition_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/repetition_period (uint32)

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    return self.__repetition_period
      
  def _set_repetition_period(self, v, load=False):
    """
    Setter method for repetition_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/repetition_period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repetition_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repetition_period() directly.

    YANG Description: This object specifies a configurable repetition time between
Measurement Intervals in a Measurement session in hundredths of a
second.

If the value is less than or equal to one Measurement Interval
there is no time gap between the end of one Measurement
Interval and the start of a new Measurement Interval. This is
the normal usage case.

If the value is greater than one Measurement Interval there is
time gap between the end of one Measurement Interval and the
start of the next Measurement Interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repetition_period must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__repetition_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repetition_period(self):
    self.__repetition_period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="repetition-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_intervals_archived(self):
    """
    Getter method for intervals_archived, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/intervals_archived (uint16)

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    return self.__intervals_archived
      
  def _set_intervals_archived(self, v, load=False):
    """
    Setter method for intervals_archived, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/intervals_archived (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intervals_archived is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intervals_archived() directly.

    YANG Description: This object specifies the number of completed measurement intervals to
store in the history statistic table.

At least 32 completed measurement intervals are to be
stored. 96 measurement intervals are recommended to be stored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intervals_archived must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__intervals_archived = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intervals_archived(self):
    self.__intervals_archived = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="intervals-archived", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_packets_per_meaurement_period(self):
    """
    Getter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/packets_per_meaurement_period (uint16)

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    return self.__packets_per_meaurement_period
      
  def _set_packets_per_meaurement_period(self, v, load=False):
    """
    Setter method for packets_per_meaurement_period, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/packets_per_meaurement_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets_per_meaurement_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets_per_meaurement_period() directly.

    YANG Description: Number of probe packets to send within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets_per_meaurement_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)""",
        })

    self.__packets_per_meaurement_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets_per_meaurement_period(self):
    self.__packets_per_meaurement_period = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packets-per-meaurement-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint16', is_config=False)


  def _get_burst_interval(self):
    """
    Getter method for burst_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/burst_interval (uint32)

    YANG Description: Interval between bursts within a measurement interval.
    """
    return self.__burst_interval
      
  def _set_burst_interval(self, v, load=False):
    """
    Setter method for burst_interval, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/burst_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_burst_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_burst_interval() directly.

    YANG Description: Interval between bursts within a measurement interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """burst_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__burst_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_burst_interval(self):
    self.__burst_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="burst-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_packet_per_burst(self):
    """
    Getter method for packet_per_burst, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/packet_per_burst (uint32)

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    return self.__packet_per_burst
      
  def _set_packet_per_burst(self, v, load=False):
    """
    Setter method for packet_per_burst, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/packet_per_burst (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_per_burst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_per_burst() directly.

    YANG Description: if burst enabled. The leaf defines the number of packet per burst of probes.
packets-per-measurement-period / burst-interval
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_per_burst must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)""",
        })

    self.__packet_per_burst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_per_burst(self):
    self.__packet_per_burst = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-per-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='uint32', is_config=False)


  def _get_loss_measurement_state(self):
    """
    Getter method for loss_measurement_state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state (container)

    YANG Description: Loss measurement state container.
    """
    return self.__loss_measurement_state
      
  def _set_loss_measurement_state(self, v, load=False):
    """
    Setter method for loss_measurement_state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/loss_measurement_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loss_measurement_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loss_measurement_state() directly.

    YANG Description: Loss measurement state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loss_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loss_measurement_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__loss_measurement_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loss_measurement_state(self):
    self.__loss_measurement_state = YANGDynClass(base=yc_loss_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_loss_measurement_state, is_container='container', yang_name="loss-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_delay_measurement_state(self):
    """
    Getter method for delay_measurement_state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state (container)

    YANG Description: Delay measurement state.
    """
    return self.__delay_measurement_state
      
  def _set_delay_measurement_state(self, v, load=False):
    """
    Setter method for delay_measurement_state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state/delay_measurement_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_measurement_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_measurement_state() directly.

    YANG Description: Delay measurement state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_delay_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_measurement_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__delay_measurement_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_measurement_state(self):
    self.__delay_measurement_state = YANGDynClass(base=yc_delay_measurement_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state_delay_measurement_state, is_container='container', yang_name="delay-measurement-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  profile_name = __builtin__.property(_get_profile_name)
  enable = __builtin__.property(_get_enable)
  measurement_type = __builtin__.property(_get_measurement_type)
  protocol_type = __builtin__.property(_get_protocol_type)
  frame_size = __builtin__.property(_get_frame_size)
  measurement_interval = __builtin__.property(_get_measurement_interval)
  repetition_period = __builtin__.property(_get_repetition_period)
  intervals_archived = __builtin__.property(_get_intervals_archived)
  packets_per_meaurement_period = __builtin__.property(_get_packets_per_meaurement_period)
  burst_interval = __builtin__.property(_get_burst_interval)
  packet_per_burst = __builtin__.property(_get_packet_per_burst)
  loss_measurement_state = __builtin__.property(_get_loss_measurement_state)
  delay_measurement_state = __builtin__.property(_get_delay_measurement_state)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('enable', enable), ('measurement_type', measurement_type), ('protocol_type', protocol_type), ('frame_size', frame_size), ('measurement_interval', measurement_interval), ('repetition_period', repetition_period), ('intervals_archived', intervals_archived), ('packets_per_meaurement_period', packets_per_meaurement_period), ('burst_interval', burst_interval), ('packet_per_burst', packet_per_burst), ('loss_measurement_state', loss_measurement_state), ('delay_measurement_state', delay_measurement_state), ])


class yc_performance_measurement_profile_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global/performance-measurement-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Performance measurement configuration and state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__config','__state',)

  _yang_name = 'performance-measurement-profile'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global', 'performance-measurement-profile']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/profile_name (leafref)

    YANG Description: A unique profile name identifying the
Performance measurement profile
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/profile_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: A unique profile name identifying the
Performance measurement profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=str, is_leaf=True, yang_name="profile-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config (container)

    YANG Description: Configuration data for Performance measurement profile.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for Performance measurement profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state (container)

    YANG Description: Statistical data for performance measurement profiles.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Statistical data for performance measurement profiles.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)

  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('config', config), ('state', state), ])


class yc_performance_measurement_profiles_global_openconfig_oam__oam_cfm_performance_measurement_profiles_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm/performance-measurement-profiles-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container includes configuration and state objects
for the Frame Loss Measurement and Delay measurement
functions as defined in [Y.1731] and [MEF SOAM PM IA].
  """
  __slots__ = ('_path_helper', '_extmethods', '__performance_measurement_profile',)

  _yang_name = 'performance-measurement-profiles-global'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__performance_measurement_profile = YANGDynClass(base=YANGListType("profile_name",yc_performance_measurement_profile_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile, yang_name="performance-measurement-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="performance-measurement-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm', 'performance-measurement-profiles-global']

  def _get_performance_measurement_profile(self):
    """
    Getter method for performance_measurement_profile, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile (list)

    YANG Description: Performance measurement configuration and state.
    """
    return self.__performance_measurement_profile
      
  def _set_performance_measurement_profile(self, v, load=False):
    """
    Setter method for performance_measurement_profile, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global/performance_measurement_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_measurement_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_measurement_profile() directly.

    YANG Description: Performance measurement configuration and state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile_name",yc_performance_measurement_profile_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile, yang_name="performance-measurement-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="performance-measurement-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """performance_measurement_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile_name",yc_performance_measurement_profile_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile, yang_name="performance-measurement-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="performance-measurement-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)""",
        })

    self.__performance_measurement_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_performance_measurement_profile(self):
    self.__performance_measurement_profile = YANGDynClass(base=YANGListType("profile_name",yc_performance_measurement_profile_openconfig_oam__oam_cfm_performance_measurement_profiles_global_performance_measurement_profile, yang_name="performance-measurement-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile-name', extensions=None), is_container='list', yang_name="performance-measurement-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='list', is_config=True)

  performance_measurement_profile = __builtin__.property(_get_performance_measurement_profile, _set_performance_measurement_profile)


  _pyangbind_elements = OrderedDict([('performance_measurement_profile', performance_measurement_profile), ])


class yc_cfm_openconfig_oam__oam_cfm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam/cfm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for CFM configuration, state and perfomance measurement policies
  """
  __slots__ = ('_path_helper', '_extmethods', '__domains','__state','__performance_measurement_profiles_global',)

  _yang_name = 'cfm'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__domains = YANGDynClass(base=yc_domains_openconfig_oam__oam_cfm_domains, is_container='container', yang_name="domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    self.__performance_measurement_profiles_global = YANGDynClass(base=yc_performance_measurement_profiles_global_openconfig_oam__oam_cfm_performance_measurement_profiles_global, is_container='container', yang_name="performance-measurement-profiles-global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam', 'cfm']

  def _get_domains(self):
    """
    Getter method for domains, mapped from YANG variable /oam/cfm/domains (container)

    YANG Description: A Container for CFM maintenance domain state and Configuration
on the local system
    """
    return self.__domains
      
  def _set_domains(self, v, load=False):
    """
    Setter method for domains, mapped from YANG variable /oam/cfm/domains (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domains is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domains() directly.

    YANG Description: A Container for CFM maintenance domain state and Configuration
on the local system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_domains_openconfig_oam__oam_cfm_domains, is_container='container', yang_name="domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domains must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_domains_openconfig_oam__oam_cfm_domains, is_container='container', yang_name="domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__domains = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domains(self):
    self.__domains = YANGDynClass(base=yc_domains_openconfig_oam__oam_cfm_domains, is_container='container', yang_name="domains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /oam/cfm/state (container)

    YANG Description: Operational data for CFM.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /oam/cfm/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational data for CFM.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_oam__oam_cfm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_oam__oam_cfm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=False)


  def _get_performance_measurement_profiles_global(self):
    """
    Getter method for performance_measurement_profiles_global, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global (container)

    YANG Description: This container includes configuration and state objects
for the Frame Loss Measurement and Delay measurement
functions as defined in [Y.1731] and [MEF SOAM PM IA].
    """
    return self.__performance_measurement_profiles_global
      
  def _set_performance_measurement_profiles_global(self, v, load=False):
    """
    Setter method for performance_measurement_profiles_global, mapped from YANG variable /oam/cfm/performance_measurement_profiles_global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_measurement_profiles_global is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_measurement_profiles_global() directly.

    YANG Description: This container includes configuration and state objects
for the Frame Loss Measurement and Delay measurement
functions as defined in [Y.1731] and [MEF SOAM PM IA].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_performance_measurement_profiles_global_openconfig_oam__oam_cfm_performance_measurement_profiles_global, is_container='container', yang_name="performance-measurement-profiles-global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """performance_measurement_profiles_global must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_performance_measurement_profiles_global_openconfig_oam__oam_cfm_performance_measurement_profiles_global, is_container='container', yang_name="performance-measurement-profiles-global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__performance_measurement_profiles_global = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_performance_measurement_profiles_global(self):
    self.__performance_measurement_profiles_global = YANGDynClass(base=yc_performance_measurement_profiles_global_openconfig_oam__oam_cfm_performance_measurement_profiles_global, is_container='container', yang_name="performance-measurement-profiles-global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

  domains = __builtin__.property(_get_domains, _set_domains)
  state = __builtin__.property(_get_state)
  performance_measurement_profiles_global = __builtin__.property(_get_performance_measurement_profiles_global, _set_performance_measurement_profiles_global)


  _pyangbind_elements = OrderedDict([('domains', domains), ('state', state), ('performance_measurement_profiles_global', performance_measurement_profiles_global), ])


class yc_oam_openconfig_oam__oam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /oam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
  """
  __slots__ = ('_path_helper', '_extmethods', '__cfm',)

  _yang_name = 'oam'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cfm = YANGDynClass(base=yc_cfm_openconfig_oam__oam_cfm, is_container='container', yang_name="cfm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['oam']

  def _get_cfm(self):
    """
    Getter method for cfm, mapped from YANG variable /oam/cfm (container)

    YANG Description: Container for CFM configuration, state and perfomance measurement policies
    """
    return self.__cfm
      
  def _set_cfm(self, v, load=False):
    """
    Setter method for cfm, mapped from YANG variable /oam/cfm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfm() directly.

    YANG Description: Container for CFM configuration, state and perfomance measurement policies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cfm_openconfig_oam__oam_cfm, is_container='container', yang_name="cfm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cfm_openconfig_oam__oam_cfm, is_container='container', yang_name="cfm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)""",
        })

    self.__cfm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfm(self):
    self.__cfm = YANGDynClass(base=yc_cfm_openconfig_oam__oam_cfm, is_container='container', yang_name="cfm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam/cfm', defining_module='openconfig-oam-cfm', yang_type='container', is_config=True)

  cfm = __builtin__.property(_get_cfm, _set_cfm)


  _pyangbind_elements = OrderedDict([('cfm', cfm), ])


class openconfig_oam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /openconfig-oam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing
EthernetOAM functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__oam',)

  _yang_name = 'openconfig-oam'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oam = YANGDynClass(base=yc_oam_openconfig_oam__oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_oam(self):
    """
    Getter method for oam, mapped from YANG variable /oam (container)

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    return self.__oam
      
  def _set_oam(self, v, load=False):
    """
    Setter method for oam, mapped from YANG variable /oam (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oam() directly.

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oam_openconfig_oam__oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oam must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oam_openconfig_oam__oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)""",
        })

    self.__oam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oam(self):
    self.__oam = YANGDynClass(base=yc_oam_openconfig_oam__oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

  oam = __builtin__.property(_get_oam, _set_oam)


  _pyangbind_elements = OrderedDict([('oam', oam), ])


class openconfig_oam_cfm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam-cfm - based on the path /openconfig-oam-cfm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing CFM
(Connectivity Fault Management) in a network device. The module includes
maintenance domains, associations, maintenance endpoints,
performance management policies and remote defect handling features
  """
  _pyangbind_elements = {}

  

class openconfig_cfm_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-cfm-types - based on the path /openconfig-cfm-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in CFM
  """
  _pyangbind_elements = {}

  

