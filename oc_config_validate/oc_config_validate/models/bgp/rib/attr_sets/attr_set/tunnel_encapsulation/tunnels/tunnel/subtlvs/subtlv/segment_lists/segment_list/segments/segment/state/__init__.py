# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State parameters relating to the segment within
the segment list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__sid','__mpls_tc','__mpls_bos','__mpls_ttl','__remote_ipv4_address','__local_ipv4_address','__remote_ipv6_address','__local_ipv6_address','__local_interface_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'rib', 'attr-sets', 'attr-set', 'tunnel-encapsulation', 'tunnels', 'tunnel', 'subtlvs', 'subtlv', 'segment-lists', 'segment-list', 'segments', 'segment', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the segment within the segment list. The segments are
ordered in ascending order, beginning at 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint64', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)

    YANG Description: The type of segment specified within the segment entry.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of segment specified within the segment entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MPLS_SID': {'value': 1}, 'IPV6_SID': {'value': 2}, 'IPV4_NODE_ADDRESS': {'value': 3}, 'IPV6_NODE_ADDRESS': {'value': 4}, 'IPV4_LOCAL_INTF_ID': {'value': 5}, 'IPV4_LOCAL_REMOTE_ADDR': {'value': 6}, 'IPV6_LOCAL_INTF_ID': {'value': 7}, 'IPV6_LOCAL_REMOTE_ADDR': {'value': 8}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='enumeration', is_config=False)


  def _get_sid(self):
    """
    Getter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    return self.__sid
      
  def _set_sid(self, v, load=False):
    """
    Setter method for sid, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/sid (oc-srt:sr-sid-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sid() directly.

    YANG Description: SID value for the segment entry, specified as an MPLS label
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sid must be of a type compatible with oc-srt:sr-sid-type""",
          'defined-type': "oc-srt:sr-sid-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)""",
        })

    self.__sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sid(self):
    self.__sid = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4_EXPLICIT_NULL': {'value': 0}, 'ROUTER_ALERT': {'value': 1}, 'IPV6_EXPLICIT_NULL': {'value': 2}, 'IMPLICIT_NULL': {'value': 3}, 'ENTROPY_LABEL_INDICATOR': {'value': 7}, 'NO_LABEL': {}},),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-srt:sr-sid-type', is_config=False)


  def _get_mpls_tc(self):
    """
    Getter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    return self.__mpls_tc
      
  def _set_mpls_tc(self, v, load=False):
    """
    Setter method for mpls_tc, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_tc() directly.

    YANG Description: The MPLS TC bits used when the SID is specified as an MPLS
label. If set to zero, the receiving system specifies the
value of the TC bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_tc(self):
    self.__mpls_tc = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="mpls-tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_mpls_bos(self):
    """
    Getter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    return self.__mpls_bos
      
  def _set_mpls_bos(self, v, load=False):
    """
    Setter method for mpls_bos, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_bos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_bos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_bos() directly.

    YANG Description: When this leaf is set to true the MPLS bottom-of-stack
(BoS) bit is set in the MPLS segment. The BoS bit should
always be set to zero by the sender.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_bos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_bos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_bos(self):
    self.__mpls_bos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-bos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='boolean', is_config=False)


  def _get_mpls_ttl(self):
    """
    Getter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    return self.__mpls_ttl
      
  def _set_mpls_ttl(self, v, load=False):
    """
    Setter method for mpls_ttl, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/mpls_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ttl() directly.

    YANG Description: The MPLS time to live (TTL) to be set for the MPLS
segment. If set to 255, the receiver specifies the
TTL value that is used for packets sent with this
segment in the stack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__mpls_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ttl(self):
    self.__mpls_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="mpls-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint8', is_config=False)


  def _get_remote_ipv4_address(self):
    """
    Getter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    return self.__remote_ipv4_address
      
  def _set_remote_ipv4_address(self, v, load=False):
    """
    Setter method for remote_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv4_address() directly.

    YANG Description: An IPv4 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__remote_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv4_address(self):
    self.__remote_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="remote-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_local_ipv4_address(self):
    """
    Getter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    return self.__local_ipv4_address
      
  def _set_local_ipv4_address(self, v, load=False):
    """
    Setter method for local_ipv4_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv4_address() directly.

    YANG Description: An IPv4 address of a local adjacency that is used to identify
the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__local_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv4_address(self):
    self.__local_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}), is_leaf=True, yang_name="local-ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_remote_ipv6_address(self):
    """
    Getter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    return self.__remote_ipv6_address
      
  def _set_remote_ipv6_address(self, v, load=False):
    """
    Setter method for remote_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/remote_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ipv6_address() directly.

    YANG Description: An IPv6 address specified as the remote node address. When the type
of the segment specifies only the remote address, no other addresses
are specified. When the type of the segment requires a local address,
this leaf specifies the remote IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__remote_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ipv6_address(self):
    self.__remote_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="remote-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_ipv6_address(self):
    """
    Getter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    return self.__local_ipv6_address
      
  def _set_local_ipv6_address(self, v, load=False):
    """
    Setter method for local_ipv6_address, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ipv6_address() directly.

    YANG Description: An IPv6 address of a local adjacency that is used to identify the
segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__local_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ipv6_address(self):
    self.__local_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}), is_leaf=True, yang_name="local-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_local_interface_id(self):
    """
    Getter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    return self.__local_interface_id
      
  def _set_local_interface_id(self, v, load=False):
    """
    Setter method for local_interface_id, mapped from YANG variable /bgp/rib/attr_sets/attr_set/tunnel_encapsulation/tunnels/tunnel/subtlvs/subtlv/segment_lists/segment_list/segments/segment/state/local_interface_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface_id() directly.

    YANG Description: The local interface identifier to be utilised for the segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface_id(self):
    self.__local_interface_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='uint32', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  sid = __builtin__.property(_get_sid)
  mpls_tc = __builtin__.property(_get_mpls_tc)
  mpls_bos = __builtin__.property(_get_mpls_bos)
  mpls_ttl = __builtin__.property(_get_mpls_ttl)
  remote_ipv4_address = __builtin__.property(_get_remote_ipv4_address)
  local_ipv4_address = __builtin__.property(_get_local_ipv4_address)
  remote_ipv6_address = __builtin__.property(_get_remote_ipv6_address)
  local_ipv6_address = __builtin__.property(_get_local_ipv6_address)
  local_interface_id = __builtin__.property(_get_local_interface_id)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('sid', sid), ('mpls_tc', mpls_tc), ('mpls_bos', mpls_bos), ('mpls_ttl', mpls_ttl), ('remote_ipv4_address', remote_ipv4_address), ('local_ipv4_address', local_ipv4_address), ('remote_ipv6_address', remote_ipv6_address), ('local_ipv6_address', local_ipv6_address), ('local_interface_id', local_interface_id), ])


