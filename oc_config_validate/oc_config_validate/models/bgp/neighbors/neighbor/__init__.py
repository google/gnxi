# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


from . import config
from . import state
from . import timers
from . import transport
from . import error_handling
from . import graceful_restart
from . import logging_options
from . import ebgp_multihop
from . import route_reflector
from . import as_path_options
from . import use_multiple_paths
from . import apply_policy
from . import afi_safis
from . import enable_bfd
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by peer IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__config','__state','__timers','__transport','__error_handling','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__use_multiple_paths','__apply_policy','__afi_safis','__enable_bfd',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /bgp/neighbors/neighbor/neighbor_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: Reference to the address of the BGP neighbor used as
a key in the neighbor list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/neighbors/neighbor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)

    YANG Description: State information relating to the BGP neighbor
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/neighbors/neighbor/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_enable_bfd(self):
    """
    Getter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    return self.__enable_bfd
      
  def _set_enable_bfd(self, v, load=False):
    """
    Setter method for enable_bfd, mapped from YANG variable /bgp/neighbors/neighbor/enable_bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_bfd() directly.

    YANG Description: Enable BFD for liveliness detection to the next-hop or
neighbour.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__enable_bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_bfd(self):
    self.__enable_bfd = YANGDynClass(base=enable_bfd.enable_bfd, is_container='container', yang_name="enable-bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  neighbor_address = __builtin__.property(_get_neighbor_address, _set_neighbor_address)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  timers = __builtin__.property(_get_timers, _set_timers)
  transport = __builtin__.property(_get_transport, _set_transport)
  error_handling = __builtin__.property(_get_error_handling, _set_error_handling)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart)
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector)
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options)
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths)
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy)
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis)
  enable_bfd = __builtin__.property(_get_enable_bfd, _set_enable_bfd)


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('config', config), ('state', state), ('timers', timers), ('transport', transport), ('error_handling', error_handling), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('enable_bfd', enable_bfd), ])


