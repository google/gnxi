# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import single_tagged
from . import single_tagged_list
from . import single_tagged_range
from . import double_tagged
from . import double_tagged_inner_list
from . import double_tagged_outer_list
from . import double_tagged_inner_range
from . import double_tagged_outer_range
from . import double_tagged_inner_outer_range
class match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/vlan/match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for various VLAN tag matching schemes,
including single-tagged 802.1q packets and double-tagged
802.1ad 'Q-in-Q' packets. Typically only one of the subordinate
containers should be specified.

Wildcards may be matched by specifying range values of 2-4094.
If implementations have a more efficient way to match Wildcards
then they should recognize this pattern and translate accordingly.

Implementations are expected to return errors for combinations
that they do not support, or provide deviations to the same effect.

For simple VLAN configurations without an 'egress-mapping' then
using the 'single-tagged' and 'double-tagged' VLAN matches that
resolve to specific values, these specify the VLAN identifiers
applied to packets on egress.
  """
  __slots__ = ('_path_helper', '_extmethods', '__single_tagged','__single_tagged_list','__single_tagged_range','__double_tagged','__double_tagged_inner_list','__double_tagged_outer_list','__double_tagged_inner_range','__double_tagged_outer_range','__double_tagged_inner_outer_range',)

  _yang_name = 'match'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__single_tagged = YANGDynClass(base=single_tagged.single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__single_tagged_list = YANGDynClass(base=single_tagged_list.single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__single_tagged_range = YANGDynClass(base=single_tagged_range.single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged = YANGDynClass(base=double_tagged.double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_list = YANGDynClass(base=double_tagged_inner_list.double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_outer_list = YANGDynClass(base=double_tagged_outer_list.double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_range = YANGDynClass(base=double_tagged_inner_range.double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_outer_range = YANGDynClass(base=double_tagged_outer_range.double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    self.__double_tagged_inner_outer_range = YANGDynClass(base=double_tagged_inner_outer_range.double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'vlan', 'match']

  def _get_single_tagged(self):
    """
    Getter method for single_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged (container)

    YANG Description: Match single-tagged packets with an exact VLAN identifier.
    """
    return self.__single_tagged
      
  def _set_single_tagged(self, v, load=False):
    """
    Setter method for single_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged() directly.

    YANG Description: Match single-tagged packets with an exact VLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=single_tagged.single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=single_tagged.single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged(self):
    self.__single_tagged = YANGDynClass(base=single_tagged.single_tagged, is_container='container', yang_name="single-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_single_tagged_list(self):
    """
    Getter method for single_tagged_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list (container)

    YANG Description: Match single-tagged packets with a list of VLAN identifiers.
    """
    return self.__single_tagged_list
      
  def _set_single_tagged_list(self, v, load=False):
    """
    Setter method for single_tagged_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged_list() directly.

    YANG Description: Match single-tagged packets with a list of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=single_tagged_list.single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=single_tagged_list.single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged_list(self):
    self.__single_tagged_list = YANGDynClass(base=single_tagged_list.single_tagged_list, is_container='container', yang_name="single-tagged-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_single_tagged_range(self):
    """
    Getter method for single_tagged_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range (container)

    YANG Description: Match single-tagged packets with a range of VLAN identifiers.
    """
    return self.__single_tagged_range
      
  def _set_single_tagged_range(self, v, load=False):
    """
    Setter method for single_tagged_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/single_tagged_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_single_tagged_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_single_tagged_range() directly.

    YANG Description: Match single-tagged packets with a range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=single_tagged_range.single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """single_tagged_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=single_tagged_range.single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__single_tagged_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_single_tagged_range(self):
    self.__single_tagged_range = YANGDynClass(base=single_tagged_range.single_tagged_range, is_container='container', yang_name="single-tagged-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged(self):
    """
    Getter method for double_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged (container)

    YANG Description: Match double-tagged packets against inner exact and outer exact
VLAN identifiers.
    """
    return self.__double_tagged
      
  def _set_double_tagged(self, v, load=False):
    """
    Setter method for double_tagged, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged() directly.

    YANG Description: Match double-tagged packets against inner exact and outer exact
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged.double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged.double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged(self):
    self.__double_tagged = YANGDynClass(base=double_tagged.double_tagged, is_container='container', yang_name="double-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_list(self):
    """
    Getter method for double_tagged_inner_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list (container)

    YANG Description: Match double-tagged packets against an inner list and outer exact
VLAN identifiers.
    """
    return self.__double_tagged_inner_list
      
  def _set_double_tagged_inner_list(self, v, load=False):
    """
    Setter method for double_tagged_inner_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_list() directly.

    YANG Description: Match double-tagged packets against an inner list and outer exact
VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged_inner_list.double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged_inner_list.double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_list(self):
    self.__double_tagged_inner_list = YANGDynClass(base=double_tagged_inner_list.double_tagged_inner_list, is_container='container', yang_name="double-tagged-inner-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_outer_list(self):
    """
    Getter method for double_tagged_outer_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list (container)

    YANG Description: Match double-tagged packets against an inner exact and outer list
of VLAN identifiers.
    """
    return self.__double_tagged_outer_list
      
  def _set_double_tagged_outer_list(self, v, load=False):
    """
    Setter method for double_tagged_outer_list, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_outer_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_outer_list() directly.

    YANG Description: Match double-tagged packets against an inner exact and outer list
of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged_outer_list.double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_outer_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged_outer_list.double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_outer_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_outer_list(self):
    self.__double_tagged_outer_list = YANGDynClass(base=double_tagged_outer_list.double_tagged_outer_list, is_container='container', yang_name="double-tagged-outer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_range(self):
    """
    Getter method for double_tagged_inner_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range (container)

    YANG Description: Match double-tagged packets against an inner range and outer
exact VLAN identifiers.
    """
    return self.__double_tagged_inner_range
      
  def _set_double_tagged_inner_range(self, v, load=False):
    """
    Setter method for double_tagged_inner_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_range() directly.

    YANG Description: Match double-tagged packets against an inner range and outer
exact VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged_inner_range.double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged_inner_range.double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_range(self):
    self.__double_tagged_inner_range = YANGDynClass(base=double_tagged_inner_range.double_tagged_inner_range, is_container='container', yang_name="double-tagged-inner-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_outer_range(self):
    """
    Getter method for double_tagged_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range (container)

    YANG Description: Match double-tagged packets against an inner exact and an outer
range of VLAN identifiers.
    """
    return self.__double_tagged_outer_range
      
  def _set_double_tagged_outer_range(self, v, load=False):
    """
    Setter method for double_tagged_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_outer_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_outer_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_outer_range() directly.

    YANG Description: Match double-tagged packets against an inner exact and an outer
range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged_outer_range.double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_outer_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged_outer_range.double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_outer_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_outer_range(self):
    self.__double_tagged_outer_range = YANGDynClass(base=double_tagged_outer_range.double_tagged_outer_range, is_container='container', yang_name="double-tagged-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)


  def _get_double_tagged_inner_outer_range(self):
    """
    Getter method for double_tagged_inner_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range (container)

    YANG Description: Match double-tagged packets against an inner range and an outer
range of VLAN identifiers.
    """
    return self.__double_tagged_inner_outer_range
      
  def _set_double_tagged_inner_outer_range(self, v, load=False):
    """
    Setter method for double_tagged_inner_outer_range, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/vlan/match/double_tagged_inner_outer_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_double_tagged_inner_outer_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_double_tagged_inner_outer_range() directly.

    YANG Description: Match double-tagged packets against an inner range and an outer
range of VLAN identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=double_tagged_inner_outer_range.double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """double_tagged_inner_outer_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=double_tagged_inner_outer_range.double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)""",
        })

    self.__double_tagged_inner_outer_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_double_tagged_inner_outer_range(self):
    self.__double_tagged_inner_outer_range = YANGDynClass(base=double_tagged_inner_outer_range.double_tagged_inner_outer_range, is_container='container', yang_name="double-tagged-inner-outer-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/vlan', defining_module='openconfig-vlan', yang_type='container', is_config=True)

  single_tagged = __builtin__.property(_get_single_tagged, _set_single_tagged)
  single_tagged_list = __builtin__.property(_get_single_tagged_list, _set_single_tagged_list)
  single_tagged_range = __builtin__.property(_get_single_tagged_range, _set_single_tagged_range)
  double_tagged = __builtin__.property(_get_double_tagged, _set_double_tagged)
  double_tagged_inner_list = __builtin__.property(_get_double_tagged_inner_list, _set_double_tagged_inner_list)
  double_tagged_outer_list = __builtin__.property(_get_double_tagged_outer_list, _set_double_tagged_outer_list)
  double_tagged_inner_range = __builtin__.property(_get_double_tagged_inner_range, _set_double_tagged_inner_range)
  double_tagged_outer_range = __builtin__.property(_get_double_tagged_outer_range, _set_double_tagged_outer_range)
  double_tagged_inner_outer_range = __builtin__.property(_get_double_tagged_inner_outer_range, _set_double_tagged_inner_outer_range)


  _pyangbind_elements = OrderedDict([('single_tagged', single_tagged), ('single_tagged_list', single_tagged_list), ('single_tagged_range', single_tagged_range), ('double_tagged', double_tagged), ('double_tagged_inner_list', double_tagged_inner_list), ('double_tagged_outer_list', double_tagged_outer_list), ('double_tagged_inner_range', double_tagged_inner_range), ('double_tagged_outer_range', double_tagged_outer_range), ('double_tagged_inner_outer_range', double_tagged_inner_outer_range), ])


