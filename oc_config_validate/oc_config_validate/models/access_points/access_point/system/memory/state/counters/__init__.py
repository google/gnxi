# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/memory/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Counters for tracking system memory errors
  """
  __slots__ = ('_path_helper', '_extmethods', '__correctable_ecc_errors','__uncorrectable_ecc_errors','__total_ecc_errors',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__correctable_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="correctable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__uncorrectable_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uncorrectable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    self.__total_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['access-points', 'access-point', 'system', 'memory', 'state', 'counters']

  def _get_correctable_ecc_errors(self):
    """
    Getter method for correctable_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/correctable_ecc_errors (uint64)

    YANG Description: Count of correctable ECC errors. Systems with ECC memory
are capable of correcting Single-bit ECC errors.
    """
    return self.__correctable_ecc_errors
      
  def _set_correctable_ecc_errors(self, v, load=False):
    """
    Setter method for correctable_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/correctable_ecc_errors (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_correctable_ecc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_correctable_ecc_errors() directly.

    YANG Description: Count of correctable ECC errors. Systems with ECC memory
are capable of correcting Single-bit ECC errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="correctable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """correctable_ecc_errors must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="correctable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__correctable_ecc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_correctable_ecc_errors(self):
    self.__correctable_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="correctable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_uncorrectable_ecc_errors(self):
    """
    Getter method for uncorrectable_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/uncorrectable_ecc_errors (uint64)

    YANG Description: Count of uncorrectable ECC errors. Systems with ECC
memory are capable of detecting multi-bit ECC errors,
but cannot correct them.
    """
    return self.__uncorrectable_ecc_errors
      
  def _set_uncorrectable_ecc_errors(self, v, load=False):
    """
    Setter method for uncorrectable_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/uncorrectable_ecc_errors (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uncorrectable_ecc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uncorrectable_ecc_errors() directly.

    YANG Description: Count of uncorrectable ECC errors. Systems with ECC
memory are capable of detecting multi-bit ECC errors,
but cannot correct them.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uncorrectable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uncorrectable_ecc_errors must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uncorrectable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__uncorrectable_ecc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uncorrectable_ecc_errors(self):
    self.__uncorrectable_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="uncorrectable-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)


  def _get_total_ecc_errors(self):
    """
    Getter method for total_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/total_ecc_errors (uint64)

    YANG Description: Count of total ECC errors, this includes both correctable
and uncorrectable ECC errors.
    """
    return self.__total_ecc_errors
      
  def _set_total_ecc_errors(self, v, load=False):
    """
    Setter method for total_ecc_errors, mapped from YANG variable /access_points/access_point/system/memory/state/counters/total_ecc_errors (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_ecc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_ecc_errors() directly.

    YANG Description: Count of total ECC errors, this includes both correctable
and uncorrectable ECC errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_ecc_errors must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)""",
        })

    self.__total_ecc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_ecc_errors(self):
    self.__total_ecc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="total-ecc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint64', is_config=False)

  correctable_ecc_errors = __builtin__.property(_get_correctable_ecc_errors)
  uncorrectable_ecc_errors = __builtin__.property(_get_uncorrectable_ecc_errors)
  total_ecc_errors = __builtin__.property(_get_total_ecc_errors)


  _pyangbind_elements = OrderedDict([('correctable_ecc_errors', correctable_ecc_errors), ('uncorrectable_ecc_errors', uncorrectable_ecc_errors), ('total_ecc_errors', total_ecc_errors), ])


