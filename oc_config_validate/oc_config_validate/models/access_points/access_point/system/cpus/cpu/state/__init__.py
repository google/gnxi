# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import total
from . import user
from . import kernel
from . import nice
from . import idle
from . import wait
from . import hardware_interrupt
from . import software_interrupt
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/system/cpus/cpu/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the system CPU(s)
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__total','__user','__kernel','__nice','__idle','__wait','__hardware_interrupt','__software_interrupt',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    self.__total = YANGDynClass(base=total.total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__user = YANGDynClass(base=user.user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__kernel = YANGDynClass(base=kernel.kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__nice = YANGDynClass(base=nice.nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__idle = YANGDynClass(base=idle.idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__wait = YANGDynClass(base=wait.wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__hardware_interrupt = YANGDynClass(base=hardware_interrupt.hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    self.__software_interrupt = YANGDynClass(base=software_interrupt.software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['access-points', 'access-point', 'system', 'cpus', 'cpu', 'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/index (union)

    YANG Description: The CPU index for each processor core on the system.  On a
single-core system, the index should be zero.  The ALL
index signifies an aggregation of the CPU utilization
statistics over all cores in the system.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/index (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: The CPU index for each processor core on the system.  On a
single-core system, the index should be zero.  The ALL
index signifies an aggregation of the CPU utilization
statistics over all cores in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with union""",
          'defined-type': "openconfig-access-points:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}},),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='union', is_config=False)


  def _get_total(self):
    """
    Getter method for total, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total (container)

    YANG Description: Total CPU utilization.
    """
    return self.__total
      
  def _set_total(self, v, load=False):
    """
    Setter method for total, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total() directly.

    YANG Description: Total CPU utilization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=total.total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=total.total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total(self):
    self.__total = YANGDynClass(base=total.total, is_container='container', yang_name="total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user (container)

    YANG Description: Percentage of CPU time spent running in user space.
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/user (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: Percentage of CPU time spent running in user space.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=user.user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=user.user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=user.user, is_container='container', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_kernel(self):
    """
    Getter method for kernel, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel (container)

    YANG Description: Percentage of CPU time spent running in kernel space.
    """
    return self.__kernel
      
  def _set_kernel(self, v, load=False):
    """
    Setter method for kernel, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/kernel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kernel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kernel() directly.

    YANG Description: Percentage of CPU time spent running in kernel space.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=kernel.kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """kernel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=kernel.kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__kernel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_kernel(self):
    self.__kernel = YANGDynClass(base=kernel.kernel, is_container='container', yang_name="kernel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_nice(self):
    """
    Getter method for nice, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice (container)

    YANG Description: Percentage of CPU time spent running low-priority (niced)
user processes.
    """
    return self.__nice
      
  def _set_nice(self, v, load=False):
    """
    Setter method for nice, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/nice (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nice() directly.

    YANG Description: Percentage of CPU time spent running low-priority (niced)
user processes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=nice.nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nice must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nice.nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__nice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nice(self):
    self.__nice = YANGDynClass(base=nice.nice, is_container='container', yang_name="nice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_idle(self):
    """
    Getter method for idle, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle (container)

    YANG Description: Percentage of CPU time spent idle.
    """
    return self.__idle
      
  def _set_idle(self, v, load=False):
    """
    Setter method for idle, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/idle (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle() directly.

    YANG Description: Percentage of CPU time spent idle.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=idle.idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=idle.idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle(self):
    self.__idle = YANGDynClass(base=idle.idle, is_container='container', yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_wait(self):
    """
    Getter method for wait, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait (container)

    YANG Description: Percentage of CPU time spent waiting for I/O.
    """
    return self.__wait
      
  def _set_wait(self, v, load=False):
    """
    Setter method for wait, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/wait (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait() directly.

    YANG Description: Percentage of CPU time spent waiting for I/O.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=wait.wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=wait.wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__wait = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait(self):
    self.__wait = YANGDynClass(base=wait.wait, is_container='container', yang_name="wait", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_hardware_interrupt(self):
    """
    Getter method for hardware_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt (container)

    YANG Description: Percentage of CPU time spent servicing hardware interrupts.
    """
    return self.__hardware_interrupt
      
  def _set_hardware_interrupt(self, v, load=False):
    """
    Setter method for hardware_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/hardware_interrupt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_interrupt() directly.

    YANG Description: Percentage of CPU time spent servicing hardware interrupts.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hardware_interrupt.hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_interrupt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hardware_interrupt.hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__hardware_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_interrupt(self):
    self.__hardware_interrupt = YANGDynClass(base=hardware_interrupt.hardware_interrupt, is_container='container', yang_name="hardware-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)


  def _get_software_interrupt(self):
    """
    Getter method for software_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt (container)

    YANG Description: Percentage of CPU time spent servicing software interrupts
    """
    return self.__software_interrupt
      
  def _set_software_interrupt(self, v, load=False):
    """
    Setter method for software_interrupt, mapped from YANG variable /access_points/access_point/system/cpus/cpu/state/software_interrupt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_interrupt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_interrupt() directly.

    YANG Description: Percentage of CPU time spent servicing software interrupts
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=software_interrupt.software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_interrupt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=software_interrupt.software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)""",
        })

    self.__software_interrupt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_interrupt(self):
    self.__software_interrupt = YANGDynClass(base=software_interrupt.software_interrupt, is_container='container', yang_name="software-interrupt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  total = __builtin__.property(_get_total)
  user = __builtin__.property(_get_user)
  kernel = __builtin__.property(_get_kernel)
  nice = __builtin__.property(_get_nice)
  idle = __builtin__.property(_get_idle)
  wait = __builtin__.property(_get_wait)
  hardware_interrupt = __builtin__.property(_get_hardware_interrupt)
  software_interrupt = __builtin__.property(_get_software_interrupt)


  _pyangbind_elements = OrderedDict([('index', index), ('total', total), ('user', user), ('kernel', kernel), ('nice', nice), ('idle', idle), ('wait', wait), ('hardware_interrupt', hardware_interrupt), ('software_interrupt', software_interrupt), ])


