# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /access-points/access-point/ssids/ssid/clients/client/dot11k-neighbors/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Client beacon reports. Requires 802.11k
enabled. See Sec. 5.2.7.1 of 802.11k-2008 Standard.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_bssid','__neighbor_channel','__neighbor_rssi','__neighbor_antenna','__channel_load_report',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['access-points', 'access-point', 'ssids', 'ssid', 'clients', 'client', 'dot11k-neighbors', 'state']

  def _get_neighbor_bssid(self):
    """
    Getter method for neighbor_bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)

    YANG Description: The BSSID of this neighbor.
    """
    return self.__neighbor_bssid
      
  def _set_neighbor_bssid(self, v, load=False):
    """
    Setter method for neighbor_bssid, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_bssid() directly.

    YANG Description: The BSSID of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__neighbor_bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_bssid(self):
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='oc-yang:mac-address', is_config=False)


  def _get_neighbor_channel(self):
    """
    Getter method for neighbor_channel, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)

    YANG Description: The channel of this neighbor.
    """
    return self.__neighbor_channel
      
  def _set_neighbor_channel(self, v, load=False):
    """
    Setter method for neighbor_channel, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_channel() directly.

    YANG Description: The channel of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_channel must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_channel(self):
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_neighbor_rssi(self):
    """
    Getter method for neighbor_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative
number.
    """
    return self.__neighbor_rssi
      
  def _set_neighbor_rssi(self, v, load=False):
    """
    Setter method for neighbor_rssi, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_rssi() directly.

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative
number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)""",
        })

    self.__neighbor_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_rssi(self):
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='int8', is_config=False)


  def _get_neighbor_antenna(self):
    """
    Getter method for neighbor_antenna, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)

    YANG Description: Antenna details for this neighbor.
    """
    return self.__neighbor_antenna
      
  def _set_neighbor_antenna(self, v, load=False):
    """
    Setter method for neighbor_antenna, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_antenna is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_antenna() directly.

    YANG Description: Antenna details for this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_antenna must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_antenna = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_antenna(self):
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)


  def _get_channel_load_report(self):
    """
    Getter method for channel_load_report, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013
Spec.
    """
    return self.__channel_load_report
      
  def _set_channel_load_report(self, v, load=False):
    """
    Setter method for channel_load_report, mapped from YANG variable /access_points/access_point/ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_load_report is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_load_report() directly.

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013
Spec.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_load_report must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)""",
        })

    self.__channel_load_report = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_load_report(self):
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='uint8', is_config=False)

  neighbor_bssid = __builtin__.property(_get_neighbor_bssid)
  neighbor_channel = __builtin__.property(_get_neighbor_channel)
  neighbor_rssi = __builtin__.property(_get_neighbor_rssi)
  neighbor_antenna = __builtin__.property(_get_neighbor_antenna)
  channel_load_report = __builtin__.property(_get_channel_load_report)


  _pyangbind_elements = OrderedDict([('neighbor_bssid', neighbor_bssid), ('neighbor_channel', neighbor_channel), ('neighbor_rssi', neighbor_rssi), ('neighbor_antenna', neighbor_antenna), ('channel_load_report', channel_load_report), ])


