# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class yc_config_openconfig_ptp__ptp_instances_instance_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for PTP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ptp/instances/instance/config/id (uint32)

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ptp/instances/instance/config/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_state_openconfig_ptp__ptp_instances_instance_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for PTP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'state']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ptp/instances/instance/state/id (uint32)

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ptp/instances/instance/state/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint32', is_config=False)

  id = __builtin__.property(_get_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_state_openconfig_ptp__ptp_instances_instance_current_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/current-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state current data set of PTP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__steps_removed','__offset_from_master','__mean_path_delay',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__steps_removed = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="steps-removed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    self.__offset_from_master = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="offset-from-master", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)
    self.__mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'current-ds', 'state']

  def _get_steps_removed(self):
    """
    Getter method for steps_removed, mapped from YANG variable /ptp/instances/instance/current_ds/state/steps_removed (uint16)

    YANG Description: The number of PTP Communication Paths traversed
between this PTP Instance and the Grandmaster
PTP Instance.
    """
    return self.__steps_removed
      
  def _set_steps_removed(self, v, load=False):
    """
    Setter method for steps_removed, mapped from YANG variable /ptp/instances/instance/current_ds/state/steps_removed (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steps_removed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steps_removed() directly.

    YANG Description: The number of PTP Communication Paths traversed
between this PTP Instance and the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="steps-removed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steps_removed must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="steps-removed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__steps_removed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steps_removed(self):
    self.__steps_removed = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="steps-removed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)


  def _get_offset_from_master(self):
    """
    Getter method for offset_from_master, mapped from YANG variable /ptp/instances/instance/current_ds/state/offset_from_master (oc-ptp-types:time-interval)

    YANG Description: The current value of the time difference between
a Master PTP Instance and a Slave PTP Instance as
computed by the Slave PTP Instance.
NOTE - When a PTP Profile requires a Boundary
Clock to transfer offset information internally
from Slave PTP Port to Master PTP Port(s), this value
effectively returns the offset from the Grandmaster
PTP Instance.
    """
    return self.__offset_from_master
      
  def _set_offset_from_master(self, v, load=False):
    """
    Setter method for offset_from_master, mapped from YANG variable /ptp/instances/instance/current_ds/state/offset_from_master (oc-ptp-types:time-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset_from_master is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset_from_master() directly.

    YANG Description: The current value of the time difference between
a Master PTP Instance and a Slave PTP Instance as
computed by the Slave PTP Instance.
NOTE - When a PTP Profile requires a Boundary
Clock to transfer offset information internally
from Slave PTP Port to Master PTP Port(s), this value
effectively returns the offset from the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="offset-from-master", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset_from_master must be of a type compatible with oc-ptp-types:time-interval""",
          'defined-type': "oc-ptp-types:time-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="offset-from-master", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)""",
        })

    self.__offset_from_master = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset_from_master(self):
    self.__offset_from_master = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="offset-from-master", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)


  def _get_mean_path_delay(self):
    """
    Getter method for mean_path_delay, mapped from YANG variable /ptp/instances/instance/current_ds/state/mean_path_delay (oc-ptp-types:time-interval)

    YANG Description: In IEEE Std 1588-2008, currentDS.meanDelay was called
currentDS.meanPathDelay. While the specification of
this member is retained in the current standard, the
member is renamed to currentDS.meanDelay. This change
is consistent with other changes that ensure clarity
and consistency of naming, where
- 'path' is associated with the
 request-response mechanism
- 'link' is associated with the
 peer-to-peer delay mechanism
    """
    return self.__mean_path_delay
      
  def _set_mean_path_delay(self, v, load=False):
    """
    Setter method for mean_path_delay, mapped from YANG variable /ptp/instances/instance/current_ds/state/mean_path_delay (oc-ptp-types:time-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mean_path_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mean_path_delay() directly.

    YANG Description: In IEEE Std 1588-2008, currentDS.meanDelay was called
currentDS.meanPathDelay. While the specification of
this member is retained in the current standard, the
member is renamed to currentDS.meanDelay. This change
is consistent with other changes that ensure clarity
and consistency of naming, where
- 'path' is associated with the
 request-response mechanism
- 'link' is associated with the
 peer-to-peer delay mechanism
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mean_path_delay must be of a type compatible with oc-ptp-types:time-interval""",
          'defined-type': "oc-ptp-types:time-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)""",
        })

    self.__mean_path_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mean_path_delay(self):
    self.__mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

  steps_removed = __builtin__.property(_get_steps_removed)
  offset_from_master = __builtin__.property(_get_offset_from_master)
  mean_path_delay = __builtin__.property(_get_mean_path_delay)


  _pyangbind_elements = OrderedDict([('steps_removed', steps_removed), ('offset_from_master', offset_from_master), ('mean_path_delay', mean_path_delay), ])


class yc_current_ds_openconfig_ptp__ptp_instances_instance_current_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/current-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current data set state data of PTP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'current-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_current_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'current-ds']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/current_ds/state (container)

    YANG Description: Operational state current data set of PTP instance.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/current_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state current data set of PTP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_current_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_current_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_current_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_config_openconfig_ptp__ptp_instances_instance_time_properties_ds_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/time-properties-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data of time properties data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__current_utc_offset','__current_utc_offset_valid','__leap59','__leap61','__time_traceable','__frequency_traceable','__ptp_timescale','__time_source',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'time-properties-ds', 'config']

  def _get_current_utc_offset(self):
    """
    Getter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    return self.__current_utc_offset
      
  def _set_current_utc_offset(self, v, load=False):
    """
    Setter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset() directly.

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset must be of a type compatible with int16""",
          'defined-type': "int16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)""",
        })

    self.__current_utc_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset(self):
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)


  def _get_current_utc_offset_valid(self):
    """
    Getter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    return self.__current_utc_offset_valid
      
  def _set_current_utc_offset_valid(self, v, load=False):
    """
    Setter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset_valid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset_valid() directly.

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset_valid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__current_utc_offset_valid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset_valid(self):
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap59(self):
    """
    Getter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    return self.__leap59
      
  def _set_leap59(self, v, load=False):
    """
    Setter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap59 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap59() directly.

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap59 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap59 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap59(self):
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap61(self):
    """
    Getter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    return self.__leap61
      
  def _set_leap61(self, v, load=False):
    """
    Setter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap61 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap61() directly.

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap61 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap61 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap61(self):
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_traceable(self):
    """
    Getter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    return self.__time_traceable
      
  def _set_time_traceable(self, v, load=False):
    """
    Setter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__time_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_traceable(self):
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_frequency_traceable(self):
    """
    Getter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    return self.__frequency_traceable
      
  def _set_frequency_traceable(self, v, load=False):
    """
    Setter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__frequency_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency_traceable(self):
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_ptp_timescale(self):
    """
    Getter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    return self.__ptp_timescale
      
  def _set_ptp_timescale(self, v, load=False):
    """
    Setter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp_timescale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp_timescale() directly.

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp_timescale must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__ptp_timescale = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp_timescale(self):
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_source(self):
    """
    Getter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    return self.__time_source
      
  def _set_time_source(self, v, load=False):
    """
    Setter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_source() directly.

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_source must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)""",
        })

    self.__time_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_source(self):
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

  current_utc_offset = __builtin__.property(_get_current_utc_offset, _set_current_utc_offset)
  current_utc_offset_valid = __builtin__.property(_get_current_utc_offset_valid, _set_current_utc_offset_valid)
  leap59 = __builtin__.property(_get_leap59, _set_leap59)
  leap61 = __builtin__.property(_get_leap61, _set_leap61)
  time_traceable = __builtin__.property(_get_time_traceable, _set_time_traceable)
  frequency_traceable = __builtin__.property(_get_frequency_traceable, _set_frequency_traceable)
  ptp_timescale = __builtin__.property(_get_ptp_timescale, _set_ptp_timescale)
  time_source = __builtin__.property(_get_time_source, _set_time_source)


  _pyangbind_elements = OrderedDict([('current_utc_offset', current_utc_offset), ('current_utc_offset_valid', current_utc_offset_valid), ('leap59', leap59), ('leap61', leap61), ('time_traceable', time_traceable), ('frequency_traceable', frequency_traceable), ('ptp_timescale', ptp_timescale), ('time_source', time_source), ])


class yc_state_openconfig_ptp__ptp_instances_instance_time_properties_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/time-properties-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of time properties data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__current_utc_offset','__current_utc_offset_valid','__leap59','__leap61','__time_traceable','__frequency_traceable','__ptp_timescale','__time_source',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=False)
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'time-properties-ds', 'state']

  def _get_current_utc_offset(self):
    """
    Getter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/current_utc_offset (int16)

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    return self.__current_utc_offset
      
  def _set_current_utc_offset(self, v, load=False):
    """
    Setter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/current_utc_offset (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset() directly.

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset must be of a type compatible with int16""",
          'defined-type': "int16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=False)""",
        })

    self.__current_utc_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset(self):
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=False)


  def _get_current_utc_offset_valid(self):
    """
    Getter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/current_utc_offset_valid (boolean)

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    return self.__current_utc_offset_valid
      
  def _set_current_utc_offset_valid(self, v, load=False):
    """
    Setter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/current_utc_offset_valid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset_valid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset_valid() directly.

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset_valid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__current_utc_offset_valid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset_valid(self):
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_leap59(self):
    """
    Getter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/leap59 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    return self.__leap59
      
  def _set_leap59(self, v, load=False):
    """
    Setter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/leap59 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap59 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap59() directly.

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap59 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__leap59 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap59(self):
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_leap61(self):
    """
    Getter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/leap61 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    return self.__leap61
      
  def _set_leap61(self, v, load=False):
    """
    Setter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/leap61 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap61 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap61() directly.

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap61 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__leap61 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap61(self):
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_time_traceable(self):
    """
    Getter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/time_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    return self.__time_traceable
      
  def _set_time_traceable(self, v, load=False):
    """
    Setter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/time_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__time_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_traceable(self):
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_frequency_traceable(self):
    """
    Getter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/frequency_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    return self.__frequency_traceable
      
  def _set_frequency_traceable(self, v, load=False):
    """
    Setter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/frequency_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__frequency_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency_traceable(self):
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_ptp_timescale(self):
    """
    Getter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/ptp_timescale (boolean)

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    return self.__ptp_timescale
      
  def _set_ptp_timescale(self, v, load=False):
    """
    Setter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/ptp_timescale (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp_timescale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp_timescale() directly.

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp_timescale must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__ptp_timescale = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp_timescale(self):
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_time_source(self):
    """
    Getter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/time_source (identityref)

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    return self.__time_source
      
  def _set_time_source(self, v, load=False):
    """
    Setter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state/time_source (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_source() directly.

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_source must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)""",
        })

    self.__time_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_source(self):
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)

  current_utc_offset = __builtin__.property(_get_current_utc_offset)
  current_utc_offset_valid = __builtin__.property(_get_current_utc_offset_valid)
  leap59 = __builtin__.property(_get_leap59)
  leap61 = __builtin__.property(_get_leap61)
  time_traceable = __builtin__.property(_get_time_traceable)
  frequency_traceable = __builtin__.property(_get_frequency_traceable)
  ptp_timescale = __builtin__.property(_get_ptp_timescale)
  time_source = __builtin__.property(_get_time_source)


  _pyangbind_elements = OrderedDict([('current_utc_offset', current_utc_offset), ('current_utc_offset_valid', current_utc_offset_valid), ('leap59', leap59), ('leap61', leap61), ('time_traceable', time_traceable), ('frequency_traceable', frequency_traceable), ('ptp_timescale', ptp_timescale), ('time_source', time_source), ])


class yc_time_properties_ds_openconfig_ptp__ptp_instances_instance_time_properties_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/time-properties-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Time properties data set of PTP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'time-properties-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_time_properties_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_time_properties_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'time-properties-ds']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config (container)

    YANG Description: Configuration data of time properties data set.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data of time properties data set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_time_properties_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_time_properties_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_time_properties_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state (container)

    YANG Description: Operational state data of time properties data set.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/time_properties_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of time properties data set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_time_properties_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_time_properties_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_time_properties_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds/clock-quality/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config state data of clock-quality
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_class','__clock_accuracy','__offset_scaled_log_variance',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds', 'clock-quality', 'config']

  def _get_clock_class(self):
    """
    Getter method for clock_class, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/clock_class (identityref)

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    return self.__clock_class
      
  def _set_clock_class(self, v, load=False):
    """
    Setter method for clock_class, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/clock_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_class() directly.

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)""",
        })

    self.__clock_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_class(self):
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)


  def _get_clock_accuracy(self):
    """
    Getter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/clock_accuracy (identityref)

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    return self.__clock_accuracy
      
  def _set_clock_accuracy(self, v, load=False):
    """
    Setter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/clock_accuracy (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_accuracy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_accuracy() directly.

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_accuracy must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)""",
        })

    self.__clock_accuracy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_accuracy(self):
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)


  def _get_offset_scaled_log_variance(self):
    """
    Getter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/offset_scaled_log_variance (uint16)

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    return self.__offset_scaled_log_variance
      
  def _set_offset_scaled_log_variance(self, v, load=False):
    """
    Setter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config/offset_scaled_log_variance (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset_scaled_log_variance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset_scaled_log_variance() directly.

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset_scaled_log_variance must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)""",
        })

    self.__offset_scaled_log_variance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset_scaled_log_variance(self):
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)

  clock_class = __builtin__.property(_get_clock_class, _set_clock_class)
  clock_accuracy = __builtin__.property(_get_clock_accuracy, _set_clock_accuracy)
  offset_scaled_log_variance = __builtin__.property(_get_offset_scaled_log_variance, _set_offset_scaled_log_variance)


  _pyangbind_elements = OrderedDict([('clock_class', clock_class), ('clock_accuracy', clock_accuracy), ('offset_scaled_log_variance', offset_scaled_log_variance), ])


class yc_state_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds/clock-quality/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of clock-quality
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_class','__clock_accuracy','__offset_scaled_log_variance',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds', 'clock-quality', 'state']

  def _get_clock_class(self):
    """
    Getter method for clock_class, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/clock_class (identityref)

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    return self.__clock_class
      
  def _set_clock_class(self, v, load=False):
    """
    Setter method for clock_class, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/clock_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_class() directly.

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)""",
        })

    self.__clock_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_class(self):
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)


  def _get_clock_accuracy(self):
    """
    Getter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/clock_accuracy (identityref)

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    return self.__clock_accuracy
      
  def _set_clock_accuracy(self, v, load=False):
    """
    Setter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/clock_accuracy (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_accuracy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_accuracy() directly.

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_accuracy must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)""",
        })

    self.__clock_accuracy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_accuracy(self):
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)


  def _get_offset_scaled_log_variance(self):
    """
    Getter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/offset_scaled_log_variance (uint16)

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    return self.__offset_scaled_log_variance
      
  def _set_offset_scaled_log_variance(self, v, load=False):
    """
    Setter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state/offset_scaled_log_variance (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset_scaled_log_variance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset_scaled_log_variance() directly.

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset_scaled_log_variance must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__offset_scaled_log_variance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset_scaled_log_variance(self):
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  clock_class = __builtin__.property(_get_clock_class)
  clock_accuracy = __builtin__.property(_get_clock_accuracy)
  offset_scaled_log_variance = __builtin__.property(_get_offset_scaled_log_variance)


  _pyangbind_elements = OrderedDict([('clock_class', clock_class), ('clock_accuracy', clock_accuracy), ('offset_scaled_log_variance', offset_scaled_log_variance), ])


class yc_clock_quality_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds/clock-quality. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The IEEE Std 1588 clockQuality of the PTP Instance.
PTP Instances with better quality are more likely to
become the Grandmaster PTP Instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'clock-quality'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds', 'clock-quality']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config (container)

    YANG Description: Config state data of clock-quality
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Config state data of clock-quality
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state (container)

    YANG Description: Operational state data of clock-quality
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of clock-quality
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_ptp__ptp_instances_instance_default_ds_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config state data of default data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__priority1','__priority2','__domain_number','__slave_only','__instance_type','__sdo_id','__network_transport','__unicast_multicast','__domain_profile',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__domain_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__slave_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__instance_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=True)
    self.__sdo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)
    self.__domain_profile = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds', 'config']

  def _get_priority1(self):
    """
    Getter method for priority1, mapped from YANG variable /ptp/instances/instance/default_ds/config/priority1 (uint8)

    YANG Description: The IEEE Std 1588 priority1 of the PTP Instance.
Since priority1 is one of the first comparisons
performed by the Best Master Clock Algorithm (BMCA),
this leaf's configuration can be used to explicitly
select a Grandmaster PTP Instance.
Lower values take precedence.
The value of priority1 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    return self.__priority1
      
  def _set_priority1(self, v, load=False):
    """
    Setter method for priority1, mapped from YANG variable /ptp/instances/instance/default_ds/config/priority1 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority1() directly.

    YANG Description: The IEEE Std 1588 priority1 of the PTP Instance.
Since priority1 is one of the first comparisons
performed by the Best Master Clock Algorithm (BMCA),
this leaf's configuration can be used to explicitly
select a Grandmaster PTP Instance.
Lower values take precedence.
The value of priority1 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority1 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__priority1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority1(self):
    self.__priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_priority2(self):
    """
    Getter method for priority2, mapped from YANG variable /ptp/instances/instance/default_ds/config/priority2 (uint8)

    YANG Description: The IEEE Std 1588 priority2 of the PTP Instance.
The priority2 member is compared by the Best Master
Clock Algorithm (BMCA) after priority1 and clockQuality.
Lower values take precedence.
The value of priority2 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    return self.__priority2
      
  def _set_priority2(self, v, load=False):
    """
    Setter method for priority2, mapped from YANG variable /ptp/instances/instance/default_ds/config/priority2 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority2() directly.

    YANG Description: The IEEE Std 1588 priority2 of the PTP Instance.
The priority2 member is compared by the Best Master
Clock Algorithm (BMCA) after priority1 and clockQuality.
Lower values take precedence.
The value of priority2 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority2 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__priority2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority2(self):
    self.__priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_domain_number(self):
    """
    Getter method for domain_number, mapped from YANG variable /ptp/instances/instance/default_ds/config/domain_number (uint8)

    YANG Description: The IEEE Std 1588 domainNumber of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The domainNumber is the primary mechanism for end users
and system integrators to isolate the operation of a
PTP Instance from PTP messages used in other domains.
The value of the domainNumber shall be configurable
to values permitted in IEEE Std 1588, unless the
allowed values are further restricted by the applicable
PTP Profile.
    """
    return self.__domain_number
      
  def _set_domain_number(self, v, load=False):
    """
    Setter method for domain_number, mapped from YANG variable /ptp/instances/instance/default_ds/config/domain_number (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_number() directly.

    YANG Description: The IEEE Std 1588 domainNumber of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The domainNumber is the primary mechanism for end users
and system integrators to isolate the operation of a
PTP Instance from PTP messages used in other domains.
The value of the domainNumber shall be configurable
to values permitted in IEEE Std 1588, unless the
allowed values are further restricted by the applicable
PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_number must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__domain_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_number(self):
    self.__domain_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_slave_only(self):
    """
    Getter method for slave_only, mapped from YANG variable /ptp/instances/instance/default_ds/config/slave_only (boolean)

    YANG Description: The value of slave-only shall be true if the
PTP Instance is a slave-only PTP Instance
(false for non-slave-only).
The slave-only member can be true for Ordinary Clocks
only.
When slave-only is true, the PTP Instance implements
special behavior in the context of the state machines
that determine port-state.
    """
    return self.__slave_only
      
  def _set_slave_only(self, v, load=False):
    """
    Setter method for slave_only, mapped from YANG variable /ptp/instances/instance/default_ds/config/slave_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slave_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slave_only() directly.

    YANG Description: The value of slave-only shall be true if the
PTP Instance is a slave-only PTP Instance
(false for non-slave-only).
The slave-only member can be true for Ordinary Clocks
only.
When slave-only is true, the PTP Instance implements
special behavior in the context of the state machines
that determine port-state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slave_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__slave_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slave_only(self):
    self.__slave_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_instance_type(self):
    """
    Getter method for instance_type, mapped from YANG variable /ptp/instances/instance/default_ds/config/instance_type (oc-ptp-types:instance-type)

    YANG Description: The type of PTP Instance.
This leaf is read-only unless support for write is
explicitly specified by the applicable PTP Profile or
product specification.
    """
    return self.__instance_type
      
  def _set_instance_type(self, v, load=False):
    """
    Setter method for instance_type, mapped from YANG variable /ptp/instances/instance/default_ds/config/instance_type (oc-ptp-types:instance-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance_type() directly.

    YANG Description: The type of PTP Instance.
This leaf is read-only unless support for write is
explicitly specified by the applicable PTP Profile or
product specification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance_type must be of a type compatible with oc-ptp-types:instance-type""",
          'defined-type': "oc-ptp-types:instance-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=True)""",
        })

    self.__instance_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance_type(self):
    self.__instance_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=True)


  def _get_sdo_id(self):
    """
    Getter method for sdo_id, mapped from YANG variable /ptp/instances/instance/default_ds/config/sdo_id (uint16)

    YANG Description: The IEEE Std 1588 sdoId of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The sdoId of a domain is a 12-bit integer in the
closed range 0 to 4095.
The sdoId member is the primary mechanism for providing
isolation of PTP Instances operating a PTP Profile
specified by a Standards Development Organization (SDO),
from other PTP Instances operating a PTP Profile
specified by a different SDO.
    """
    return self.__sdo_id
      
  def _set_sdo_id(self, v, load=False):
    """
    Setter method for sdo_id, mapped from YANG variable /ptp/instances/instance/default_ds/config/sdo_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sdo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sdo_id() directly.

    YANG Description: The IEEE Std 1588 sdoId of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The sdoId of a domain is a 12-bit integer in the
closed range 0 to 4095.
The sdoId member is the primary mechanism for providing
isolation of PTP Instances operating a PTP Profile
specified by a Standards Development Organization (SDO),
from other PTP Instances operating a PTP Profile
specified by a different SDO.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sdo_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)""",
        })

    self.__sdo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sdo_id(self):
    self.__sdo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)


  def _get_network_transport(self):
    """
    Getter method for network_transport, mapped from YANG variable /ptp/instances/instance/default_ds/config/network_transport (oc-ptp-types:network-transport-enumeration)

    YANG Description: The network transport used for communication
    """
    return self.__network_transport
      
  def _set_network_transport(self, v, load=False):
    """
    Setter method for network_transport, mapped from YANG variable /ptp/instances/instance/default_ds/config/network_transport (oc-ptp-types:network-transport-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_transport() directly.

    YANG Description: The network transport used for communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_transport must be of a type compatible with oc-ptp-types:network-transport-enumeration""",
          'defined-type': "oc-ptp-types:network-transport-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)""",
        })

    self.__network_transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_transport(self):
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)


  def _get_unicast_multicast(self):
    """
    Getter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/default_ds/config/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    return self.__unicast_multicast
      
  def _set_unicast_multicast(self, v, load=False):
    """
    Setter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/default_ds/config/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unicast_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unicast_multicast() directly.

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unicast_multicast must be of a type compatible with oc-ptp-types:unicast-multicast-enumeration""",
          'defined-type': "oc-ptp-types:unicast-multicast-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)""",
        })

    self.__unicast_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unicast_multicast(self):
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)


  def _get_domain_profile(self):
    """
    Getter method for domain_profile, mapped from YANG variable /ptp/instances/instance/default_ds/config/domain_profile (oc-ptp-types:domain-profile-enumeration)

    YANG Description: The method to be used when comparing data sets during
the Best Master Clock Algorithm.
    """
    return self.__domain_profile
      
  def _set_domain_profile(self, v, load=False):
    """
    Setter method for domain_profile, mapped from YANG variable /ptp/instances/instance/default_ds/config/domain_profile (oc-ptp-types:domain-profile-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_profile() directly.

    YANG Description: The method to be used when comparing data sets during
the Best Master Clock Algorithm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_profile must be of a type compatible with oc-ptp-types:domain-profile-enumeration""",
          'defined-type': "oc-ptp-types:domain-profile-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=True)""",
        })

    self.__domain_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_profile(self):
    self.__domain_profile = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=True)

  priority1 = __builtin__.property(_get_priority1, _set_priority1)
  priority2 = __builtin__.property(_get_priority2, _set_priority2)
  domain_number = __builtin__.property(_get_domain_number, _set_domain_number)
  slave_only = __builtin__.property(_get_slave_only, _set_slave_only)
  instance_type = __builtin__.property(_get_instance_type, _set_instance_type)
  sdo_id = __builtin__.property(_get_sdo_id, _set_sdo_id)
  network_transport = __builtin__.property(_get_network_transport, _set_network_transport)
  unicast_multicast = __builtin__.property(_get_unicast_multicast, _set_unicast_multicast)
  domain_profile = __builtin__.property(_get_domain_profile, _set_domain_profile)


  _pyangbind_elements = OrderedDict([('priority1', priority1), ('priority2', priority2), ('domain_number', domain_number), ('slave_only', slave_only), ('instance_type', instance_type), ('sdo_id', sdo_id), ('network_transport', network_transport), ('unicast_multicast', unicast_multicast), ('domain_profile', domain_profile), ])


class yc_state_openconfig_ptp__ptp_instances_instance_default_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of default data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__priority1','__priority2','__domain_number','__slave_only','__instance_type','__sdo_id','__network_transport','__unicast_multicast','__domain_profile','__two_step_flag','__clock_identity','__number_ports',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__domain_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__slave_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__instance_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=False)
    self.__sdo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)
    self.__domain_profile = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=False)
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    self.__number_ports = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds', 'state']

  def _get_priority1(self):
    """
    Getter method for priority1, mapped from YANG variable /ptp/instances/instance/default_ds/state/priority1 (uint8)

    YANG Description: The IEEE Std 1588 priority1 of the PTP Instance.
Since priority1 is one of the first comparisons
performed by the Best Master Clock Algorithm (BMCA),
this leaf's configuration can be used to explicitly
select a Grandmaster PTP Instance.
Lower values take precedence.
The value of priority1 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    return self.__priority1
      
  def _set_priority1(self, v, load=False):
    """
    Setter method for priority1, mapped from YANG variable /ptp/instances/instance/default_ds/state/priority1 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority1() directly.

    YANG Description: The IEEE Std 1588 priority1 of the PTP Instance.
Since priority1 is one of the first comparisons
performed by the Best Master Clock Algorithm (BMCA),
this leaf's configuration can be used to explicitly
select a Grandmaster PTP Instance.
Lower values take precedence.
The value of priority1 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority1 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__priority1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority1(self):
    self.__priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_priority2(self):
    """
    Getter method for priority2, mapped from YANG variable /ptp/instances/instance/default_ds/state/priority2 (uint8)

    YANG Description: The IEEE Std 1588 priority2 of the PTP Instance.
The priority2 member is compared by the Best Master
Clock Algorithm (BMCA) after priority1 and clockQuality.
Lower values take precedence.
The value of priority2 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    return self.__priority2
      
  def _set_priority2(self, v, load=False):
    """
    Setter method for priority2, mapped from YANG variable /ptp/instances/instance/default_ds/state/priority2 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority2() directly.

    YANG Description: The IEEE Std 1588 priority2 of the PTP Instance.
The priority2 member is compared by the Best Master
Clock Algorithm (BMCA) after priority1 and clockQuality.
Lower values take precedence.
The value of priority2 shall be configurable to any
value in the range 0 to 255, unless restricted by
limits established by the applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority2 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__priority2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority2(self):
    self.__priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_domain_number(self):
    """
    Getter method for domain_number, mapped from YANG variable /ptp/instances/instance/default_ds/state/domain_number (uint8)

    YANG Description: The IEEE Std 1588 domainNumber of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The domainNumber is the primary mechanism for end users
and system integrators to isolate the operation of a
PTP Instance from PTP messages used in other domains.
The value of the domainNumber shall be configurable
to values permitted in IEEE Std 1588, unless the
allowed values are further restricted by the applicable
PTP Profile.
    """
    return self.__domain_number
      
  def _set_domain_number(self, v, load=False):
    """
    Setter method for domain_number, mapped from YANG variable /ptp/instances/instance/default_ds/state/domain_number (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_number() directly.

    YANG Description: The IEEE Std 1588 domainNumber of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The domainNumber is the primary mechanism for end users
and system integrators to isolate the operation of a
PTP Instance from PTP messages used in other domains.
The value of the domainNumber shall be configurable
to values permitted in IEEE Std 1588, unless the
allowed values are further restricted by the applicable
PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_number must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__domain_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_number(self):
    self.__domain_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="domain-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_slave_only(self):
    """
    Getter method for slave_only, mapped from YANG variable /ptp/instances/instance/default_ds/state/slave_only (boolean)

    YANG Description: The value of slave-only shall be true if the
PTP Instance is a slave-only PTP Instance
(false for non-slave-only).
The slave-only member can be true for Ordinary Clocks
only.
When slave-only is true, the PTP Instance implements
special behavior in the context of the state machines
that determine port-state.
    """
    return self.__slave_only
      
  def _set_slave_only(self, v, load=False):
    """
    Setter method for slave_only, mapped from YANG variable /ptp/instances/instance/default_ds/state/slave_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slave_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slave_only() directly.

    YANG Description: The value of slave-only shall be true if the
PTP Instance is a slave-only PTP Instance
(false for non-slave-only).
The slave-only member can be true for Ordinary Clocks
only.
When slave-only is true, the PTP Instance implements
special behavior in the context of the state machines
that determine port-state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slave_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__slave_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slave_only(self):
    self.__slave_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="slave-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_instance_type(self):
    """
    Getter method for instance_type, mapped from YANG variable /ptp/instances/instance/default_ds/state/instance_type (oc-ptp-types:instance-type)

    YANG Description: The type of PTP Instance.
This leaf is read-only unless support for write is
explicitly specified by the applicable PTP Profile or
product specification.
    """
    return self.__instance_type
      
  def _set_instance_type(self, v, load=False):
    """
    Setter method for instance_type, mapped from YANG variable /ptp/instances/instance/default_ds/state/instance_type (oc-ptp-types:instance-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance_type() directly.

    YANG Description: The type of PTP Instance.
This leaf is read-only unless support for write is
explicitly specified by the applicable PTP Profile or
product specification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance_type must be of a type compatible with oc-ptp-types:instance-type""",
          'defined-type': "oc-ptp-types:instance-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=False)""",
        })

    self.__instance_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance_type(self):
    self.__instance_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'OC': {'value': 0}, 'BC': {'value': 1}, 'P2P_TC': {'value': 2}, 'E2E_TC': {'value': 3}},), is_leaf=True, yang_name="instance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:instance-type', is_config=False)


  def _get_sdo_id(self):
    """
    Getter method for sdo_id, mapped from YANG variable /ptp/instances/instance/default_ds/state/sdo_id (uint16)

    YANG Description: The IEEE Std 1588 sdoId of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The sdoId of a domain is a 12-bit integer in the
closed range 0 to 4095.
The sdoId member is the primary mechanism for providing
isolation of PTP Instances operating a PTP Profile
specified by a Standards Development Organization (SDO),
from other PTP Instances operating a PTP Profile
specified by a different SDO.
    """
    return self.__sdo_id
      
  def _set_sdo_id(self, v, load=False):
    """
    Setter method for sdo_id, mapped from YANG variable /ptp/instances/instance/default_ds/state/sdo_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sdo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sdo_id() directly.

    YANG Description: The IEEE Std 1588 sdoId of the PTP Instance.
A domain consists of one or more PTP Instances
communicating with each other as defined by the
protocol. A domain shall define the scope of PTP message
communication, state, operations, data sets, and
timescale. Therefore, each domain represents a distinct
time.
Within a PTP Network, a domain is identified by two
data set members: domainNumber and sdoId.
The sdoId of a domain is a 12-bit integer in the
closed range 0 to 4095.
The sdoId member is the primary mechanism for providing
isolation of PTP Instances operating a PTP Profile
specified by a Standards Development Organization (SDO),
from other PTP Instances operating a PTP Profile
specified by a different SDO.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sdo_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__sdo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sdo_id(self):
    self.__sdo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="sdo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)


  def _get_network_transport(self):
    """
    Getter method for network_transport, mapped from YANG variable /ptp/instances/instance/default_ds/state/network_transport (oc-ptp-types:network-transport-enumeration)

    YANG Description: The network transport used for communication
    """
    return self.__network_transport
      
  def _set_network_transport(self, v, load=False):
    """
    Setter method for network_transport, mapped from YANG variable /ptp/instances/instance/default_ds/state/network_transport (oc-ptp-types:network-transport-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_transport() directly.

    YANG Description: The network transport used for communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_transport must be of a type compatible with oc-ptp-types:network-transport-enumeration""",
          'defined-type': "oc-ptp-types:network-transport-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)""",
        })

    self.__network_transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_transport(self):
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)


  def _get_unicast_multicast(self):
    """
    Getter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/default_ds/state/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    return self.__unicast_multicast
      
  def _set_unicast_multicast(self, v, load=False):
    """
    Setter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/default_ds/state/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unicast_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unicast_multicast() directly.

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unicast_multicast must be of a type compatible with oc-ptp-types:unicast-multicast-enumeration""",
          'defined-type': "oc-ptp-types:unicast-multicast-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)""",
        })

    self.__unicast_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unicast_multicast(self):
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)


  def _get_domain_profile(self):
    """
    Getter method for domain_profile, mapped from YANG variable /ptp/instances/instance/default_ds/state/domain_profile (oc-ptp-types:domain-profile-enumeration)

    YANG Description: The method to be used when comparing data sets during
the Best Master Clock Algorithm.
    """
    return self.__domain_profile
      
  def _set_domain_profile(self, v, load=False):
    """
    Setter method for domain_profile, mapped from YANG variable /ptp/instances/instance/default_ds/state/domain_profile (oc-ptp-types:domain-profile-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_profile() directly.

    YANG Description: The method to be used when comparing data sets during
the Best Master Clock Algorithm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_profile must be of a type compatible with oc-ptp-types:domain-profile-enumeration""",
          'defined-type': "oc-ptp-types:domain-profile-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=False)""",
        })

    self.__domain_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_profile(self):
    self.__domain_profile = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IEEE1588': {'value': 1}, 'G8275.1': {'value': 2}, 'G8275.2': {'value': 3}},), is_leaf=True, yang_name="domain-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:domain-profile-enumeration', is_config=False)


  def _get_two_step_flag(self):
    """
    Getter method for two_step_flag, mapped from YANG variable /ptp/instances/instance/default_ds/state/two_step_flag (boolean)

    YANG Description: When set to true, the PTP Instance is two-step,
otherwise the PTP Instance is one-step.
This data set member is no longer used. However,
the twoStepFlag of the PTP common header is used.
One step or two step egress behavior is allowed to
be specified per PTP Port, or per PTP Instance.
Management of the one/two step egress behavior of
a PTP Port is not provided by this standard, but
can be specified as extensions to the data sets by a
PTP Profile or a product specification.
    """
    return self.__two_step_flag
      
  def _set_two_step_flag(self, v, load=False):
    """
    Setter method for two_step_flag, mapped from YANG variable /ptp/instances/instance/default_ds/state/two_step_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_two_step_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_two_step_flag() directly.

    YANG Description: When set to true, the PTP Instance is two-step,
otherwise the PTP Instance is one-step.
This data set member is no longer used. However,
the twoStepFlag of the PTP common header is used.
One step or two step egress behavior is allowed to
be specified per PTP Port, or per PTP Instance.
Management of the one/two step egress behavior of
a PTP Port is not provided by this standard, but
can be specified as extensions to the data sets by a
PTP Profile or a product specification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """two_step_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__two_step_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_two_step_flag(self):
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_clock_identity(self):
    """
    Getter method for clock_identity, mapped from YANG variable /ptp/instances/instance/default_ds/state/clock_identity (oc-ptp-types:clock-identity)

    YANG Description: The IEEE Std 1588 clockIdentity of the PTP Instance.
    """
    return self.__clock_identity
      
  def _set_clock_identity(self, v, load=False):
    """
    Setter method for clock_identity, mapped from YANG variable /ptp/instances/instance/default_ds/state/clock_identity (oc-ptp-types:clock-identity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_identity() directly.

    YANG Description: The IEEE Std 1588 clockIdentity of the PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_identity must be of a type compatible with oc-ptp-types:clock-identity""",
          'defined-type': "oc-ptp-types:clock-identity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)""",
        })

    self.__clock_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_identity(self):
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)


  def _get_number_ports(self):
    """
    Getter method for number_ports, mapped from YANG variable /ptp/instances/instance/default_ds/state/number_ports (uint16)

    YANG Description: The number of PTP Ports on the PTP Instance.
For an Ordinary Clock, the value shall be one.
    """
    return self.__number_ports
      
  def _set_number_ports(self, v, load=False):
    """
    Setter method for number_ports, mapped from YANG variable /ptp/instances/instance/default_ds/state/number_ports (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_ports() directly.

    YANG Description: The number of PTP Ports on the PTP Instance.
For an Ordinary Clock, the value shall be one.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_ports must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__number_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_ports(self):
    self.__number_ports = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  priority1 = __builtin__.property(_get_priority1)
  priority2 = __builtin__.property(_get_priority2)
  domain_number = __builtin__.property(_get_domain_number)
  slave_only = __builtin__.property(_get_slave_only)
  instance_type = __builtin__.property(_get_instance_type)
  sdo_id = __builtin__.property(_get_sdo_id)
  network_transport = __builtin__.property(_get_network_transport)
  unicast_multicast = __builtin__.property(_get_unicast_multicast)
  domain_profile = __builtin__.property(_get_domain_profile)
  two_step_flag = __builtin__.property(_get_two_step_flag)
  clock_identity = __builtin__.property(_get_clock_identity)
  number_ports = __builtin__.property(_get_number_ports)


  _pyangbind_elements = OrderedDict([('priority1', priority1), ('priority2', priority2), ('domain_number', domain_number), ('slave_only', slave_only), ('instance_type', instance_type), ('sdo_id', sdo_id), ('network_transport', network_transport), ('unicast_multicast', unicast_multicast), ('domain_profile', domain_profile), ('two_step_flag', two_step_flag), ('clock_identity', clock_identity), ('number_ports', number_ports), ])


class yc_default_ds_openconfig_ptp__ptp_instances_instance_default_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/default-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The default data set of the PTP Instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_quality','__config','__state',)

  _yang_name = 'default-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_quality = YANGDynClass(base=yc_clock_quality_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality, is_container='container', yang_name="clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'default-ds']

  def _get_clock_quality(self):
    """
    Getter method for clock_quality, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality (container)

    YANG Description: The IEEE Std 1588 clockQuality of the PTP Instance.
PTP Instances with better quality are more likely to
become the Grandmaster PTP Instance.
    """
    return self.__clock_quality
      
  def _set_clock_quality(self, v, load=False):
    """
    Setter method for clock_quality, mapped from YANG variable /ptp/instances/instance/default_ds/clock_quality (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_quality is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_quality() directly.

    YANG Description: The IEEE Std 1588 clockQuality of the PTP Instance.
PTP Instances with better quality are more likely to
become the Grandmaster PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clock_quality_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality, is_container='container', yang_name="clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_quality must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clock_quality_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality, is_container='container', yang_name="clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__clock_quality = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_quality(self):
    self.__clock_quality = YANGDynClass(base=yc_clock_quality_openconfig_ptp__ptp_instances_instance_default_ds_clock_quality, is_container='container', yang_name="clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/default_ds/config (container)

    YANG Description: Config state data of default data set of the clock
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/default_ds/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Config state data of default data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/default_ds/state (container)

    YANG Description: Operational state data of default data set of the clock
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/default_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of default data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  clock_quality = __builtin__.property(_get_clock_quality, _set_clock_quality)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('clock_quality', clock_quality), ('config', config), ('state', state), ])


class yc_parent_port_identity_openconfig_ptp__ptp_instances_instance_parent_ds_state_parent_port_identity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/parent-ds/state/parent-port-identity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The IEEE Std 1588 portIdentity of the PTP Port on the
Master PTP Instance that issues the Sync messages
used in synchronizing this PTP Instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_identity','__port_number',)

  _yang_name = 'parent-port-identity'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'parent-ds', 'state', 'parent-port-identity']

  def _get_clock_identity(self):
    """
    Getter method for clock_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity/clock_identity (oc-ptp-types:clock-identity)

    YANG Description: IEEE Std 1588 clockIdentity.
    """
    return self.__clock_identity
      
  def _set_clock_identity(self, v, load=False):
    """
    Setter method for clock_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity/clock_identity (oc-ptp-types:clock-identity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_identity() directly.

    YANG Description: IEEE Std 1588 clockIdentity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_identity must be of a type compatible with oc-ptp-types:clock-identity""",
          'defined-type': "oc-ptp-types:clock-identity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)""",
        })

    self.__clock_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_identity(self):
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)


  def _get_port_number(self):
    """
    Getter method for port_number, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity/port_number (uint16)

    YANG Description: IEEE Std 1588 portNumber.
If portNumber is unavailable, the value 0 can
be used, or this leaf can be omitted from the
operational datastore.
    """
    return self.__port_number
      
  def _set_port_number(self, v, load=False):
    """
    Setter method for port_number, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity/port_number (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_number() directly.

    YANG Description: IEEE Std 1588 portNumber.
If portNumber is unavailable, the value 0 can
be used, or this leaf can be omitted from the
operational datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_number must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_number(self):
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  clock_identity = __builtin__.property(_get_clock_identity)
  port_number = __builtin__.property(_get_port_number)


  _pyangbind_elements = OrderedDict([('clock_identity', clock_identity), ('port_number', port_number), ])


class yc_grandmaster_clock_quality_openconfig_ptp__ptp_instances_instance_parent_ds_state_grandmaster_clock_quality(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/parent-ds/state/grandmaster-clock-quality. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The IEEE Std 1588 clockQuality of the Grandmaster PTP
Instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_class','__clock_accuracy','__offset_scaled_log_variance',)

  _yang_name = 'grandmaster-clock-quality'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'parent-ds', 'state', 'grandmaster-clock-quality']

  def _get_clock_class(self):
    """
    Getter method for clock_class, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/clock_class (identityref)

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    return self.__clock_class
      
  def _set_clock_class(self, v, load=False):
    """
    Setter method for clock_class, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/clock_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_class() directly.

    YANG Description: The clockClass denotes the traceability of the time
or frequency distributed by the clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)""",
        })

    self.__clock_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_class(self):
    self.__clock_class = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)


  def _get_clock_accuracy(self):
    """
    Getter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/clock_accuracy (identityref)

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    return self.__clock_accuracy
      
  def _set_clock_accuracy(self, v, load=False):
    """
    Setter method for clock_accuracy, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/clock_accuracy (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_accuracy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_accuracy() directly.

    YANG Description: The clockAccuracy indicates the accuracy of the clock
(Local Clock of the PTP Instance).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_accuracy must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)""",
        })

    self.__clock_accuracy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_accuracy(self):
    self.__clock_accuracy = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="clock-accuracy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=False)


  def _get_offset_scaled_log_variance(self):
    """
    Getter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/offset_scaled_log_variance (uint16)

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    return self.__offset_scaled_log_variance
      
  def _set_offset_scaled_log_variance(self, v, load=False):
    """
    Setter method for offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality/offset_scaled_log_variance (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset_scaled_log_variance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset_scaled_log_variance() directly.

    YANG Description: The offsetScaledLogVariance indicates the stability of the
clock (Local Clock of the PTP Instance). It provides an
estimate of the variations of the clock from a linear timescale
when it is not synchronized to another clock using the
protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset_scaled_log_variance must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__offset_scaled_log_variance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset_scaled_log_variance(self):
    self.__offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  clock_class = __builtin__.property(_get_clock_class)
  clock_accuracy = __builtin__.property(_get_clock_accuracy)
  offset_scaled_log_variance = __builtin__.property(_get_offset_scaled_log_variance)


  _pyangbind_elements = OrderedDict([('clock_class', clock_class), ('clock_accuracy', clock_accuracy), ('offset_scaled_log_variance', offset_scaled_log_variance), ])


class yc_state_openconfig_ptp__ptp_instances_instance_parent_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/parent-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of parent data set
  """
  __slots__ = ('_path_helper', '_extmethods', '__parent_port_identity','__parent_stats','__observed_parent_offset_scaled_log_variance','__observed_parent_clock_phase_change_rate','__grandmaster_identity','__grandmaster_clock_quality','__grandmaster_priority1','__grandmaster_priority2',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__parent_port_identity = YANGDynClass(base=yc_parent_port_identity_openconfig_ptp__ptp_instances_instance_parent_ds_state_parent_port_identity, is_container='container', yang_name="parent-port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__parent_stats = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="parent-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__observed_parent_offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="observed-parent-offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    self.__observed_parent_clock_phase_change_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="observed-parent-clock-phase-change-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int32', is_config=False)
    self.__grandmaster_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="grandmaster-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    self.__grandmaster_clock_quality = YANGDynClass(base=yc_grandmaster_clock_quality_openconfig_ptp__ptp_instances_instance_parent_ds_state_grandmaster_clock_quality, is_container='container', yang_name="grandmaster-clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__grandmaster_priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__grandmaster_priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'parent-ds', 'state']

  def _get_parent_port_identity(self):
    """
    Getter method for parent_port_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity (container)

    YANG Description: The IEEE Std 1588 portIdentity of the PTP Port on the
Master PTP Instance that issues the Sync messages
used in synchronizing this PTP Instance.
    """
    return self.__parent_port_identity
      
  def _set_parent_port_identity(self, v, load=False):
    """
    Setter method for parent_port_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_port_identity (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_port_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_port_identity() directly.

    YANG Description: The IEEE Std 1588 portIdentity of the PTP Port on the
Master PTP Instance that issues the Sync messages
used in synchronizing this PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_parent_port_identity_openconfig_ptp__ptp_instances_instance_parent_ds_state_parent_port_identity, is_container='container', yang_name="parent-port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_port_identity must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_parent_port_identity_openconfig_ptp__ptp_instances_instance_parent_ds_state_parent_port_identity, is_container='container', yang_name="parent-port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__parent_port_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_port_identity(self):
    self.__parent_port_identity = YANGDynClass(base=yc_parent_port_identity_openconfig_ptp__ptp_instances_instance_parent_ds_state_parent_port_identity, is_container='container', yang_name="parent-port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_parent_stats(self):
    """
    Getter method for parent_stats, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_stats (boolean)

    YANG Description: When set to true, the values of
parent-ds/observed-parent-offset-scaled-log-variance
and
parent-ds/observed-parent-clock-phase-change-rate
have been measured and are valid.
    """
    return self.__parent_stats
      
  def _set_parent_stats(self, v, load=False):
    """
    Setter method for parent_stats, mapped from YANG variable /ptp/instances/instance/parent_ds/state/parent_stats (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_stats is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_stats() directly.

    YANG Description: When set to true, the values of
parent-ds/observed-parent-offset-scaled-log-variance
and
parent-ds/observed-parent-clock-phase-change-rate
have been measured and are valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="parent-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_stats must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="parent-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__parent_stats = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_stats(self):
    self.__parent_stats = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="parent-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_observed_parent_offset_scaled_log_variance(self):
    """
    Getter method for observed_parent_offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/parent_ds/state/observed_parent_offset_scaled_log_variance (uint16)

    YANG Description: Estimate of the variance of the phase offset of the
Local PTP Clock of the Parent PTP Instance as measured
with respect to the Local PTP Clock in the Slave PTP
Instance. This measurement is optional, but if not made,
the value of parent-ds/parent-stats shall be false.
    """
    return self.__observed_parent_offset_scaled_log_variance
      
  def _set_observed_parent_offset_scaled_log_variance(self, v, load=False):
    """
    Setter method for observed_parent_offset_scaled_log_variance, mapped from YANG variable /ptp/instances/instance/parent_ds/state/observed_parent_offset_scaled_log_variance (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_observed_parent_offset_scaled_log_variance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_observed_parent_offset_scaled_log_variance() directly.

    YANG Description: Estimate of the variance of the phase offset of the
Local PTP Clock of the Parent PTP Instance as measured
with respect to the Local PTP Clock in the Slave PTP
Instance. This measurement is optional, but if not made,
the value of parent-ds/parent-stats shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="observed-parent-offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """observed_parent_offset_scaled_log_variance must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="observed-parent-offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__observed_parent_offset_scaled_log_variance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_observed_parent_offset_scaled_log_variance(self):
    self.__observed_parent_offset_scaled_log_variance = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="observed-parent-offset-scaled-log-variance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)


  def _get_observed_parent_clock_phase_change_rate(self):
    """
    Getter method for observed_parent_clock_phase_change_rate, mapped from YANG variable /ptp/instances/instance/parent_ds/state/observed_parent_clock_phase_change_rate (int32)

    YANG Description: Estimate of the phase change rate of the
Local PTP Clock of the Parent PTP Instance as measured
by the Slave PTP Instance using its Local PTP Clock.
If the estimate exceeds the capacity of its data type,
this value shall be set to 7FFF FFFF (base 16) or
8000 0000 (base 16), as appropriate. A positive sign
indicates that the phase change rate in the
Parent PTP Instance is greater than that in the
Slave PTP Instance. The measurement of this value is
optional, but if not measured, the value of
parent-ds/parent-stats shall be false.
    """
    return self.__observed_parent_clock_phase_change_rate
      
  def _set_observed_parent_clock_phase_change_rate(self, v, load=False):
    """
    Setter method for observed_parent_clock_phase_change_rate, mapped from YANG variable /ptp/instances/instance/parent_ds/state/observed_parent_clock_phase_change_rate (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_observed_parent_clock_phase_change_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_observed_parent_clock_phase_change_rate() directly.

    YANG Description: Estimate of the phase change rate of the
Local PTP Clock of the Parent PTP Instance as measured
by the Slave PTP Instance using its Local PTP Clock.
If the estimate exceeds the capacity of its data type,
this value shall be set to 7FFF FFFF (base 16) or
8000 0000 (base 16), as appropriate. A positive sign
indicates that the phase change rate in the
Parent PTP Instance is greater than that in the
Slave PTP Instance. The measurement of this value is
optional, but if not measured, the value of
parent-ds/parent-stats shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="observed-parent-clock-phase-change-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """observed_parent_clock_phase_change_rate must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="observed-parent-clock-phase-change-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int32', is_config=False)""",
        })

    self.__observed_parent_clock_phase_change_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_observed_parent_clock_phase_change_rate(self):
    self.__observed_parent_clock_phase_change_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="observed-parent-clock-phase-change-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int32', is_config=False)


  def _get_grandmaster_identity(self):
    """
    Getter method for grandmaster_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_identity (oc-ptp-types:clock-identity)

    YANG Description: The IEEE Std 1588 clockIdentity of the Grandmaster PTP
Instance.
    """
    return self.__grandmaster_identity
      
  def _set_grandmaster_identity(self, v, load=False):
    """
    Setter method for grandmaster_identity, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_identity (oc-ptp-types:clock-identity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grandmaster_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grandmaster_identity() directly.

    YANG Description: The IEEE Std 1588 clockIdentity of the Grandmaster PTP
Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="grandmaster-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grandmaster_identity must be of a type compatible with oc-ptp-types:clock-identity""",
          'defined-type': "oc-ptp-types:clock-identity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="grandmaster-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)""",
        })

    self.__grandmaster_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grandmaster_identity(self):
    self.__grandmaster_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="grandmaster-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)


  def _get_grandmaster_clock_quality(self):
    """
    Getter method for grandmaster_clock_quality, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality (container)

    YANG Description: The IEEE Std 1588 clockQuality of the Grandmaster PTP
Instance.
    """
    return self.__grandmaster_clock_quality
      
  def _set_grandmaster_clock_quality(self, v, load=False):
    """
    Setter method for grandmaster_clock_quality, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_clock_quality (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grandmaster_clock_quality is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grandmaster_clock_quality() directly.

    YANG Description: The IEEE Std 1588 clockQuality of the Grandmaster PTP
Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_grandmaster_clock_quality_openconfig_ptp__ptp_instances_instance_parent_ds_state_grandmaster_clock_quality, is_container='container', yang_name="grandmaster-clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grandmaster_clock_quality must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_grandmaster_clock_quality_openconfig_ptp__ptp_instances_instance_parent_ds_state_grandmaster_clock_quality, is_container='container', yang_name="grandmaster-clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__grandmaster_clock_quality = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grandmaster_clock_quality(self):
    self.__grandmaster_clock_quality = YANGDynClass(base=yc_grandmaster_clock_quality_openconfig_ptp__ptp_instances_instance_parent_ds_state_grandmaster_clock_quality, is_container='container', yang_name="grandmaster-clock-quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_grandmaster_priority1(self):
    """
    Getter method for grandmaster_priority1, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_priority1 (uint8)

    YANG Description: The IEEE Std 1588 priority1 of the Grandmaster PTP
Instance.
    """
    return self.__grandmaster_priority1
      
  def _set_grandmaster_priority1(self, v, load=False):
    """
    Setter method for grandmaster_priority1, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_priority1 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grandmaster_priority1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grandmaster_priority1() directly.

    YANG Description: The IEEE Std 1588 priority1 of the Grandmaster PTP
Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grandmaster_priority1 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__grandmaster_priority1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grandmaster_priority1(self):
    self.__grandmaster_priority1 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_grandmaster_priority2(self):
    """
    Getter method for grandmaster_priority2, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_priority2 (uint8)

    YANG Description: The IEEE Std 1588 priority2 of the Grandmaster PTP
Instance.
    """
    return self.__grandmaster_priority2
      
  def _set_grandmaster_priority2(self, v, load=False):
    """
    Setter method for grandmaster_priority2, mapped from YANG variable /ptp/instances/instance/parent_ds/state/grandmaster_priority2 (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grandmaster_priority2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grandmaster_priority2() directly.

    YANG Description: The IEEE Std 1588 priority2 of the Grandmaster PTP
Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grandmaster_priority2 must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__grandmaster_priority2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grandmaster_priority2(self):
    self.__grandmaster_priority2 = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="grandmaster-priority2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)

  parent_port_identity = __builtin__.property(_get_parent_port_identity)
  parent_stats = __builtin__.property(_get_parent_stats)
  observed_parent_offset_scaled_log_variance = __builtin__.property(_get_observed_parent_offset_scaled_log_variance)
  observed_parent_clock_phase_change_rate = __builtin__.property(_get_observed_parent_clock_phase_change_rate)
  grandmaster_identity = __builtin__.property(_get_grandmaster_identity)
  grandmaster_clock_quality = __builtin__.property(_get_grandmaster_clock_quality)
  grandmaster_priority1 = __builtin__.property(_get_grandmaster_priority1)
  grandmaster_priority2 = __builtin__.property(_get_grandmaster_priority2)


  _pyangbind_elements = OrderedDict([('parent_port_identity', parent_port_identity), ('parent_stats', parent_stats), ('observed_parent_offset_scaled_log_variance', observed_parent_offset_scaled_log_variance), ('observed_parent_clock_phase_change_rate', observed_parent_clock_phase_change_rate), ('grandmaster_identity', grandmaster_identity), ('grandmaster_clock_quality', grandmaster_clock_quality), ('grandmaster_priority1', grandmaster_priority1), ('grandmaster_priority2', grandmaster_priority2), ])


class yc_parent_ds_openconfig_ptp__ptp_instances_instance_parent_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/parent-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides data learned from the parent of this PTP Instance (i.e.
master port on the other side of the path/link).
  """
  __slots__ = ('_path_helper', '_extmethods', '__state',)

  _yang_name = 'parent-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_parent_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'parent-ds']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/parent_ds/state (container)

    YANG Description: Operational state data of parent data set
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/parent_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of parent data set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_parent_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_parent_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_parent_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('state', state), ])


class yc_config_openconfig_ptp__ptp_instances_instance_ports_port_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config state data of port data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__underlying_interface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port', 'config']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/config/port_index (uint16)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/config/port_index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)


  def _get_underlying_interface(self):
    """
    Getter method for underlying_interface, mapped from YANG variable /ptp/instances/instance/ports/port/config/underlying_interface (if:interface-ref)

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    return self.__underlying_interface
      
  def _set_underlying_interface(self, v, load=False):
    """
    Setter method for underlying_interface, mapped from YANG variable /ptp/instances/instance/ports/port/config/underlying_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underlying_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underlying_interface() directly.

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underlying_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__underlying_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underlying_interface(self):
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)

  port_index = __builtin__.property(_get_port_index, _set_port_index)
  underlying_interface = __builtin__.property(_get_underlying_interface, _set_underlying_interface)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('underlying_interface', underlying_interface), ])


class yc_state_openconfig_ptp__ptp_instances_instance_ports_port_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: operational state data of port data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__underlying_interface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port', 'state']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/state/port_index (uint16)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/state/port_index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)


  def _get_underlying_interface(self):
    """
    Getter method for underlying_interface, mapped from YANG variable /ptp/instances/instance/ports/port/state/underlying_interface (if:interface-ref)

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    return self.__underlying_interface
      
  def _set_underlying_interface(self, v, load=False):
    """
    Setter method for underlying_interface, mapped from YANG variable /ptp/instances/instance/ports/port/state/underlying_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underlying_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underlying_interface() directly.

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underlying_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__underlying_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underlying_interface(self):
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)

  port_index = __builtin__.property(_get_port_index)
  underlying_interface = __builtin__.property(_get_underlying_interface)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('underlying_interface', underlying_interface), ])


class yc_config_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port/port-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data of port data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_announce_interval','__announce_receipt_timeout','__log_sync_interval','__delay_mechanism','__log_min_pdelay_req_interval','__version_number','__log_min_delay_req_interval','__unicast_multicast',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_announce_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    self.__announce_receipt_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__log_sync_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    self.__version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__log_min_delay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port', 'port-ds', 'config']

  def _get_log_announce_interval(self):
    """
    Getter method for log_announce_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_announce_interval (int8)

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
announceInterval, the time interval between
successive Announce messages sent by a PTP Port.
    """
    return self.__log_announce_interval
      
  def _set_log_announce_interval(self, v, load=False):
    """
    Setter method for log_announce_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_announce_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_announce_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_announce_interval() directly.

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
announceInterval, the time interval between
successive Announce messages sent by a PTP Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_announce_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)""",
        })

    self.__log_announce_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_announce_interval(self):
    self.__log_announce_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)


  def _get_announce_receipt_timeout(self):
    """
    Getter method for announce_receipt_timeout, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/announce_receipt_timeout (uint8)

    YANG Description: The integral multiple of IEEE Std 1588
announceInterval that must pass without receipt of
an Announce message before the occurrence of the
event ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES. The range
shall be 2 to 255 subject to further restrictions of
the applicable PTP Profile. While 2 is permissible,
normally the value should be at least 3.
    """
    return self.__announce_receipt_timeout
      
  def _set_announce_receipt_timeout(self, v, load=False):
    """
    Setter method for announce_receipt_timeout, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/announce_receipt_timeout (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_announce_receipt_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_announce_receipt_timeout() directly.

    YANG Description: The integral multiple of IEEE Std 1588
announceInterval that must pass without receipt of
an Announce message before the occurrence of the
event ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES. The range
shall be 2 to 255 subject to further restrictions of
the applicable PTP Profile. While 2 is permissible,
normally the value should be at least 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """announce_receipt_timeout must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__announce_receipt_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_announce_receipt_timeout(self):
    self.__announce_receipt_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_log_sync_interval(self):
    """
    Getter method for log_sync_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_sync_interval (int8)

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
syncInterval, the time interval between successive
Sync messages, when transmitted as multicast
messages. The rates for unicast transmissions are
negotiated separately on a per PTP Port basis and
are not constrained by this leaf.
    """
    return self.__log_sync_interval
      
  def _set_log_sync_interval(self, v, load=False):
    """
    Setter method for log_sync_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_sync_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_sync_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_sync_interval() directly.

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
syncInterval, the time interval between successive
Sync messages, when transmitted as multicast
messages. The rates for unicast transmissions are
negotiated separately on a per PTP Port basis and
are not constrained by this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_sync_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)""",
        })

    self.__log_sync_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_sync_interval(self):
    self.__log_sync_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)


  def _get_delay_mechanism(self):
    """
    Getter method for delay_mechanism, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)

    YANG Description: The path delay measuring mechanism used by the PTP
Port in computing <meanDelay> (propagation delay).
    """
    return self.__delay_mechanism
      
  def _set_delay_mechanism(self, v, load=False):
    """
    Setter method for delay_mechanism, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_mechanism is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_mechanism() directly.

    YANG Description: The path delay measuring mechanism used by the PTP
Port in computing <meanDelay> (propagation delay).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_mechanism must be of a type compatible with oc-ptp-types:delay-mechanism-enumeration""",
          'defined-type': "oc-ptp-types:delay-mechanism-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)""",
        })

    self.__delay_mechanism = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_mechanism(self):
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)


  def _get_log_min_pdelay_req_interval(self):
    """
    Getter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_min_pdelay_req_interval (int8)

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minPdelayReqInterval, the minimum permitted
mean time interval between successive Pdelay_Req
messages sent over a PTP Link.
    """
    return self.__log_min_pdelay_req_interval
      
  def _set_log_min_pdelay_req_interval(self, v, load=False):
    """
    Setter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_min_pdelay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_pdelay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_pdelay_req_interval() directly.

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minPdelayReqInterval, the minimum permitted
mean time interval between successive Pdelay_Req
messages sent over a PTP Link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_pdelay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)""",
        })

    self.__log_min_pdelay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_pdelay_req_interval(self):
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)


  def _get_version_number(self):
    """
    Getter method for version_number, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/version_number (uint8)

    YANG Description: The PTP major version in use on the PTP Port.
NOTE - This indicates the version of the
IEEE 1588 standard, and not the version of an
applicable PTP Profile.
    """
    return self.__version_number
      
  def _set_version_number(self, v, load=False):
    """
    Setter method for version_number, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/version_number (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version_number() directly.

    YANG Description: The PTP major version in use on the PTP Port.
NOTE - This indicates the version of the
IEEE 1588 standard, and not the version of an
applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version_number must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__version_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version_number(self):
    self.__version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_log_min_delay_req_interval(self):
    """
    Getter method for log_min_delay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_min_delay_req_interval (int8)

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minDelayReqInterval, the minimum permitted
mean time interval between successive Delay_Req
messages sent by a Slave PTP Instance.
    """
    return self.__log_min_delay_req_interval
      
  def _set_log_min_delay_req_interval(self, v, load=False):
    """
    Setter method for log_min_delay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/log_min_delay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_delay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_delay_req_interval() directly.

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minDelayReqInterval, the minimum permitted
mean time interval between successive Delay_Req
messages sent by a Slave PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_delay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)""",
        })

    self.__log_min_delay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_delay_req_interval(self):
    self.__log_min_delay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)


  def _get_unicast_multicast(self):
    """
    Getter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    return self.__unicast_multicast
      
  def _set_unicast_multicast(self, v, load=False):
    """
    Setter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unicast_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unicast_multicast() directly.

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unicast_multicast must be of a type compatible with oc-ptp-types:unicast-multicast-enumeration""",
          'defined-type': "oc-ptp-types:unicast-multicast-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)""",
        })

    self.__unicast_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unicast_multicast(self):
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=True)

  log_announce_interval = __builtin__.property(_get_log_announce_interval, _set_log_announce_interval)
  announce_receipt_timeout = __builtin__.property(_get_announce_receipt_timeout, _set_announce_receipt_timeout)
  log_sync_interval = __builtin__.property(_get_log_sync_interval, _set_log_sync_interval)
  delay_mechanism = __builtin__.property(_get_delay_mechanism, _set_delay_mechanism)
  log_min_pdelay_req_interval = __builtin__.property(_get_log_min_pdelay_req_interval, _set_log_min_pdelay_req_interval)
  version_number = __builtin__.property(_get_version_number, _set_version_number)
  log_min_delay_req_interval = __builtin__.property(_get_log_min_delay_req_interval, _set_log_min_delay_req_interval)
  unicast_multicast = __builtin__.property(_get_unicast_multicast, _set_unicast_multicast)


  _pyangbind_elements = OrderedDict([('log_announce_interval', log_announce_interval), ('announce_receipt_timeout', announce_receipt_timeout), ('log_sync_interval', log_sync_interval), ('delay_mechanism', delay_mechanism), ('log_min_pdelay_req_interval', log_min_pdelay_req_interval), ('version_number', version_number), ('log_min_delay_req_interval', log_min_delay_req_interval), ('unicast_multicast', unicast_multicast), ])


class yc_state_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port/port-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of port data set of the clock
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_announce_interval','__announce_receipt_timeout','__log_sync_interval','__delay_mechanism','__log_min_pdelay_req_interval','__version_number','__log_min_delay_req_interval','__unicast_multicast','__port_state','__peer_mean_path_delay',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_announce_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    self.__announce_receipt_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__log_sync_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    self.__version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__log_min_delay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)
    self.__port_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'INITIALIZING': {'value': 1}, 'FAULTY': {'value': 2}, 'DISABLED': {'value': 3}, 'LISTENING': {'value': 4}, 'PRE_MASTER': {'value': 5}, 'MASTER': {'value': 6}, 'PASSIVE': {'value': 7}, 'UNCALIBRATED': {'value': 8}, 'SLAVE': {'value': 9}},), is_leaf=True, yang_name="port-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:port-state-enumeration', is_config=False)
    self.__peer_mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port', 'port-ds', 'state']

  def _get_log_announce_interval(self):
    """
    Getter method for log_announce_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_announce_interval (int8)

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
announceInterval, the time interval between
successive Announce messages sent by a PTP Port.
    """
    return self.__log_announce_interval
      
  def _set_log_announce_interval(self, v, load=False):
    """
    Setter method for log_announce_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_announce_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_announce_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_announce_interval() directly.

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
announceInterval, the time interval between
successive Announce messages sent by a PTP Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_announce_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)""",
        })

    self.__log_announce_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_announce_interval(self):
    self.__log_announce_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-announce-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)


  def _get_announce_receipt_timeout(self):
    """
    Getter method for announce_receipt_timeout, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/announce_receipt_timeout (uint8)

    YANG Description: The integral multiple of IEEE Std 1588
announceInterval that must pass without receipt of
an Announce message before the occurrence of the
event ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES. The range
shall be 2 to 255 subject to further restrictions of
the applicable PTP Profile. While 2 is permissible,
normally the value should be at least 3.
    """
    return self.__announce_receipt_timeout
      
  def _set_announce_receipt_timeout(self, v, load=False):
    """
    Setter method for announce_receipt_timeout, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/announce_receipt_timeout (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_announce_receipt_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_announce_receipt_timeout() directly.

    YANG Description: The integral multiple of IEEE Std 1588
announceInterval that must pass without receipt of
an Announce message before the occurrence of the
event ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES. The range
shall be 2 to 255 subject to further restrictions of
the applicable PTP Profile. While 2 is permissible,
normally the value should be at least 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """announce_receipt_timeout must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__announce_receipt_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_announce_receipt_timeout(self):
    self.__announce_receipt_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="announce-receipt-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_log_sync_interval(self):
    """
    Getter method for log_sync_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_sync_interval (int8)

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
syncInterval, the time interval between successive
Sync messages, when transmitted as multicast
messages. The rates for unicast transmissions are
negotiated separately on a per PTP Port basis and
are not constrained by this leaf.
    """
    return self.__log_sync_interval
      
  def _set_log_sync_interval(self, v, load=False):
    """
    Setter method for log_sync_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_sync_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_sync_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_sync_interval() directly.

    YANG Description: Logarithm to the base 2 of the mean IEEE Std 1588
syncInterval, the time interval between successive
Sync messages, when transmitted as multicast
messages. The rates for unicast transmissions are
negotiated separately on a per PTP Port basis and
are not constrained by this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_sync_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)""",
        })

    self.__log_sync_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_sync_interval(self):
    self.__log_sync_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-sync-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)


  def _get_delay_mechanism(self):
    """
    Getter method for delay_mechanism, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)

    YANG Description: The path delay measuring mechanism used by the PTP
Port in computing <meanDelay> (propagation delay).
    """
    return self.__delay_mechanism
      
  def _set_delay_mechanism(self, v, load=False):
    """
    Setter method for delay_mechanism, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_mechanism is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_mechanism() directly.

    YANG Description: The path delay measuring mechanism used by the PTP
Port in computing <meanDelay> (propagation delay).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_mechanism must be of a type compatible with oc-ptp-types:delay-mechanism-enumeration""",
          'defined-type': "oc-ptp-types:delay-mechanism-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)""",
        })

    self.__delay_mechanism = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_mechanism(self):
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)


  def _get_log_min_pdelay_req_interval(self):
    """
    Getter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_min_pdelay_req_interval (int8)

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minPdelayReqInterval, the minimum permitted
mean time interval between successive Pdelay_Req
messages sent over a PTP Link.
    """
    return self.__log_min_pdelay_req_interval
      
  def _set_log_min_pdelay_req_interval(self, v, load=False):
    """
    Setter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_min_pdelay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_pdelay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_pdelay_req_interval() directly.

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minPdelayReqInterval, the minimum permitted
mean time interval between successive Pdelay_Req
messages sent over a PTP Link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_pdelay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)""",
        })

    self.__log_min_pdelay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_pdelay_req_interval(self):
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)


  def _get_version_number(self):
    """
    Getter method for version_number, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/version_number (uint8)

    YANG Description: The PTP major version in use on the PTP Port.
NOTE - This indicates the version of the
IEEE 1588 standard, and not the version of an
applicable PTP Profile.
    """
    return self.__version_number
      
  def _set_version_number(self, v, load=False):
    """
    Setter method for version_number, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/version_number (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version_number() directly.

    YANG Description: The PTP major version in use on the PTP Port.
NOTE - This indicates the version of the
IEEE 1588 standard, and not the version of an
applicable PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version_number must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__version_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version_number(self):
    self.__version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_log_min_delay_req_interval(self):
    """
    Getter method for log_min_delay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_min_delay_req_interval (int8)

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minDelayReqInterval, the minimum permitted
mean time interval between successive Delay_Req
messages sent by a Slave PTP Instance.
    """
    return self.__log_min_delay_req_interval
      
  def _set_log_min_delay_req_interval(self, v, load=False):
    """
    Setter method for log_min_delay_req_interval, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/log_min_delay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_delay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_delay_req_interval() directly.

    YANG Description: Logarithm to the base 2 of the IEEE Std 1588
minDelayReqInterval, the minimum permitted
mean time interval between successive Delay_Req
messages sent by a Slave PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_delay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)""",
        })

    self.__log_min_delay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_delay_req_interval(self):
    self.__log_min_delay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-delay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)


  def _get_unicast_multicast(self):
    """
    Getter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    return self.__unicast_multicast
      
  def _set_unicast_multicast(self, v, load=False):
    """
    Setter method for unicast_multicast, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/unicast_multicast (oc-ptp-types:unicast-multicast-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unicast_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unicast_multicast() directly.

    YANG Description: Whether the network transport uses unicast or
multicast communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unicast_multicast must be of a type compatible with oc-ptp-types:unicast-multicast-enumeration""",
          'defined-type': "oc-ptp-types:unicast-multicast-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)""",
        })

    self.__unicast_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unicast_multicast(self):
    self.__unicast_multicast = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'UNICAST': {'value': 1}, 'MULTICAST': {'value': 2}},), is_leaf=True, yang_name="unicast-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:unicast-multicast-enumeration', is_config=False)


  def _get_port_state(self):
    """
    Getter method for port_state, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/port_state (oc-ptp-types:port-state-enumeration)

    YANG Description: Current state of the protocol engine associated
with this PTP Port.
    """
    return self.__port_state
      
  def _set_port_state(self, v, load=False):
    """
    Setter method for port_state, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/port_state (oc-ptp-types:port-state-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_state() directly.

    YANG Description: Current state of the protocol engine associated
with this PTP Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'INITIALIZING': {'value': 1}, 'FAULTY': {'value': 2}, 'DISABLED': {'value': 3}, 'LISTENING': {'value': 4}, 'PRE_MASTER': {'value': 5}, 'MASTER': {'value': 6}, 'PASSIVE': {'value': 7}, 'UNCALIBRATED': {'value': 8}, 'SLAVE': {'value': 9}},), is_leaf=True, yang_name="port-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:port-state-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_state must be of a type compatible with oc-ptp-types:port-state-enumeration""",
          'defined-type': "oc-ptp-types:port-state-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'INITIALIZING': {'value': 1}, 'FAULTY': {'value': 2}, 'DISABLED': {'value': 3}, 'LISTENING': {'value': 4}, 'PRE_MASTER': {'value': 5}, 'MASTER': {'value': 6}, 'PASSIVE': {'value': 7}, 'UNCALIBRATED': {'value': 8}, 'SLAVE': {'value': 9}},), is_leaf=True, yang_name="port-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:port-state-enumeration', is_config=False)""",
        })

    self.__port_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_state(self):
    self.__port_state = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'INITIALIZING': {'value': 1}, 'FAULTY': {'value': 2}, 'DISABLED': {'value': 3}, 'LISTENING': {'value': 4}, 'PRE_MASTER': {'value': 5}, 'MASTER': {'value': 6}, 'PASSIVE': {'value': 7}, 'UNCALIBRATED': {'value': 8}, 'SLAVE': {'value': 9}},), is_leaf=True, yang_name="port-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:port-state-enumeration', is_config=False)


  def _get_peer_mean_path_delay(self):
    """
    Getter method for peer_mean_path_delay, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/peer_mean_path_delay (oc-ptp-types:time-interval)

    YANG Description: In IEEE Std 1588-2008, this data set member was
called portDS.peerMeanPathDelay. While the
specification of this member is retained in the
current standard, the member is renamed to
portDS.meanLinkDelay (i.e., ../mean-link-delay).
This change is consistent with other changes that
ensure clarity and consistency of naming, where
- 'path' is associated with the
 request-response mechanism
- 'link' is associated with the
 peer-to-peer delay mechanism
    """
    return self.__peer_mean_path_delay
      
  def _set_peer_mean_path_delay(self, v, load=False):
    """
    Setter method for peer_mean_path_delay, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state/peer_mean_path_delay (oc-ptp-types:time-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_mean_path_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_mean_path_delay() directly.

    YANG Description: In IEEE Std 1588-2008, this data set member was
called portDS.peerMeanPathDelay. While the
specification of this member is retained in the
current standard, the member is renamed to
portDS.meanLinkDelay (i.e., ../mean-link-delay).
This change is consistent with other changes that
ensure clarity and consistency of naming, where
- 'path' is associated with the
 request-response mechanism
- 'link' is associated with the
 peer-to-peer delay mechanism
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_mean_path_delay must be of a type compatible with oc-ptp-types:time-interval""",
          'defined-type': "oc-ptp-types:time-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)""",
        })

    self.__peer_mean_path_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_mean_path_delay(self):
    self.__peer_mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

  log_announce_interval = __builtin__.property(_get_log_announce_interval)
  announce_receipt_timeout = __builtin__.property(_get_announce_receipt_timeout)
  log_sync_interval = __builtin__.property(_get_log_sync_interval)
  delay_mechanism = __builtin__.property(_get_delay_mechanism)
  log_min_pdelay_req_interval = __builtin__.property(_get_log_min_pdelay_req_interval)
  version_number = __builtin__.property(_get_version_number)
  log_min_delay_req_interval = __builtin__.property(_get_log_min_delay_req_interval)
  unicast_multicast = __builtin__.property(_get_unicast_multicast)
  port_state = __builtin__.property(_get_port_state)
  peer_mean_path_delay = __builtin__.property(_get_peer_mean_path_delay)


  _pyangbind_elements = OrderedDict([('log_announce_interval', log_announce_interval), ('announce_receipt_timeout', announce_receipt_timeout), ('log_sync_interval', log_sync_interval), ('delay_mechanism', delay_mechanism), ('log_min_pdelay_req_interval', log_min_pdelay_req_interval), ('version_number', version_number), ('log_min_delay_req_interval', log_min_delay_req_interval), ('unicast_multicast', unicast_multicast), ('port_state', port_state), ('peer_mean_path_delay', peer_mean_path_delay), ])


class yc_port_ds_openconfig_ptp__ptp_instances_instance_ports_port_port_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port/port-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Primary data set for the PTP Port.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'port-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port', 'port-ds']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config (container)

    YANG Description: Configuration data of port data set of the clock
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data of port data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state (container)

    YANG Description: Operational state data of port data set of the clock
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of port data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_port_openconfig_ptp__ptp_instances_instance_ports_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of data for each PTP Port in the PTP Instance.
While the PTP Instance is disabled, it is possible to
have zero PTP Ports (i.e., ports not yet created).
While the PTP Instance is enabled, an Ordinary Clock
will have one PTP Port, and a Boundary Clock or
Transparent Clock will have more than one PTP Port.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__config','__state','__port_ds',)

  _yang_name = 'port'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__port_ds = YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_instances_instance_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports', 'port']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/port_index (leafref)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/instances/instance/ports/port/port_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/ports/port/config (container)

    YANG Description: Config state data of port data set of the clock
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/ports/port/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Config state data of port data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/ports/port/state (container)

    YANG Description: operational state data of port data set of the clock
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/ports/port/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: operational state data of port data set of the clock
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_port_ds(self):
    """
    Getter method for port_ds, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds (container)

    YANG Description: Primary data set for the PTP Port.
    """
    return self.__port_ds
      
  def _set_port_ds(self, v, load=False):
    """
    Setter method for port_ds, mapped from YANG variable /ptp/instances/instance/ports/port/port_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_ds() directly.

    YANG Description: Primary data set for the PTP Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_ds_openconfig_ptp__ptp_instances_instance_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_instances_instance_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__port_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_ds(self):
    self.__port_ds = YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_instances_instance_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  port_index = __builtin__.property(_get_port_index, _set_port_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  port_ds = __builtin__.property(_get_port_ds, _set_port_ds)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('config', config), ('state', state), ('port_ds', port_ds), ])


class yc_ports_openconfig_ptp__ptp_instances_instance_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG container that is used to get all PTP Ports
in the PTP Instance.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port',)

  _yang_name = 'ports'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_instances_instance_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'ports']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /ptp/instances/instance/ports/port (list)

    YANG Description: List of data for each PTP Port in the PTP Instance.
While the PTP Instance is disabled, it is possible to
have zero PTP Ports (i.e., ports not yet created).
While the PTP Instance is enabled, an Ordinary Clock
will have one PTP Port, and a Boundary Clock or
Transparent Clock will have more than one PTP Port.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /ptp/instances/instance/ports/port (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: List of data for each PTP Port in the PTP Instance.
While the PTP Instance is disabled, it is possible to
have zero PTP Ports (i.e., ports not yet created).
While the PTP Instance is enabled, an Ordinary Clock
will have one PTP Port, and a Boundary Clock or
Transparent Clock will have more than one PTP Port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_instances_instance_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_instances_instance_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_instances_instance_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('port', port), ])


class yc_instance_openconfig_ptp__ptp_instances_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of one or more PTP Instances in the product (PTP Node). Each
PTP Instance represents a distinct instance of PTP implementation
(i.e. distinct Ordinary Clock, Boundary Clock, or Transparent Clock),
maintaining a distinct time. PTP Instances may be created or deleted
dynamically in implementations that support dynamic create/delete.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__config','__state','__current_ds','__time_properties_ds','__default_ds','__parent_ds','__ports',)

  _yang_name = 'instance'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__current_ds = YANGDynClass(base=yc_current_ds_openconfig_ptp__ptp_instances_instance_current_ds, is_container='container', yang_name="current-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__time_properties_ds = YANGDynClass(base=yc_time_properties_ds_openconfig_ptp__ptp_instances_instance_time_properties_ds, is_container='container', yang_name="time-properties-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__default_ds = YANGDynClass(base=yc_default_ds_openconfig_ptp__ptp_instances_instance_default_ds, is_container='container', yang_name="default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__parent_ds = YANGDynClass(base=yc_parent_ds_openconfig_ptp__ptp_instances_instance_parent_ds, is_container='container', yang_name="parent-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__ports = YANGDynClass(base=yc_ports_openconfig_ptp__ptp_instances_instance_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ptp/instances/instance/id (leafref)

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ptp/instances/instance/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The instance list is indexed using a number that is unique per PTP
Instance within the PTP Node, applicable to the management context
only (i.e. not used in PTP messages). The domain-number of the PTP
Instance is not used as the key to instance-list, since it is possible
for a PTP Node to contain multiple PTP Instances using the same
domain-number.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/instances/instance/config (container)

    YANG Description: Configuration data for PTP instance.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/instances/instance/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for PTP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_instances_instance_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_instances_instance_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/instances/instance/state (container)

    YANG Description: Operational state data for PTP instance.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/instances/instance/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for PTP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_instances_instance_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_instances_instance_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_current_ds(self):
    """
    Getter method for current_ds, mapped from YANG variable /ptp/instances/instance/current_ds (container)

    YANG Description: Current data set state data of PTP instance.
    """
    return self.__current_ds
      
  def _set_current_ds(self, v, load=False):
    """
    Setter method for current_ds, mapped from YANG variable /ptp/instances/instance/current_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_ds() directly.

    YANG Description: Current data set state data of PTP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_current_ds_openconfig_ptp__ptp_instances_instance_current_ds, is_container='container', yang_name="current-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_current_ds_openconfig_ptp__ptp_instances_instance_current_ds, is_container='container', yang_name="current-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__current_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_ds(self):
    self.__current_ds = YANGDynClass(base=yc_current_ds_openconfig_ptp__ptp_instances_instance_current_ds, is_container='container', yang_name="current-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_time_properties_ds(self):
    """
    Getter method for time_properties_ds, mapped from YANG variable /ptp/instances/instance/time_properties_ds (container)

    YANG Description: Time properties data set of PTP instance.
    """
    return self.__time_properties_ds
      
  def _set_time_properties_ds(self, v, load=False):
    """
    Setter method for time_properties_ds, mapped from YANG variable /ptp/instances/instance/time_properties_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_properties_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_properties_ds() directly.

    YANG Description: Time properties data set of PTP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_time_properties_ds_openconfig_ptp__ptp_instances_instance_time_properties_ds, is_container='container', yang_name="time-properties-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_properties_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_time_properties_ds_openconfig_ptp__ptp_instances_instance_time_properties_ds, is_container='container', yang_name="time-properties-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__time_properties_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_properties_ds(self):
    self.__time_properties_ds = YANGDynClass(base=yc_time_properties_ds_openconfig_ptp__ptp_instances_instance_time_properties_ds, is_container='container', yang_name="time-properties-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_default_ds(self):
    """
    Getter method for default_ds, mapped from YANG variable /ptp/instances/instance/default_ds (container)

    YANG Description: The default data set of the PTP Instance.
    """
    return self.__default_ds
      
  def _set_default_ds(self, v, load=False):
    """
    Setter method for default_ds, mapped from YANG variable /ptp/instances/instance/default_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_ds() directly.

    YANG Description: The default data set of the PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_default_ds_openconfig_ptp__ptp_instances_instance_default_ds, is_container='container', yang_name="default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_default_ds_openconfig_ptp__ptp_instances_instance_default_ds, is_container='container', yang_name="default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__default_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_ds(self):
    self.__default_ds = YANGDynClass(base=yc_default_ds_openconfig_ptp__ptp_instances_instance_default_ds, is_container='container', yang_name="default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_parent_ds(self):
    """
    Getter method for parent_ds, mapped from YANG variable /ptp/instances/instance/parent_ds (container)

    YANG Description: Provides data learned from the parent of this PTP Instance (i.e.
master port on the other side of the path/link).
    """
    return self.__parent_ds
      
  def _set_parent_ds(self, v, load=False):
    """
    Setter method for parent_ds, mapped from YANG variable /ptp/instances/instance/parent_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_ds() directly.

    YANG Description: Provides data learned from the parent of this PTP Instance (i.e.
master port on the other side of the path/link).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_parent_ds_openconfig_ptp__ptp_instances_instance_parent_ds, is_container='container', yang_name="parent-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_parent_ds_openconfig_ptp__ptp_instances_instance_parent_ds, is_container='container', yang_name="parent-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__parent_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_ds(self):
    self.__parent_ds = YANGDynClass(base=yc_parent_ds_openconfig_ptp__ptp_instances_instance_parent_ds, is_container='container', yang_name="parent-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_ports(self):
    """
    Getter method for ports, mapped from YANG variable /ptp/instances/instance/ports (container)

    YANG Description: YANG container that is used to get all PTP Ports
in the PTP Instance.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
    """
    return self.__ports
      
  def _set_ports(self, v, load=False):
    """
    Setter method for ports, mapped from YANG variable /ptp/instances/instance/ports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ports() directly.

    YANG Description: YANG container that is used to get all PTP Ports
in the PTP Instance.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ports_openconfig_ptp__ptp_instances_instance_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ports_openconfig_ptp__ptp_instances_instance_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ports(self):
    self.__ports = YANGDynClass(base=yc_ports_openconfig_ptp__ptp_instances_instance_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  current_ds = __builtin__.property(_get_current_ds, _set_current_ds)
  time_properties_ds = __builtin__.property(_get_time_properties_ds, _set_time_properties_ds)
  default_ds = __builtin__.property(_get_default_ds, _set_default_ds)
  parent_ds = __builtin__.property(_get_parent_ds, _set_parent_ds)
  ports = __builtin__.property(_get_ports, _set_ports)


  _pyangbind_elements = OrderedDict([('id', id), ('config', config), ('state', state), ('current_ds', current_ds), ('time_properties_ds', time_properties_ds), ('default_ds', default_ds), ('parent_ds', parent_ds), ('ports', ports), ])


class yc_instances_openconfig_ptp__ptp_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG container that is used to get all PTP Instances. YANG does not
allow get of all elements in a YANG list, so a YANG container wrapping
the YANG list is provided for that purpose. The naming convention uses
plural for the wrapping YANG container, and singular for the YANG list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instance',)

  _yang_name = 'instances'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instance = YANGDynClass(base=YANGListType("id",yc_instance_openconfig_ptp__ptp_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances']

  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /ptp/instances/instance (list)

    YANG Description: List of one or more PTP Instances in the product (PTP Node). Each
PTP Instance represents a distinct instance of PTP implementation
(i.e. distinct Ordinary Clock, Boundary Clock, or Transparent Clock),
maintaining a distinct time. PTP Instances may be created or deleted
dynamically in implementations that support dynamic create/delete.
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /ptp/instances/instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.

    YANG Description: List of one or more PTP Instances in the product (PTP Node). Each
PTP Instance represents a distinct instance of PTP implementation
(i.e. distinct Ordinary Clock, Boundary Clock, or Transparent Clock),
maintaining a distinct time. PTP Instances may be created or deleted
dynamically in implementations that support dynamic create/delete.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_instance_openconfig_ptp__ptp_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_instance_openconfig_ptp__ptp_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=YANGListType("id",yc_instance_openconfig_ptp__ptp_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

  instance = __builtin__.property(_get_instance, _set_instance)


  _pyangbind_elements = OrderedDict([('instance', instance), ])


class yc_config_openconfig_ptp__ptp_transparent_clock_default_ds_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-default-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for configuration data of transparent clock.
  """
  __slots__ = ('_path_helper', '_extmethods', '__delay_mechanism','__primary_domain','__two_step_flag',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)
    self.__primary_domain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-default-ds', 'config']

  def _get_delay_mechanism(self):
    """
    Getter method for delay_mechanism, mapped from YANG variable /ptp/transparent_clock_default_ds/config/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)

    YANG Description: The propagation delay measuring mechanism (e2e or p2p).
    """
    return self.__delay_mechanism
      
  def _set_delay_mechanism(self, v, load=False):
    """
    Setter method for delay_mechanism, mapped from YANG variable /ptp/transparent_clock_default_ds/config/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_mechanism is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_mechanism() directly.

    YANG Description: The propagation delay measuring mechanism (e2e or p2p).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_mechanism must be of a type compatible with oc-ptp-types:delay-mechanism-enumeration""",
          'defined-type': "oc-ptp-types:delay-mechanism-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)""",
        })

    self.__delay_mechanism = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_mechanism(self):
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=True)


  def _get_primary_domain(self):
    """
    Getter method for primary_domain, mapped from YANG variable /ptp/transparent_clock_default_ds/config/primary_domain (uint8)

    YANG Description: The domainNumber of the primary syntonization domain.
    """
    return self.__primary_domain
      
  def _set_primary_domain(self, v, load=False):
    """
    Setter method for primary_domain, mapped from YANG variable /ptp/transparent_clock_default_ds/config/primary_domain (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_domain() directly.

    YANG Description: The domainNumber of the primary syntonization domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_domain must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)""",
        })

    self.__primary_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_domain(self):
    self.__primary_domain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=True)


  def _get_two_step_flag(self):
    """
    Getter method for two_step_flag, mapped from YANG variable /ptp/transparent_clock_default_ds/config/two_step_flag (boolean)

    YANG Description: When set to true, the clock is a two-step clock;
otherwise,the clock is a one-step clock.
    """
    return self.__two_step_flag
      
  def _set_two_step_flag(self, v, load=False):
    """
    Setter method for two_step_flag, mapped from YANG variable /ptp/transparent_clock_default_ds/config/two_step_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_two_step_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_two_step_flag() directly.

    YANG Description: When set to true, the clock is a two-step clock;
otherwise,the clock is a one-step clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """two_step_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__two_step_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_two_step_flag(self):
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)

  delay_mechanism = __builtin__.property(_get_delay_mechanism, _set_delay_mechanism)
  primary_domain = __builtin__.property(_get_primary_domain, _set_primary_domain)
  two_step_flag = __builtin__.property(_get_two_step_flag, _set_two_step_flag)


  _pyangbind_elements = OrderedDict([('delay_mechanism', delay_mechanism), ('primary_domain', primary_domain), ('two_step_flag', two_step_flag), ])


class yc_state_openconfig_ptp__ptp_transparent_clock_default_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-default-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for operational state data of transparent clock.
  """
  __slots__ = ('_path_helper', '_extmethods', '__delay_mechanism','__primary_domain','__two_step_flag','__clock_identity','__number_ports',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)
    self.__primary_domain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    self.__number_ports = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-default-ds', 'state']

  def _get_delay_mechanism(self):
    """
    Getter method for delay_mechanism, mapped from YANG variable /ptp/transparent_clock_default_ds/state/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)

    YANG Description: The propagation delay measuring mechanism (e2e or p2p).
    """
    return self.__delay_mechanism
      
  def _set_delay_mechanism(self, v, load=False):
    """
    Setter method for delay_mechanism, mapped from YANG variable /ptp/transparent_clock_default_ds/state/delay_mechanism (oc-ptp-types:delay-mechanism-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay_mechanism is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay_mechanism() directly.

    YANG Description: The propagation delay measuring mechanism (e2e or p2p).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay_mechanism must be of a type compatible with oc-ptp-types:delay-mechanism-enumeration""",
          'defined-type': "oc-ptp-types:delay-mechanism-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)""",
        })

    self.__delay_mechanism = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay_mechanism(self):
    self.__delay_mechanism = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'E2E': {'value': 1}, 'P2P': {'value': 2}, 'DISABLED': {'value': 254}},), is_leaf=True, yang_name="delay-mechanism", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:delay-mechanism-enumeration', is_config=False)


  def _get_primary_domain(self):
    """
    Getter method for primary_domain, mapped from YANG variable /ptp/transparent_clock_default_ds/state/primary_domain (uint8)

    YANG Description: The domainNumber of the primary syntonization domain.
    """
    return self.__primary_domain
      
  def _set_primary_domain(self, v, load=False):
    """
    Setter method for primary_domain, mapped from YANG variable /ptp/transparent_clock_default_ds/state/primary_domain (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_domain() directly.

    YANG Description: The domainNumber of the primary syntonization domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_domain must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)""",
        })

    self.__primary_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_domain(self):
    self.__primary_domain = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="primary-domain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint8', is_config=False)


  def _get_two_step_flag(self):
    """
    Getter method for two_step_flag, mapped from YANG variable /ptp/transparent_clock_default_ds/state/two_step_flag (boolean)

    YANG Description: When set to true, the clock is a two-step clock;
otherwise,the clock is a one-step clock.
    """
    return self.__two_step_flag
      
  def _set_two_step_flag(self, v, load=False):
    """
    Setter method for two_step_flag, mapped from YANG variable /ptp/transparent_clock_default_ds/state/two_step_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_two_step_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_two_step_flag() directly.

    YANG Description: When set to true, the clock is a two-step clock;
otherwise,the clock is a one-step clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """two_step_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__two_step_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_two_step_flag(self):
    self.__two_step_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="two-step-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_clock_identity(self):
    """
    Getter method for clock_identity, mapped from YANG variable /ptp/transparent_clock_default_ds/state/clock_identity (oc-ptp-types:clock-identity)

    YANG Description: The clockIdentity of the local clock.
    """
    return self.__clock_identity
      
  def _set_clock_identity(self, v, load=False):
    """
    Setter method for clock_identity, mapped from YANG variable /ptp/transparent_clock_default_ds/state/clock_identity (oc-ptp-types:clock-identity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_identity() directly.

    YANG Description: The clockIdentity of the local clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_identity must be of a type compatible with oc-ptp-types:clock-identity""",
          'defined-type': "oc-ptp-types:clock-identity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)""",
        })

    self.__clock_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_identity(self):
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)


  def _get_number_ports(self):
    """
    Getter method for number_ports, mapped from YANG variable /ptp/transparent_clock_default_ds/state/number_ports (uint16)

    YANG Description: The number of PTP Ports of the device.
    """
    return self.__number_ports
      
  def _set_number_ports(self, v, load=False):
    """
    Setter method for number_ports, mapped from YANG variable /ptp/transparent_clock_default_ds/state/number_ports (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_ports() directly.

    YANG Description: The number of PTP Ports of the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_ports must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__number_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_ports(self):
    self.__number_ports = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="number-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  delay_mechanism = __builtin__.property(_get_delay_mechanism)
  primary_domain = __builtin__.property(_get_primary_domain)
  two_step_flag = __builtin__.property(_get_two_step_flag)
  clock_identity = __builtin__.property(_get_clock_identity)
  number_ports = __builtin__.property(_get_number_ports)


  _pyangbind_elements = OrderedDict([('delay_mechanism', delay_mechanism), ('primary_domain', primary_domain), ('two_step_flag', two_step_flag), ('clock_identity', clock_identity), ('number_ports', number_ports), ])


class yc_transparent_clock_default_ds_openconfig_ptp__ptp_transparent_clock_default_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-default-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This default data set was specified in
IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this data set is specified as
applying to the PTP Node (all domains), but the data set is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance and
domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'transparent-clock-default-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-default-ds']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/transparent_clock_default_ds/config (container)

    YANG Description: Top-level container for configuration data of transparent clock.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/transparent_clock_default_ds/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level container for configuration data of transparent clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_transparent_clock_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_default_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/transparent_clock_default_ds/state (container)

    YANG Description: Top-level container for operational state data of transparent clock.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/transparent_clock_default_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top-level container for operational state data of transparent clock.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_transparent_clock_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_default_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for configuration data of transparent clock port.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__underlying_interface',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'config']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/config/port_index (uint16)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/config/port_index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=True)


  def _get_underlying_interface(self):
    """
    Getter method for underlying_interface, mapped from YANG variable /ptp/transparent_clock_ports/port/config/underlying_interface (if:interface-ref)

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    return self.__underlying_interface
      
  def _set_underlying_interface(self, v, load=False):
    """
    Setter method for underlying_interface, mapped from YANG variable /ptp/transparent_clock_ports/port/config/underlying_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underlying_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underlying_interface() directly.

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underlying_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__underlying_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underlying_interface(self):
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=True)

  port_index = __builtin__.property(_get_port_index, _set_port_index)
  underlying_interface = __builtin__.property(_get_underlying_interface, _set_underlying_interface)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('underlying_interface', underlying_interface), ])


class yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for operational state data of transparent clock port.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__underlying_interface',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'state']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/state/port_index (uint16)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/state/port_index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)


  def _get_underlying_interface(self):
    """
    Getter method for underlying_interface, mapped from YANG variable /ptp/transparent_clock_ports/port/state/underlying_interface (if:interface-ref)

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    return self.__underlying_interface
      
  def _set_underlying_interface(self, v, load=False):
    """
    Setter method for underlying_interface, mapped from YANG variable /ptp/transparent_clock_ports/port/state/underlying_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underlying_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underlying_interface() directly.

    YANG Description: Reference to the configured underlying IETF YANG
interface that is used by this PTP Port for
transport of PTP messages. Among other data,
physical identifiers for the interface
(e.g., MAC address) can be obtained using this
reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underlying_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__underlying_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underlying_interface(self):
    self.__underlying_interface = YANGDynClass(base=str, is_leaf=True, yang_name="underlying-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='if:interface-ref', is_config=False)

  port_index = __builtin__.property(_get_port_index)
  underlying_interface = __builtin__.property(_get_underlying_interface)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('underlying_interface', underlying_interface), ])


class yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/port-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data of transparent clock port data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_min_pdelay_req_interval','__faulty_flag','__network_transport',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    self.__faulty_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'port-ds', 'config']

  def _get_log_min_pdelay_req_interval(self):
    """
    Getter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/log_min_pdelay_req_interval (int8)

    YANG Description: The logarithm to the base 2 of the
minPdelayReqInterval (minimum permitted mean time
interval between successive Pdelay_Req messages).
    """
    return self.__log_min_pdelay_req_interval
      
  def _set_log_min_pdelay_req_interval(self, v, load=False):
    """
    Setter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/log_min_pdelay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_pdelay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_pdelay_req_interval() directly.

    YANG Description: The logarithm to the base 2 of the
minPdelayReqInterval (minimum permitted mean time
interval between successive Pdelay_Req messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_pdelay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)""",
        })

    self.__log_min_pdelay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_pdelay_req_interval(self):
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=True)


  def _get_faulty_flag(self):
    """
    Getter method for faulty_flag, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/faulty_flag (boolean)

    YANG Description: Shall be true if the port is faulty and false
if the port is operating normally.
    """
    return self.__faulty_flag
      
  def _set_faulty_flag(self, v, load=False):
    """
    Setter method for faulty_flag, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/faulty_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_faulty_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_faulty_flag() directly.

    YANG Description: Shall be true if the port is faulty and false
if the port is operating normally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """faulty_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__faulty_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_faulty_flag(self):
    self.__faulty_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_network_transport(self):
    """
    Getter method for network_transport, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/network_transport (oc-ptp-types:network-transport-enumeration)

    YANG Description: The network transport used for communication
    """
    return self.__network_transport
      
  def _set_network_transport(self, v, load=False):
    """
    Setter method for network_transport, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config/network_transport (oc-ptp-types:network-transport-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_transport() directly.

    YANG Description: The network transport used for communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_transport must be of a type compatible with oc-ptp-types:network-transport-enumeration""",
          'defined-type': "oc-ptp-types:network-transport-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)""",
        })

    self.__network_transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_transport(self):
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=True)

  log_min_pdelay_req_interval = __builtin__.property(_get_log_min_pdelay_req_interval, _set_log_min_pdelay_req_interval)
  faulty_flag = __builtin__.property(_get_faulty_flag, _set_faulty_flag)
  network_transport = __builtin__.property(_get_network_transport, _set_network_transport)


  _pyangbind_elements = OrderedDict([('log_min_pdelay_req_interval', log_min_pdelay_req_interval), ('faulty_flag', faulty_flag), ('network_transport', network_transport), ])


class yc_port_identity_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state_port_identity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/port-ds/state/port-identity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The IEEE Std 1588 portIdentity of this port.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clock_identity','__port_number',)

  _yang_name = 'port-identity'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'port-ds', 'state', 'port-identity']

  def _get_clock_identity(self):
    """
    Getter method for clock_identity, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity/clock_identity (oc-ptp-types:clock-identity)

    YANG Description: IEEE Std 1588 clockIdentity.
    """
    return self.__clock_identity
      
  def _set_clock_identity(self, v, load=False):
    """
    Setter method for clock_identity, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity/clock_identity (oc-ptp-types:clock-identity)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock_identity() directly.

    YANG Description: IEEE Std 1588 clockIdentity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock_identity must be of a type compatible with oc-ptp-types:clock-identity""",
          'defined-type': "oc-ptp-types:clock-identity",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)""",
        })

    self.__clock_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock_identity(self):
    self.__clock_identity = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '[0-9A-F]{2}(-[0-9A-F]{2}){7}'}), is_leaf=True, yang_name="clock-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:clock-identity', is_config=False)


  def _get_port_number(self):
    """
    Getter method for port_number, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity/port_number (uint16)

    YANG Description: IEEE Std 1588 portNumber.
If portNumber is unavailable, the value 0 can
be used, or this leaf can be omitted from the
operational datastore.
    """
    return self.__port_number
      
  def _set_port_number(self, v, load=False):
    """
    Setter method for port_number, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity/port_number (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_number() directly.

    YANG Description: IEEE Std 1588 portNumber.
If portNumber is unavailable, the value 0 can
be used, or this leaf can be omitted from the
operational datastore.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_number must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)""",
        })

    self.__port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_number(self):
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='uint16', is_config=False)

  clock_identity = __builtin__.property(_get_clock_identity)
  port_number = __builtin__.property(_get_port_number)


  _pyangbind_elements = OrderedDict([('clock_identity', clock_identity), ('port_number', port_number), ])


class yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/port-ds/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data of transparent clock port data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_min_pdelay_req_interval','__faulty_flag','__network_transport','__port_identity','__peer_mean_path_delay',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    self.__faulty_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)
    self.__port_identity = YANGDynClass(base=yc_port_identity_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state_port_identity, is_container='container', yang_name="port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__peer_mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'port-ds', 'state']

  def _get_log_min_pdelay_req_interval(self):
    """
    Getter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/log_min_pdelay_req_interval (int8)

    YANG Description: The logarithm to the base 2 of the
minPdelayReqInterval (minimum permitted mean time
interval between successive Pdelay_Req messages).
    """
    return self.__log_min_pdelay_req_interval
      
  def _set_log_min_pdelay_req_interval(self, v, load=False):
    """
    Setter method for log_min_pdelay_req_interval, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/log_min_pdelay_req_interval (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_min_pdelay_req_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_min_pdelay_req_interval() directly.

    YANG Description: The logarithm to the base 2 of the
minPdelayReqInterval (minimum permitted mean time
interval between successive Pdelay_Req messages).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_min_pdelay_req_interval must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)""",
        })

    self.__log_min_pdelay_req_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_min_pdelay_req_interval(self):
    self.__log_min_pdelay_req_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="log-min-pdelay-req-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int8', is_config=False)


  def _get_faulty_flag(self):
    """
    Getter method for faulty_flag, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/faulty_flag (boolean)

    YANG Description: Shall be true if the port is faulty and false
if the port is operating normally.
    """
    return self.__faulty_flag
      
  def _set_faulty_flag(self, v, load=False):
    """
    Setter method for faulty_flag, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/faulty_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_faulty_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_faulty_flag() directly.

    YANG Description: Shall be true if the port is faulty and false
if the port is operating normally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """faulty_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)""",
        })

    self.__faulty_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_faulty_flag(self):
    self.__faulty_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="faulty-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=False)


  def _get_network_transport(self):
    """
    Getter method for network_transport, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/network_transport (oc-ptp-types:network-transport-enumeration)

    YANG Description: The network transport used for communication
    """
    return self.__network_transport
      
  def _set_network_transport(self, v, load=False):
    """
    Setter method for network_transport, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/network_transport (oc-ptp-types:network-transport-enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_transport() directly.

    YANG Description: The network transport used for communication
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_transport must be of a type compatible with oc-ptp-types:network-transport-enumeration""",
          'defined-type': "oc-ptp-types:network-transport-enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)""",
        })

    self.__network_transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_transport(self):
    self.__network_transport = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'L2': {'value': 1}, 'UDPV4': {'value': 2}, 'UDPV6': {'value': 3}},), is_leaf=True, yang_name="network-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:network-transport-enumeration', is_config=False)


  def _get_port_identity(self):
    """
    Getter method for port_identity, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity (container)

    YANG Description: The IEEE Std 1588 portIdentity of this port.
    """
    return self.__port_identity
      
  def _set_port_identity(self, v, load=False):
    """
    Setter method for port_identity, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/port_identity (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_identity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_identity() directly.

    YANG Description: The IEEE Std 1588 portIdentity of this port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_identity_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state_port_identity, is_container='container', yang_name="port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_identity must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_identity_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state_port_identity, is_container='container', yang_name="port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__port_identity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_identity(self):
    self.__port_identity = YANGDynClass(base=yc_port_identity_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state_port_identity, is_container='container', yang_name="port-identity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_peer_mean_path_delay(self):
    """
    Getter method for peer_mean_path_delay, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/peer_mean_path_delay (oc-ptp-types:time-interval)

    YANG Description: An estimate of the current one-way propagation delay
on the link when the delayMechanism is P2P; otherwise,
it is zero.
    """
    return self.__peer_mean_path_delay
      
  def _set_peer_mean_path_delay(self, v, load=False):
    """
    Setter method for peer_mean_path_delay, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state/peer_mean_path_delay (oc-ptp-types:time-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_mean_path_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_mean_path_delay() directly.

    YANG Description: An estimate of the current one-way propagation delay
on the link when the delayMechanism is P2P; otherwise,
it is zero.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_mean_path_delay must be of a type compatible with oc-ptp-types:time-interval""",
          'defined-type': "oc-ptp-types:time-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)""",
        })

    self.__peer_mean_path_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_mean_path_delay(self):
    self.__peer_mean_path_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="peer-mean-path-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='oc-ptp-types:time-interval', is_config=False)

  log_min_pdelay_req_interval = __builtin__.property(_get_log_min_pdelay_req_interval)
  faulty_flag = __builtin__.property(_get_faulty_flag)
  network_transport = __builtin__.property(_get_network_transport)
  port_identity = __builtin__.property(_get_port_identity)
  peer_mean_path_delay = __builtin__.property(_get_peer_mean_path_delay)


  _pyangbind_elements = OrderedDict([('log_min_pdelay_req_interval', log_min_pdelay_req_interval), ('faulty_flag', faulty_flag), ('network_transport', network_transport), ('port_identity', port_identity), ('peer_mean_path_delay', peer_mean_path_delay), ])


class yc_port_ds_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port/port-ds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IEEE Std 1588 transparentClockPortDS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'port-ds'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port', 'port-ds']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config (container)

    YANG Description: Configuration data of transparent clock port data set.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data of transparent clock port data set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state (container)

    YANG Description: Operational state data of transparent clock port data set.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data of transparent clock port data set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_port_openconfig_ptp__ptp_transparent_clock_ports_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list of Transparent Clock port data sets was specified
in IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this list is specified as
applying to the PTP Node (all domains), but the list is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance
and domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_index','__config','__state','__port_ds',)

  _yang_name = 'port'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_index = YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    self.__port_ds = YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports', 'port']

  def _get_port_index(self):
    """
    Getter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/port_index (leafref)

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    return self.__port_index
      
  def _set_port_index(self, v, load=False):
    """
    Setter method for port_index, mapped from YANG variable /ptp/transparent_clock_ports/port/port_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_index() directly.

    YANG Description: The port list is indexed using a number that is
unique per PTP Port within the PTP Instance,
applicable to the management context only
(i.e., not used in PTP messages).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)""",
        })

    self.__port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_index(self):
    self.__port_index = YANGDynClass(base=str, is_leaf=True, yang_name="port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ptp/transparent_clock_ports/port/config (container)

    YANG Description: Top-level container for configuration data of transparent clock port.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ptp/transparent_clock_ports/port/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Top-level container for configuration data of transparent clock port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ptp__ptp_transparent_clock_ports_port_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ptp/transparent_clock_ports/port/state (container)

    YANG Description: Top-level container for operational state data of transparent clock port.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ptp/transparent_clock_ports/port/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top-level container for operational state data of transparent clock port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ptp__ptp_transparent_clock_ports_port_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=False)


  def _get_port_ds(self):
    """
    Getter method for port_ds, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds (container)

    YANG Description: IEEE Std 1588 transparentClockPortDS.
    """
    return self.__port_ds
      
  def _set_port_ds(self, v, load=False):
    """
    Setter method for port_ds, mapped from YANG variable /ptp/transparent_clock_ports/port/port_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_ds() directly.

    YANG Description: IEEE Std 1588 transparentClockPortDS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_ds_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__port_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_ds(self):
    self.__port_ds = YANGDynClass(base=yc_port_ds_openconfig_ptp__ptp_transparent_clock_ports_port_port_ds, is_container='container', yang_name="port-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  port_index = __builtin__.property(_get_port_index, _set_port_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  port_ds = __builtin__.property(_get_port_ds, _set_port_ds)


  _pyangbind_elements = OrderedDict([('port_index', port_index), ('config', config), ('state', state), ('port_ds', port_ds), ])


class yc_transparent_clock_ports_openconfig_ptp__ptp_transparent_clock_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/transparent-clock-ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG container that is used to get all ports of the
IEEE Std 1588 transparentClockPortDS.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port',)

  _yang_name = 'transparent-clock-ports'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_transparent_clock_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'transparent-clock-ports']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /ptp/transparent_clock_ports/port (list)

    YANG Description: This list of Transparent Clock port data sets was specified
in IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this list is specified as
applying to the PTP Node (all domains), but the list is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance
and domain.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /ptp/transparent_clock_ports/port (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: This list of Transparent Clock port data sets was specified
in IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this list is specified as
applying to the PTP Node (all domains), but the list is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance
and domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_transparent_clock_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_transparent_clock_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=YANGListType("port_index",yc_port_openconfig_ptp__ptp_transparent_clock_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-index', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='list', is_config=True)

  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('port', port), ])


class yc_ptp_openconfig_ptp__ptp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instances','__transparent_clock_default_ds','__transparent_clock_ports',)

  _yang_name = 'ptp'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instances = YANGDynClass(base=yc_instances_openconfig_ptp__ptp_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__transparent_clock_default_ds = YANGDynClass(base=yc_transparent_clock_default_ds_openconfig_ptp__ptp_transparent_clock_default_ds, is_container='container', yang_name="transparent-clock-default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    self.__transparent_clock_ports = YANGDynClass(base=yc_transparent_clock_ports_openconfig_ptp__ptp_transparent_clock_ports, is_container='container', yang_name="transparent-clock-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp']

  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /ptp/instances (container)

    YANG Description: YANG container that is used to get all PTP Instances. YANG does not
allow get of all elements in a YANG list, so a YANG container wrapping
the YANG list is provided for that purpose. The naming convention uses
plural for the wrapping YANG container, and singular for the YANG list.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /ptp/instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: YANG container that is used to get all PTP Instances. YANG does not
allow get of all elements in a YANG list, so a YANG container wrapping
the YANG list is provided for that purpose. The naming convention uses
plural for the wrapping YANG container, and singular for the YANG list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instances_openconfig_ptp__ptp_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instances_openconfig_ptp__ptp_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=yc_instances_openconfig_ptp__ptp_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_transparent_clock_default_ds(self):
    """
    Getter method for transparent_clock_default_ds, mapped from YANG variable /ptp/transparent_clock_default_ds (container)

    YANG Description: This default data set was specified in
IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this data set is specified as
applying to the PTP Node (all domains), but the data set is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance and
domain.
    """
    return self.__transparent_clock_default_ds
      
  def _set_transparent_clock_default_ds(self, v, load=False):
    """
    Setter method for transparent_clock_default_ds, mapped from YANG variable /ptp/transparent_clock_default_ds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transparent_clock_default_ds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transparent_clock_default_ds() directly.

    YANG Description: This default data set was specified in
IEEE Std 1588-2008, and under some interpretations,
it applied to all domains, which in turn means that it
represents multiple Transparent Clocks.
In IEEE Std 1588-2019, this data set is specified as
applying to the PTP Node (all domains), but the data set is
deprecated. For new designs, the standard recommends that
Transparent Clocks use the PTP Instance data sets
(i.e., /ptp/instances/instance[]), such that each
Transparent Clock supports a single PTP Instance and
domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transparent_clock_default_ds_openconfig_ptp__ptp_transparent_clock_default_ds, is_container='container', yang_name="transparent-clock-default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transparent_clock_default_ds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transparent_clock_default_ds_openconfig_ptp__ptp_transparent_clock_default_ds, is_container='container', yang_name="transparent-clock-default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__transparent_clock_default_ds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transparent_clock_default_ds(self):
    self.__transparent_clock_default_ds = YANGDynClass(base=yc_transparent_clock_default_ds_openconfig_ptp__ptp_transparent_clock_default_ds, is_container='container', yang_name="transparent-clock-default-ds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)


  def _get_transparent_clock_ports(self):
    """
    Getter method for transparent_clock_ports, mapped from YANG variable /ptp/transparent_clock_ports (container)

    YANG Description: YANG container that is used to get all ports of the
IEEE Std 1588 transparentClockPortDS.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
    """
    return self.__transparent_clock_ports
      
  def _set_transparent_clock_ports(self, v, load=False):
    """
    Setter method for transparent_clock_ports, mapped from YANG variable /ptp/transparent_clock_ports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transparent_clock_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transparent_clock_ports() directly.

    YANG Description: YANG container that is used to get all ports of the
IEEE Std 1588 transparentClockPortDS.
YANG does not allow get of all elements in a YANG list,
so a YANG container wrapping the YANG list is provided for
that purpose. The naming convention uses plural for the
wrapping YANG container, and singular for the YANG list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transparent_clock_ports_openconfig_ptp__ptp_transparent_clock_ports, is_container='container', yang_name="transparent-clock-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transparent_clock_ports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transparent_clock_ports_openconfig_ptp__ptp_transparent_clock_ports, is_container='container', yang_name="transparent-clock-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__transparent_clock_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transparent_clock_ports(self):
    self.__transparent_clock_ports = YANGDynClass(base=yc_transparent_clock_ports_openconfig_ptp__ptp_transparent_clock_ports, is_container='container', yang_name="transparent-clock-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  instances = __builtin__.property(_get_instances, _set_instances)
  transparent_clock_default_ds = __builtin__.property(_get_transparent_clock_default_ds, _set_transparent_clock_default_ds)
  transparent_clock_ports = __builtin__.property(_get_transparent_clock_ports, _set_transparent_clock_ports)


  _pyangbind_elements = OrderedDict([('instances', instances), ('transparent_clock_default_ds', transparent_clock_default_ds), ('transparent_clock_ports', transparent_clock_ports), ])


class openconfig_ptp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /openconfig-ptp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines a data model for the configuration
and state of IEEE Std 1588 clocks. IEEE Std 1588 specifies the
Precision Time Protocol (PTP).

The nodes in this YANG module are designed for compatibility
with ietf-ptp.yang, the YANG data model for IEEE Std 1588-2008,
as specified in IETF RFC 8575.

NOTE regarding default value:
PTP's concept of 'initialization value' is analogous to YANG's
concept of a 'default value'. According to 8.1.3.4 of
IEEE Std 1588-2019, the initialization value for configuration
is specified in IEEE Std 1588, but that value can be overridden
by a PTP Profile specification, or by the product that
implements PTP. This makes it challenging to repeat the
specification of initialization value using a YANG 'default'
statement, because there is no straightforward mechanism for
a PTP Profile's (or product's) YANG module to import this
module and override its YANG default. Since a YANG management
client can read the default value from the operational
datastore, there is no need to re-specify the default in YANG.
The implementer of PTP refers to the relevant PTP
specifications for the default (not YANG modules).
Therefore, this YANG module avoids use of the YANG 'default'
statement.

NOTE regarding IEEE Std 1588 classification:
8.1.2 of IEEE Std 1588-2019 specifies a classification of
each data set member, which corresponds to a leaf in YANG.
The relationship between 1588 classification and
YANG 'config' (i.e., whether the leaf is read-write) is:
- 1588 static: The leaf is 'config false' (read-only).
- 1588 configurable: The leaf is 'config true', which is
 the default value for a YANG leaf.
- 1588 dynamic: A judgement is made on a member-by-member
 basis. If the member corresponds to the first item of
 8.1.2.1.2 of IEEE Std 1588-2019 (i.e., value from protocol
 only, such as log of protocol behavior), the YANG leaf
 is 'config false'. Otherwise, the member's value can be
 provided by an entity outside PTP (e.g., NETCONF or
 RESTCONF client), and therefore the YANG leaf is
 'config true'.

NOTE regarding terminology (two YANG modules):
To accommodate the need by some organizations to use the
original terminology specified by IEEE Std 1588, and the
need by some other organizations to use the alternative
terminology specified in 4.4 of IEEE Std 1588g-2022,
two YANG modules are provided by IEEE Std 1588e (MIB and
YANG Data Models). For a detailed explanation, see 15.4.2.11
of IEEE Std 1588e.
This module uses the original terminology specified by
IEEE Std 1588 (master/slave).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ptp',)

  _yang_name = 'openconfig-ptp'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ptp = YANGDynClass(base=yc_ptp_openconfig_ptp__ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ptp(self):
    """
    Getter method for ptp, mapped from YANG variable /ptp (container)

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    return self.__ptp
      
  def _set_ptp(self, v, load=False):
    """
    Setter method for ptp, mapped from YANG variable /ptp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp() directly.

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ptp_openconfig_ptp__ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ptp_openconfig_ptp__ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__ptp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp(self):
    self.__ptp = YANGDynClass(base=yc_ptp_openconfig_ptp__ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  ptp = __builtin__.property(_get_ptp, _set_ptp)


  _pyangbind_elements = OrderedDict([('ptp', ptp), ])


class openconfig_ptp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp-types - based on the path /openconfig-ptp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used in OpenConfig
models related to Precision Time Protocol (PTP).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  _pyangbind_elements = {}

  

