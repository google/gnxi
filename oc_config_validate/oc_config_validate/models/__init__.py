# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import interfaces
class openconfig_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /openconfig-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing network interfaces and subinterfaces.  This
module also defines convenience types / groupings for other
models to create references to interfaces:

 base-interface-ref (type) -  reference to a base interface
 interface-ref (grouping) -  container for reference to a
   interface + subinterface
 interface-ref-state (grouping) - container for read-only
   (opstate) reference to interface + subinterface

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7223 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7223.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'openconfig-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


class openconfig_if_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip - based on the path /openconfig-if-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines data for managing configuration and
operational state on IP (IPv4 and IPv6) interfaces.

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7277 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7277.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

from . import access_points
class openconfig_access_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /openconfig-access-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level WiFi Configurations for a list of
Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__access_points',)

  _yang_name = 'openconfig-access-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_access_points(self):
    """
    Getter method for access_points, mapped from YANG variable /access_points (container)

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    return self.__access_points
      
  def _set_access_points(self, v, load=False):
    """
    Setter method for access_points, mapped from YANG variable /access_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_points() directly.

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__access_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_points(self):
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  access_points = __builtin__.property(_get_access_points, _set_access_points)


  _pyangbind_elements = OrderedDict([('access_points', access_points), ])


class openconfig_ap_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-interfaces - based on the path /openconfig-ap-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the configuration and state data for
non-radio interfaces on WiFi Access Points.
  """
  _pyangbind_elements = {}

  

from . import provision_aps
from . import joined_aps
class openconfig_ap_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /openconfig-ap-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level configuration and state data for a
system which manages Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__provision_aps','__joined_aps',)

  _yang_name = 'openconfig-ap-manager'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_provision_aps(self):
    """
    Getter method for provision_aps, mapped from YANG variable /provision_aps (container)

    YANG Description: Top most container for assigning hostnames to APs.
    """
    return self.__provision_aps
      
  def _set_provision_aps(self, v, load=False):
    """
    Setter method for provision_aps, mapped from YANG variable /provision_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provision_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provision_aps() directly.

    YANG Description: Top most container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provision_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__provision_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provision_aps(self):
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)


  def _get_joined_aps(self):
    """
    Getter method for joined_aps, mapped from YANG variable /joined_aps (container)

    YANG Description: Top most container for joined-aps.
    """
    return self.__joined_aps
      
  def _set_joined_aps(self, v, load=False):
    """
    Setter method for joined_aps, mapped from YANG variable /joined_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined_aps() directly.

    YANG Description: Top most container for joined-aps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__joined_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined_aps(self):
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

  provision_aps = __builtin__.property(_get_provision_aps, _set_provision_aps)
  joined_aps = __builtin__.property(_get_joined_aps, _set_joined_aps)


  _pyangbind_elements = OrderedDict([('provision_aps', provision_aps), ('joined_aps', joined_aps), ])


from . import system
class openconfig_system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /openconfig-system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing system-wide services and functions on
network devices.

Portions of this code were derived from IETF RFC 7317.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__system',)

  _yang_name = 'openconfig-system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_system(self):
    """
    Getter method for system, mapped from YANG variable /system (container)

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    return self.__system
      
  def _set_system(self, v, load=False):
    """
    Setter method for system, mapped from YANG variable /system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system() directly.

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system(self):
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

  system = __builtin__.property(_get_system, _set_system)


  _pyangbind_elements = OrderedDict([('system', system), ])


class openconfig_aaa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa - based on the path /openconfig-aaa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to authorization, authentication, and accounting (AAA)
management.

Portions of this model reuse data definitions or structure from
RFC 7317 - A YANG Data Model for System Management
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-tacacs - based on the path /openconfig-aaa-tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the TACACS+ protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-radius - based on the path /openconfig-aaa-radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the RADIUS protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

from . import local_routes
class openconfig_local_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-local-routing - based on the path /openconfig-local-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes configuration and operational state data
for routes that are locally generated, i.e., not created by
dynamic routing protocols.  These include static routes, locally
created aggregate routes for reducing the number of constituent
routes that must be advertised, summary routes for IGPs, etc.

This model expresses locally generated routes as generically as
possible, avoiding configuration of protocol-specific attributes
at the time of route creation.  This is primarily to avoid
assumptions about how underlying router implementations handle
route attributes in various routing table data structures they
maintain.  Hence, the definition of locally generated routes
essentially creates 'bare' routes that do not have any protocol-
specific attributes.

When protocol-specific attributes must be attached to a route
(e.g., communities on a locally defined route meant to be
advertised via BGP), the attributes should be attached via a
protocol-specific policy after importing the route into the
protocol for distribution (again via routing policy).
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_routes',)

  _yang_name = 'openconfig-local-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_routes = YANGDynClass(base=local_routes.local_routes, is_container='container', yang_name="local-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/local-routing', defining_module='openconfig-local-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_local_routes(self):
    """
    Getter method for local_routes, mapped from YANG variable /local_routes (container)

    YANG Description: Top-level container for local routes
    """
    return self.__local_routes
      
  def _set_local_routes(self, v, load=False):
    """
    Setter method for local_routes, mapped from YANG variable /local_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_routes() directly.

    YANG Description: Top-level container for local routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=local_routes.local_routes, is_container='container', yang_name="local-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/local-routing', defining_module='openconfig-local-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=local_routes.local_routes, is_container='container', yang_name="local-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/local-routing', defining_module='openconfig-local-routing', yang_type='container', is_config=True)""",
        })

    self.__local_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_routes(self):
    self.__local_routes = YANGDynClass(base=local_routes.local_routes, is_container='container', yang_name="local-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/local-routing', defining_module='openconfig-local-routing', yang_type='container', is_config=True)

  local_routes = __builtin__.property(_get_local_routes, _set_local_routes)


  _pyangbind_elements = OrderedDict([('local_routes', local_routes), ])


from . import bgp
class openconfig_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /openconfig-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for BGP protocol
configuration.It is a limited subset of all of the configuration
parameters available in the variety of vendor implementations,
hence it is expected that it would be augmented with vendor-
specific configuration data as needed. Additional modules or
submodules to handle other aspects of BGP configuration,
including policy, VRFs, VPNs, and additional address families
are also expected.

This model supports the following BGP configuration level
hierarchy:

 BGP
   |
   +-> [ global BGP configuration ]
     +-> AFI / SAFI global
   +-> peer group
     +-> [ peer group config ]
     +-> AFI / SAFI [ per-AFI overrides ]
   +-> neighbor
     +-> [ neighbor config ]
     +-> [ optional pointer to peer-group ]
     +-> AFI / SAFI [ per-AFI overrides ]
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-common'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-common-multiprotocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-common-structure'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-peer-group'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


from . import bgp
class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'openconfig-bgp-global'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Top-level configuration and state for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration and state for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp)


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

from . import lldp
class openconfig_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lldp - based on the path /openconfig-lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the LLDP protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lldp',)

  _yang_name = 'openconfig-lldp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_lldp(self):
    """
    Getter method for lldp, mapped from YANG variable /lldp (container)

    YANG Description: Top-level container for LLDP configuration and state data
    """
    return self.__lldp
      
  def _set_lldp(self, v, load=False):
    """
    Setter method for lldp, mapped from YANG variable /lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp() directly.

    YANG Description: Top-level container for LLDP configuration and state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)""",
        })

    self.__lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp(self):
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

  lldp = __builtin__.property(_get_lldp, _set_lldp)


  _pyangbind_elements = OrderedDict([('lldp', lldp), ])


