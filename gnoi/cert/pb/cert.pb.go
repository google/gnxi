// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cert.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Types of certificates.
type CertificateType int32

const (
	// 1 - 500 for public use.
	// 501 onwards for private use.
	CertificateType_CT_UNKNOWN CertificateType = 0
	CertificateType_CT_X509    CertificateType = 1
)

var CertificateType_name = map[int32]string{
	0: "CT_UNKNOWN",
	1: "CT_X509",
}
var CertificateType_value = map[string]int32{
	"CT_UNKNOWN": 0,
	"CT_X509":    1,
}

func (x CertificateType) String() string {
	return proto.EnumName(CertificateType_name, int32(x))
}
func (CertificateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{0}
}

// Algorithm to be used for generation the key pair.
type KeyType int32

const (
	// 1 - 500, for known types.
	// 501 and onwards for private use.
	KeyType_KT_UNKNOWN KeyType = 0
	KeyType_KT_RSA     KeyType = 1
)

var KeyType_name = map[int32]string{
	0: "KT_UNKNOWN",
	1: "KT_RSA",
}
var KeyType_value = map[string]int32{
	"KT_UNKNOWN": 0,
	"KT_RSA":     1,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}
func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{1}
}

// Type of endpoint that can use a cert. This list is to be extended based on
// conversation with vendors.
type Endpoint_Type int32

const (
	Endpoint_EP_UNSPECIFIED  Endpoint_Type = 0
	Endpoint_EP_IPSEC_TUNNEL Endpoint_Type = 1
	Endpoint_EP_DAEMON       Endpoint_Type = 2
)

var Endpoint_Type_name = map[int32]string{
	0: "EP_UNSPECIFIED",
	1: "EP_IPSEC_TUNNEL",
	2: "EP_DAEMON",
}
var Endpoint_Type_value = map[string]int32{
	"EP_UNSPECIFIED":  0,
	"EP_IPSEC_TUNNEL": 1,
	"EP_DAEMON":       2,
}

func (x Endpoint_Type) String() string {
	return proto.EnumName(Endpoint_Type_name, int32(x))
}
func (Endpoint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{21, 0}
}

// Request messages to rotate existing certificates on the target.
type RotateCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to RotateRequest:
	//	*RotateCertificateRequest_GenerateCsr
	//	*RotateCertificateRequest_LoadCertificate
	//	*RotateCertificateRequest_FinalizeRotation
	RotateRequest        isRotateCertificateRequest_RotateRequest `protobuf_oneof:"rotate_request"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *RotateCertificateRequest) Reset()         { *m = RotateCertificateRequest{} }
func (m *RotateCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*RotateCertificateRequest) ProtoMessage()    {}
func (*RotateCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{0}
}
func (m *RotateCertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RotateCertificateRequest.Unmarshal(m, b)
}
func (m *RotateCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RotateCertificateRequest.Marshal(b, m, deterministic)
}
func (dst *RotateCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateCertificateRequest.Merge(dst, src)
}
func (m *RotateCertificateRequest) XXX_Size() int {
	return xxx_messageInfo_RotateCertificateRequest.Size(m)
}
func (m *RotateCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RotateCertificateRequest proto.InternalMessageInfo

type isRotateCertificateRequest_RotateRequest interface {
	isRotateCertificateRequest_RotateRequest()
}

type RotateCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,proto3,oneof"`
}
type RotateCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,proto3,oneof"`
}
type RotateCertificateRequest_FinalizeRotation struct {
	FinalizeRotation *FinalizeRequest `protobuf:"bytes,3,opt,name=finalize_rotation,json=finalizeRotation,proto3,oneof"`
}

func (*RotateCertificateRequest_GenerateCsr) isRotateCertificateRequest_RotateRequest()      {}
func (*RotateCertificateRequest_LoadCertificate) isRotateCertificateRequest_RotateRequest()  {}
func (*RotateCertificateRequest_FinalizeRotation) isRotateCertificateRequest_RotateRequest() {}

func (m *RotateCertificateRequest) GetRotateRequest() isRotateCertificateRequest_RotateRequest {
	if m != nil {
		return m.RotateRequest
	}
	return nil
}

func (m *RotateCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *RotateCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

func (m *RotateCertificateRequest) GetFinalizeRotation() *FinalizeRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_FinalizeRotation); ok {
		return x.FinalizeRotation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateRequest_OneofMarshaler, _RotateCertificateRequest_OneofUnmarshaler, _RotateCertificateRequest_OneofSizer, []interface{}{
		(*RotateCertificateRequest_GenerateCsr)(nil),
		(*RotateCertificateRequest_LoadCertificate)(nil),
		(*RotateCertificateRequest_FinalizeRotation)(nil),
	}
}

func _RotateCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *RotateCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case *RotateCertificateRequest_FinalizeRotation:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FinalizeRotation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateRequest.RotateRequest has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateRequest)
	switch tag {
	case 1: // rotate_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // rotate_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_LoadCertificate{msg}
		return true, err
	case 3: // rotate_request.finalize_rotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FinalizeRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_FinalizeRotation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_FinalizeRotation:
		s := proto.Size(x.FinalizeRotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target.
type RotateCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to RotateResponse:
	//	*RotateCertificateResponse_GeneratedCsr
	//	*RotateCertificateResponse_LoadCertificate
	RotateResponse       isRotateCertificateResponse_RotateResponse `protobuf_oneof:"rotate_response"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *RotateCertificateResponse) Reset()         { *m = RotateCertificateResponse{} }
func (m *RotateCertificateResponse) String() string { return proto.CompactTextString(m) }
func (*RotateCertificateResponse) ProtoMessage()    {}
func (*RotateCertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{1}
}
func (m *RotateCertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RotateCertificateResponse.Unmarshal(m, b)
}
func (m *RotateCertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RotateCertificateResponse.Marshal(b, m, deterministic)
}
func (dst *RotateCertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateCertificateResponse.Merge(dst, src)
}
func (m *RotateCertificateResponse) XXX_Size() int {
	return xxx_messageInfo_RotateCertificateResponse.Size(m)
}
func (m *RotateCertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateCertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RotateCertificateResponse proto.InternalMessageInfo

type isRotateCertificateResponse_RotateResponse interface {
	isRotateCertificateResponse_RotateResponse()
}

type RotateCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,proto3,oneof"`
}
type RotateCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,proto3,oneof"`
}

func (*RotateCertificateResponse_GeneratedCsr) isRotateCertificateResponse_RotateResponse()    {}
func (*RotateCertificateResponse_LoadCertificate) isRotateCertificateResponse_RotateResponse() {}

func (m *RotateCertificateResponse) GetRotateResponse() isRotateCertificateResponse_RotateResponse {
	if m != nil {
		return m.RotateResponse
	}
	return nil
}

func (m *RotateCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *RotateCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateResponse_OneofMarshaler, _RotateCertificateResponse_OneofUnmarshaler, _RotateCertificateResponse_OneofSizer, []interface{}{
		(*RotateCertificateResponse_GeneratedCsr)(nil),
		(*RotateCertificateResponse_LoadCertificate)(nil),
	}
}

func _RotateCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *RotateCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateResponse.RotateResponse has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateResponse)
	switch tag {
	case 1: // rotate_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // rotate_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request messages to install new certificates on the target.
type InstallCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to InstallRequest:
	//	*InstallCertificateRequest_GenerateCsr
	//	*InstallCertificateRequest_LoadCertificate
	InstallRequest       isInstallCertificateRequest_InstallRequest `protobuf_oneof:"install_request"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *InstallCertificateRequest) Reset()         { *m = InstallCertificateRequest{} }
func (m *InstallCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*InstallCertificateRequest) ProtoMessage()    {}
func (*InstallCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{2}
}
func (m *InstallCertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstallCertificateRequest.Unmarshal(m, b)
}
func (m *InstallCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstallCertificateRequest.Marshal(b, m, deterministic)
}
func (dst *InstallCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallCertificateRequest.Merge(dst, src)
}
func (m *InstallCertificateRequest) XXX_Size() int {
	return xxx_messageInfo_InstallCertificateRequest.Size(m)
}
func (m *InstallCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InstallCertificateRequest proto.InternalMessageInfo

type isInstallCertificateRequest_InstallRequest interface {
	isInstallCertificateRequest_InstallRequest()
}

type InstallCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,proto3,oneof"`
}
type InstallCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,proto3,oneof"`
}

func (*InstallCertificateRequest_GenerateCsr) isInstallCertificateRequest_InstallRequest()     {}
func (*InstallCertificateRequest_LoadCertificate) isInstallCertificateRequest_InstallRequest() {}

func (m *InstallCertificateRequest) GetInstallRequest() isInstallCertificateRequest_InstallRequest {
	if m != nil {
		return m.InstallRequest
	}
	return nil
}

func (m *InstallCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *InstallCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateRequest_OneofMarshaler, _InstallCertificateRequest_OneofUnmarshaler, _InstallCertificateRequest_OneofSizer, []interface{}{
		(*InstallCertificateRequest_GenerateCsr)(nil),
		(*InstallCertificateRequest_LoadCertificate)(nil),
	}
}

func _InstallCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *InstallCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateRequest.InstallRequest has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateRequest)
	switch tag {
	case 1: // install_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // install_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target for the InstallCertificateRequest.
type InstallCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to InstallResponse:
	//	*InstallCertificateResponse_GeneratedCsr
	//	*InstallCertificateResponse_LoadCertificate
	InstallResponse      isInstallCertificateResponse_InstallResponse `protobuf_oneof:"install_response"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *InstallCertificateResponse) Reset()         { *m = InstallCertificateResponse{} }
func (m *InstallCertificateResponse) String() string { return proto.CompactTextString(m) }
func (*InstallCertificateResponse) ProtoMessage()    {}
func (*InstallCertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{3}
}
func (m *InstallCertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstallCertificateResponse.Unmarshal(m, b)
}
func (m *InstallCertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstallCertificateResponse.Marshal(b, m, deterministic)
}
func (dst *InstallCertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallCertificateResponse.Merge(dst, src)
}
func (m *InstallCertificateResponse) XXX_Size() int {
	return xxx_messageInfo_InstallCertificateResponse.Size(m)
}
func (m *InstallCertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallCertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InstallCertificateResponse proto.InternalMessageInfo

type isInstallCertificateResponse_InstallResponse interface {
	isInstallCertificateResponse_InstallResponse()
}

type InstallCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,proto3,oneof"`
}
type InstallCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,proto3,oneof"`
}

func (*InstallCertificateResponse_GeneratedCsr) isInstallCertificateResponse_InstallResponse()    {}
func (*InstallCertificateResponse_LoadCertificate) isInstallCertificateResponse_InstallResponse() {}

func (m *InstallCertificateResponse) GetInstallResponse() isInstallCertificateResponse_InstallResponse {
	if m != nil {
		return m.InstallResponse
	}
	return nil
}

func (m *InstallCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *InstallCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateResponse_OneofMarshaler, _InstallCertificateResponse_OneofUnmarshaler, _InstallCertificateResponse_OneofSizer, []interface{}{
		(*InstallCertificateResponse_GeneratedCsr)(nil),
		(*InstallCertificateResponse_LoadCertificate)(nil),
	}
}

func _InstallCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *InstallCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateResponse.InstallResponse has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateResponse)
	switch tag {
	case 1: // install_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // install_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request to generate the CSR.
// When this request is made for rotating an existing certificate as part of the
// Rotate() RPC, then the target must ensure that the "certificate_id" is
// already created and exists on the target. If the Certificate Rotation
// proceeds to load the certificate, it must associate the new certificate with
// the previously created "certificate_id".
//
// When this request is made for installing a completely new certificate as part
// of the Install() RPC , then the target must ensure that the "certificate_id"
// is completely new and no entities on the target are should be bound to this
// certificate_id. If any existing certificate matches the certificate_id, then
// this request should fail.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the GenerateCSRRequest should fail.
type GenerateCSRRequest struct {
	// Parameters for creating a CSR.
	CsrParams *CSRParams `protobuf:"bytes,1,opt,name=csr_params,json=csrParams,proto3" json:"csr_params,omitempty"`
	// The certificate id with which this CSR will be associated. The target
	// configuration should bind an entity which wants to use a certificate to
	// the certificate_id it should use.
	CertificateId        string   `protobuf:"bytes,2,opt,name=certificate_id,json=certificateId,proto3" json:"certificate_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateCSRRequest) Reset()         { *m = GenerateCSRRequest{} }
func (m *GenerateCSRRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateCSRRequest) ProtoMessage()    {}
func (*GenerateCSRRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{4}
}
func (m *GenerateCSRRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenerateCSRRequest.Unmarshal(m, b)
}
func (m *GenerateCSRRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenerateCSRRequest.Marshal(b, m, deterministic)
}
func (dst *GenerateCSRRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateCSRRequest.Merge(dst, src)
}
func (m *GenerateCSRRequest) XXX_Size() int {
	return xxx_messageInfo_GenerateCSRRequest.Size(m)
}
func (m *GenerateCSRRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateCSRRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateCSRRequest proto.InternalMessageInfo

func (m *GenerateCSRRequest) GetCsrParams() *CSRParams {
	if m != nil {
		return m.CsrParams
	}
	return nil
}

func (m *GenerateCSRRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

// Parameters to be used when generating a Certificate Signing Request.
type CSRParams struct {
	// The type of certificate which will be associated for this CSR.
	Type CertificateType `protobuf:"varint,1,opt,name=type,proto3,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Minimum size of the key to be used by the target when generating a
	// public/private key pair.
	MinKeySize uint32 `protobuf:"varint,2,opt,name=min_key_size,json=minKeySize,proto3" json:"min_key_size,omitempty"`
	// If provided, the target must use the provided key type. If the target
	// cannot use the algorithm specified in the key_type, it should cancel the
	// stream with an Unimplemented error.
	KeyType KeyType `protobuf:"varint,3,opt,name=key_type,json=keyType,proto3,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	// --- common set of parameters applicable for any type of certificate --- //
	CommonName           string   `protobuf:"bytes,4,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty"`
	Country              string   `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
	State                string   `protobuf:"bytes,6,opt,name=state,proto3" json:"state,omitempty"`
	City                 string   `protobuf:"bytes,7,opt,name=city,proto3" json:"city,omitempty"`
	Organization         string   `protobuf:"bytes,8,opt,name=organization,proto3" json:"organization,omitempty"`
	OrganizationalUnit   string   `protobuf:"bytes,9,opt,name=organizational_unit,json=organizationalUnit,proto3" json:"organizational_unit,omitempty"`
	IpAddress            string   `protobuf:"bytes,10,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	EmailId              string   `protobuf:"bytes,11,opt,name=email_id,json=emailId,proto3" json:"email_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSRParams) Reset()         { *m = CSRParams{} }
func (m *CSRParams) String() string { return proto.CompactTextString(m) }
func (*CSRParams) ProtoMessage()    {}
func (*CSRParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{5}
}
func (m *CSRParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CSRParams.Unmarshal(m, b)
}
func (m *CSRParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CSRParams.Marshal(b, m, deterministic)
}
func (dst *CSRParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSRParams.Merge(dst, src)
}
func (m *CSRParams) XXX_Size() int {
	return xxx_messageInfo_CSRParams.Size(m)
}
func (m *CSRParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CSRParams.DiscardUnknown(m)
}

var xxx_messageInfo_CSRParams proto.InternalMessageInfo

func (m *CSRParams) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSRParams) GetMinKeySize() uint32 {
	if m != nil {
		return m.MinKeySize
	}
	return 0
}

func (m *CSRParams) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CSRParams) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *CSRParams) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CSRParams) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *CSRParams) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *CSRParams) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CSRParams) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *CSRParams) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *CSRParams) GetEmailId() string {
	if m != nil {
		return m.EmailId
	}
	return ""
}

// GenerateCSRResponse contains the CSR associated with the Certificate ID
// supplied in the GenerateCSRRequest. When a Certificate is subsequently
// installed on the target in the same streaming RPC session, it must be
// associated to that Certificate ID.
//
// An Unimplemented error will be returned if the target cannot generate a CSR
// as per the request. In this case, the caller must generate its own key pair.
type GenerateCSRResponse struct {
	Csr                  *CSR     `protobuf:"bytes,1,opt,name=csr,proto3" json:"csr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateCSRResponse) Reset()         { *m = GenerateCSRResponse{} }
func (m *GenerateCSRResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateCSRResponse) ProtoMessage()    {}
func (*GenerateCSRResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{6}
}
func (m *GenerateCSRResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenerateCSRResponse.Unmarshal(m, b)
}
func (m *GenerateCSRResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenerateCSRResponse.Marshal(b, m, deterministic)
}
func (dst *GenerateCSRResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateCSRResponse.Merge(dst, src)
}
func (m *GenerateCSRResponse) XXX_Size() int {
	return xxx_messageInfo_GenerateCSRResponse.Size(m)
}
func (m *GenerateCSRResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateCSRResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateCSRResponse proto.InternalMessageInfo

func (m *GenerateCSRResponse) GetCsr() *CSR {
	if m != nil {
		return m.Csr
	}
	return nil
}

// LoadCertificateRequest instructs the target to store the given certificate.
//
// Case 1: Target Generated CSR and Key Pair.
// If the target generated the CSR (and the public/private key pair) during the
// GenerateCSR request, then the target must associate the certificate with the
// certificate ID specified in the preceding GenerateCSR request.
//
// Case 2: Externally Generated Key Pair.
// If the target can not generate a CSR, then the public/private key pair is
// generated externally. In this case provide the target with the key pair,
// and the certificate_id to be associated with the new certificate.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the LoadCertificateRequest must fail.
type LoadCertificateRequest struct {
	// The certificate to be Loaded on the target.
	Certificate *Certificate `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// The key pair to be used with the certificate. This is provided in the event
	// that the target cannot generate a CSR (and the corresponding public/private
	// keys).
	KeyPair *KeyPair `protobuf:"bytes,2,opt,name=key_pair,json=keyPair,proto3" json:"key_pair,omitempty"`
	// Certificate Id of the above certificate. This is to be provided only when
	// there is an externally generated key pair.
	CertificateId string `protobuf:"bytes,3,opt,name=certificate_id,json=certificateId,proto3" json:"certificate_id,omitempty"`
	// Optional pool of CA certificates to be used for authenticating the client.
	CaCertificate        []*Certificate `protobuf:"bytes,4,rep,name=ca_certificate,json=caCertificate,proto3" json:"ca_certificate,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LoadCertificateRequest) Reset()         { *m = LoadCertificateRequest{} }
func (m *LoadCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*LoadCertificateRequest) ProtoMessage()    {}
func (*LoadCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{7}
}
func (m *LoadCertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadCertificateRequest.Unmarshal(m, b)
}
func (m *LoadCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadCertificateRequest.Marshal(b, m, deterministic)
}
func (dst *LoadCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadCertificateRequest.Merge(dst, src)
}
func (m *LoadCertificateRequest) XXX_Size() int {
	return xxx_messageInfo_LoadCertificateRequest.Size(m)
}
func (m *LoadCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoadCertificateRequest proto.InternalMessageInfo

func (m *LoadCertificateRequest) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *LoadCertificateRequest) GetKeyPair() *KeyPair {
	if m != nil {
		return m.KeyPair
	}
	return nil
}

func (m *LoadCertificateRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *LoadCertificateRequest) GetCaCertificate() []*Certificate {
	if m != nil {
		return m.CaCertificate
	}
	return nil
}

// Response from target after Loading a Certificate.
// If the target could not load the certificate, it must end the RPC stream with
// a suitable RPC error about why the Certificate was not loaded.
type LoadCertificateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadCertificateResponse) Reset()         { *m = LoadCertificateResponse{} }
func (m *LoadCertificateResponse) String() string { return proto.CompactTextString(m) }
func (*LoadCertificateResponse) ProtoMessage()    {}
func (*LoadCertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{8}
}
func (m *LoadCertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoadCertificateResponse.Unmarshal(m, b)
}
func (m *LoadCertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoadCertificateResponse.Marshal(b, m, deterministic)
}
func (dst *LoadCertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadCertificateResponse.Merge(dst, src)
}
func (m *LoadCertificateResponse) XXX_Size() int {
	return xxx_messageInfo_LoadCertificateResponse.Size(m)
}
func (m *LoadCertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadCertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoadCertificateResponse proto.InternalMessageInfo

// A Finalize message is sent to the target to confirm the Rotation of
// the certificate and that the certificate should not be rolled back when
// the RPC concludes. The certificate must be rolled back if the target returns
// an error after receiving a Finalize message.
type FinalizeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinalizeRequest) Reset()         { *m = FinalizeRequest{} }
func (m *FinalizeRequest) String() string { return proto.CompactTextString(m) }
func (*FinalizeRequest) ProtoMessage()    {}
func (*FinalizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{9}
}
func (m *FinalizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FinalizeRequest.Unmarshal(m, b)
}
func (m *FinalizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FinalizeRequest.Marshal(b, m, deterministic)
}
func (dst *FinalizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalizeRequest.Merge(dst, src)
}
func (m *FinalizeRequest) XXX_Size() int {
	return xxx_messageInfo_FinalizeRequest.Size(m)
}
func (m *FinalizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinalizeRequest proto.InternalMessageInfo

// The request to query all the certificates on the target.
type GetCertificatesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCertificatesRequest) Reset()         { *m = GetCertificatesRequest{} }
func (m *GetCertificatesRequest) String() string { return proto.CompactTextString(m) }
func (*GetCertificatesRequest) ProtoMessage()    {}
func (*GetCertificatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{10}
}
func (m *GetCertificatesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCertificatesRequest.Unmarshal(m, b)
}
func (m *GetCertificatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCertificatesRequest.Marshal(b, m, deterministic)
}
func (dst *GetCertificatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCertificatesRequest.Merge(dst, src)
}
func (m *GetCertificatesRequest) XXX_Size() int {
	return xxx_messageInfo_GetCertificatesRequest.Size(m)
}
func (m *GetCertificatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCertificatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCertificatesRequest proto.InternalMessageInfo

// Response from the target about the certificates that exist on the target what
// what is using them.
type GetCertificatesResponse struct {
	CertificateInfo      []*CertificateInfo `protobuf:"bytes,1,rep,name=certificate_info,json=certificateInfo,proto3" json:"certificate_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetCertificatesResponse) Reset()         { *m = GetCertificatesResponse{} }
func (m *GetCertificatesResponse) String() string { return proto.CompactTextString(m) }
func (*GetCertificatesResponse) ProtoMessage()    {}
func (*GetCertificatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{11}
}
func (m *GetCertificatesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCertificatesResponse.Unmarshal(m, b)
}
func (m *GetCertificatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCertificatesResponse.Marshal(b, m, deterministic)
}
func (dst *GetCertificatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCertificatesResponse.Merge(dst, src)
}
func (m *GetCertificatesResponse) XXX_Size() int {
	return xxx_messageInfo_GetCertificatesResponse.Size(m)
}
func (m *GetCertificatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCertificatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCertificatesResponse proto.InternalMessageInfo

func (m *GetCertificatesResponse) GetCertificateInfo() []*CertificateInfo {
	if m != nil {
		return m.CertificateInfo
	}
	return nil
}

type CertificateInfo struct {
	CertificateId string       `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId,proto3" json:"certificate_id,omitempty"`
	Certificate   *Certificate `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// List of endpoints using this certificate.
	Endpoints []*Endpoint `protobuf:"bytes,3,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	// System modification time when the certificate was installed/rotated in
	// nanoseconds since epoch.
	ModificationTime     int64    `protobuf:"varint,4,opt,name=modification_time,json=modificationTime,proto3" json:"modification_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertificateInfo) Reset()         { *m = CertificateInfo{} }
func (m *CertificateInfo) String() string { return proto.CompactTextString(m) }
func (*CertificateInfo) ProtoMessage()    {}
func (*CertificateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{12}
}
func (m *CertificateInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateInfo.Unmarshal(m, b)
}
func (m *CertificateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateInfo.Marshal(b, m, deterministic)
}
func (dst *CertificateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateInfo.Merge(dst, src)
}
func (m *CertificateInfo) XXX_Size() int {
	return xxx_messageInfo_CertificateInfo.Size(m)
}
func (m *CertificateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateInfo proto.InternalMessageInfo

func (m *CertificateInfo) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateInfo) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *CertificateInfo) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *CertificateInfo) GetModificationTime() int64 {
	if m != nil {
		return m.ModificationTime
	}
	return 0
}

type RevokeCertificatesRequest struct {
	// Certificates to revoke.
	CertificateId        []string `protobuf:"bytes,1,rep,name=certificate_id,json=certificateId,proto3" json:"certificate_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RevokeCertificatesRequest) Reset()         { *m = RevokeCertificatesRequest{} }
func (m *RevokeCertificatesRequest) String() string { return proto.CompactTextString(m) }
func (*RevokeCertificatesRequest) ProtoMessage()    {}
func (*RevokeCertificatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{13}
}
func (m *RevokeCertificatesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RevokeCertificatesRequest.Unmarshal(m, b)
}
func (m *RevokeCertificatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RevokeCertificatesRequest.Marshal(b, m, deterministic)
}
func (dst *RevokeCertificatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeCertificatesRequest.Merge(dst, src)
}
func (m *RevokeCertificatesRequest) XXX_Size() int {
	return xxx_messageInfo_RevokeCertificatesRequest.Size(m)
}
func (m *RevokeCertificatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeCertificatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeCertificatesRequest proto.InternalMessageInfo

func (m *RevokeCertificatesRequest) GetCertificateId() []string {
	if m != nil {
		return m.CertificateId
	}
	return nil
}

type RevokeCertificatesResponse struct {
	// List of certificates successfully revoked.
	RevokedCertificateId []string `protobuf:"bytes,1,rep,name=revoked_certificate_id,json=revokedCertificateId,proto3" json:"revoked_certificate_id,omitempty"`
	// List of errors why certain certificates could not be revoked.
	CertificateRevocationError []*CertificateRevocationError `protobuf:"bytes,2,rep,name=certificate_revocation_error,json=certificateRevocationError,proto3" json:"certificate_revocation_error,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                      `json:"-"`
	XXX_unrecognized           []byte                        `json:"-"`
	XXX_sizecache              int32                         `json:"-"`
}

func (m *RevokeCertificatesResponse) Reset()         { *m = RevokeCertificatesResponse{} }
func (m *RevokeCertificatesResponse) String() string { return proto.CompactTextString(m) }
func (*RevokeCertificatesResponse) ProtoMessage()    {}
func (*RevokeCertificatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{14}
}
func (m *RevokeCertificatesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RevokeCertificatesResponse.Unmarshal(m, b)
}
func (m *RevokeCertificatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RevokeCertificatesResponse.Marshal(b, m, deterministic)
}
func (dst *RevokeCertificatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeCertificatesResponse.Merge(dst, src)
}
func (m *RevokeCertificatesResponse) XXX_Size() int {
	return xxx_messageInfo_RevokeCertificatesResponse.Size(m)
}
func (m *RevokeCertificatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeCertificatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeCertificatesResponse proto.InternalMessageInfo

func (m *RevokeCertificatesResponse) GetRevokedCertificateId() []string {
	if m != nil {
		return m.RevokedCertificateId
	}
	return nil
}

func (m *RevokeCertificatesResponse) GetCertificateRevocationError() []*CertificateRevocationError {
	if m != nil {
		return m.CertificateRevocationError
	}
	return nil
}

// An error message indicating why a certificate id could not be revoked.
type CertificateRevocationError struct {
	CertificateId        string   `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId,proto3" json:"certificate_id,omitempty"`
	ErrorMessage         string   `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertificateRevocationError) Reset()         { *m = CertificateRevocationError{} }
func (m *CertificateRevocationError) String() string { return proto.CompactTextString(m) }
func (*CertificateRevocationError) ProtoMessage()    {}
func (*CertificateRevocationError) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{15}
}
func (m *CertificateRevocationError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateRevocationError.Unmarshal(m, b)
}
func (m *CertificateRevocationError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateRevocationError.Marshal(b, m, deterministic)
}
func (dst *CertificateRevocationError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateRevocationError.Merge(dst, src)
}
func (m *CertificateRevocationError) XXX_Size() int {
	return xxx_messageInfo_CertificateRevocationError.Size(m)
}
func (m *CertificateRevocationError) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateRevocationError.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateRevocationError proto.InternalMessageInfo

func (m *CertificateRevocationError) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateRevocationError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// A request to ask the target if it can generate key pairs.
type CanGenerateCSRRequest struct {
	KeyType              KeyType         `protobuf:"varint,1,opt,name=key_type,json=keyType,proto3,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	CertificateType      CertificateType `protobuf:"varint,2,opt,name=certificate_type,json=certificateType,proto3,enum=gnoi.certificate.CertificateType" json:"certificate_type,omitempty"`
	KeySize              uint32          `protobuf:"varint,3,opt,name=key_size,json=keySize,proto3" json:"key_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CanGenerateCSRRequest) Reset()         { *m = CanGenerateCSRRequest{} }
func (m *CanGenerateCSRRequest) String() string { return proto.CompactTextString(m) }
func (*CanGenerateCSRRequest) ProtoMessage()    {}
func (*CanGenerateCSRRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{16}
}
func (m *CanGenerateCSRRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CanGenerateCSRRequest.Unmarshal(m, b)
}
func (m *CanGenerateCSRRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CanGenerateCSRRequest.Marshal(b, m, deterministic)
}
func (dst *CanGenerateCSRRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanGenerateCSRRequest.Merge(dst, src)
}
func (m *CanGenerateCSRRequest) XXX_Size() int {
	return xxx_messageInfo_CanGenerateCSRRequest.Size(m)
}
func (m *CanGenerateCSRRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CanGenerateCSRRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CanGenerateCSRRequest proto.InternalMessageInfo

func (m *CanGenerateCSRRequest) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetCertificateType() CertificateType {
	if m != nil {
		return m.CertificateType
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetKeySize() uint32 {
	if m != nil {
		return m.KeySize
	}
	return 0
}

// Response from the target about whether it can generate a CSR with the given
// parameters.
type CanGenerateCSRResponse struct {
	CanGenerate          bool     `protobuf:"varint,4,opt,name=can_generate,json=canGenerate,proto3" json:"can_generate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CanGenerateCSRResponse) Reset()         { *m = CanGenerateCSRResponse{} }
func (m *CanGenerateCSRResponse) String() string { return proto.CompactTextString(m) }
func (*CanGenerateCSRResponse) ProtoMessage()    {}
func (*CanGenerateCSRResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{17}
}
func (m *CanGenerateCSRResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CanGenerateCSRResponse.Unmarshal(m, b)
}
func (m *CanGenerateCSRResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CanGenerateCSRResponse.Marshal(b, m, deterministic)
}
func (dst *CanGenerateCSRResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanGenerateCSRResponse.Merge(dst, src)
}
func (m *CanGenerateCSRResponse) XXX_Size() int {
	return xxx_messageInfo_CanGenerateCSRResponse.Size(m)
}
func (m *CanGenerateCSRResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CanGenerateCSRResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CanGenerateCSRResponse proto.InternalMessageInfo

func (m *CanGenerateCSRResponse) GetCanGenerate() bool {
	if m != nil {
		return m.CanGenerate
	}
	return false
}

// A certificate.
type Certificate struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,proto3,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Actual certificate.
	// The exact encoding depends upon the type of certificate.
	// for X509, this should be a PEM encoded Certificate.
	Certificate          []byte   `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{18}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Certificate.Unmarshal(m, b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
}
func (dst *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(dst, src)
}
func (m *Certificate) XXX_Size() int {
	return xxx_messageInfo_Certificate.Size(m)
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *Certificate) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// A Certificate Signing Request.
type CSR struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,proto3,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Bytes representing the CSR.
	// The exact encoding depends upon the type of certificate requested.
	// for X509: This should be the PEM encoded CSR.
	Csr                  []byte   `protobuf:"bytes,2,opt,name=csr,proto3" json:"csr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSR) Reset()         { *m = CSR{} }
func (m *CSR) String() string { return proto.CompactTextString(m) }
func (*CSR) ProtoMessage()    {}
func (*CSR) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{19}
}
func (m *CSR) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CSR.Unmarshal(m, b)
}
func (m *CSR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CSR.Marshal(b, m, deterministic)
}
func (dst *CSR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSR.Merge(dst, src)
}
func (m *CSR) XXX_Size() int {
	return xxx_messageInfo_CSR.Size(m)
}
func (m *CSR) XXX_DiscardUnknown() {
	xxx_messageInfo_CSR.DiscardUnknown(m)
}

var xxx_messageInfo_CSR proto.InternalMessageInfo

func (m *CSR) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSR) GetCsr() []byte {
	if m != nil {
		return m.Csr
	}
	return nil
}

// A message representing a pair of public/private keys.
type KeyPair struct {
	PrivateKey           []byte   `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyPair) Reset()         { *m = KeyPair{} }
func (m *KeyPair) String() string { return proto.CompactTextString(m) }
func (*KeyPair) ProtoMessage()    {}
func (*KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{20}
}
func (m *KeyPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyPair.Unmarshal(m, b)
}
func (m *KeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyPair.Marshal(b, m, deterministic)
}
func (dst *KeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyPair.Merge(dst, src)
}
func (m *KeyPair) XXX_Size() int {
	return xxx_messageInfo_KeyPair.Size(m)
}
func (m *KeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyPair proto.InternalMessageInfo

func (m *KeyPair) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *KeyPair) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// An endpoint represents an entity on the target which can use a certificate.
type Endpoint struct {
	Type Endpoint_Type `protobuf:"varint,1,opt,name=type,proto3,enum=gnoi.certificate.Endpoint_Type" json:"type,omitempty"`
	// Human readable identifier for an endpoint.
	Endpoint             string   `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_cert_460e8e7993df797d, []int{21}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Endpoint.Unmarshal(m, b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
}
func (dst *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(dst, src)
}
func (m *Endpoint) XXX_Size() int {
	return xxx_messageInfo_Endpoint.Size(m)
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetType() Endpoint_Type {
	if m != nil {
		return m.Type
	}
	return Endpoint_EP_UNSPECIFIED
}

func (m *Endpoint) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func init() {
	proto.RegisterType((*RotateCertificateRequest)(nil), "gnoi.certificate.RotateCertificateRequest")
	proto.RegisterType((*RotateCertificateResponse)(nil), "gnoi.certificate.RotateCertificateResponse")
	proto.RegisterType((*InstallCertificateRequest)(nil), "gnoi.certificate.InstallCertificateRequest")
	proto.RegisterType((*InstallCertificateResponse)(nil), "gnoi.certificate.InstallCertificateResponse")
	proto.RegisterType((*GenerateCSRRequest)(nil), "gnoi.certificate.GenerateCSRRequest")
	proto.RegisterType((*CSRParams)(nil), "gnoi.certificate.CSRParams")
	proto.RegisterType((*GenerateCSRResponse)(nil), "gnoi.certificate.GenerateCSRResponse")
	proto.RegisterType((*LoadCertificateRequest)(nil), "gnoi.certificate.LoadCertificateRequest")
	proto.RegisterType((*LoadCertificateResponse)(nil), "gnoi.certificate.LoadCertificateResponse")
	proto.RegisterType((*FinalizeRequest)(nil), "gnoi.certificate.FinalizeRequest")
	proto.RegisterType((*GetCertificatesRequest)(nil), "gnoi.certificate.GetCertificatesRequest")
	proto.RegisterType((*GetCertificatesResponse)(nil), "gnoi.certificate.GetCertificatesResponse")
	proto.RegisterType((*CertificateInfo)(nil), "gnoi.certificate.CertificateInfo")
	proto.RegisterType((*RevokeCertificatesRequest)(nil), "gnoi.certificate.RevokeCertificatesRequest")
	proto.RegisterType((*RevokeCertificatesResponse)(nil), "gnoi.certificate.RevokeCertificatesResponse")
	proto.RegisterType((*CertificateRevocationError)(nil), "gnoi.certificate.CertificateRevocationError")
	proto.RegisterType((*CanGenerateCSRRequest)(nil), "gnoi.certificate.CanGenerateCSRRequest")
	proto.RegisterType((*CanGenerateCSRResponse)(nil), "gnoi.certificate.CanGenerateCSRResponse")
	proto.RegisterType((*Certificate)(nil), "gnoi.certificate.Certificate")
	proto.RegisterType((*CSR)(nil), "gnoi.certificate.CSR")
	proto.RegisterType((*KeyPair)(nil), "gnoi.certificate.KeyPair")
	proto.RegisterType((*Endpoint)(nil), "gnoi.certificate.Endpoint")
	proto.RegisterEnum("gnoi.certificate.CertificateType", CertificateType_name, CertificateType_value)
	proto.RegisterEnum("gnoi.certificate.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("gnoi.certificate.Endpoint_Type", Endpoint_Type_name, Endpoint_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CertificateManagementClient is the client API for CertificateManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertificateManagementClient interface {
	// Rotate will replace an existing Certificate on the target by creating a
	// new CSR request and placing the new Certificate based on the CSR on the
	// target. If the stream is broken or any steps in the process fail the
	// target must rollback to the original Certificate.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Rotate() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR.
	//
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest----> Target
	//     Client <----- GenerateCSRResponse <--- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client --> LoadCertificateRequest ----> Target
	//     Client <-- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//     This step should be to create a new connection to the target using
	//     The new certificate and validate that the certificate works.
	//     Once verfied, the client will then proceed to finalize the rotation.
	//     If the new connection cannot be completed the client will cancel the
	//     RPC thereby forcing the target to rollback the certificate.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	//
	//
	// Case 2: When Client generates the CSR.
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ----> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client ---> LoadCertificateRequest ----> Target
	//     Client <--- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	Rotate(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_RotateClient, error)
	// Install will put a new Certificate on the target by creating a new CSR
	// request and placing the new Certificate based on the CSR on the target.The
	// new Certificate will be associated with a new Certificate Id on the target.
	// If the target has a pre existing Certificate with the given Certificate Id,
	// the operation should fail.
	// If the stream is broken or any steps in the process fail the target must
	// revert any changes in state.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Install() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR-------------------------:
	//
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest() ----> Target
	//     Client <---- GenerateCSRResponse() <---- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	// Case 2: When Client generates the CSR-------------------------:
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	Install(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_InstallClient, error)
	// An RPC to get the certificates on the target.
	GetCertificates(ctx context.Context, in *GetCertificatesRequest, opts ...grpc.CallOption) (*GetCertificatesResponse, error)
	// An RPC to revoke specific certificates.
	// If a certificate is not present on the target, the request should silently
	// succeed. Revoking a certificate should render the existing certificate
	// unusable by any endpoints.
	RevokeCertificates(ctx context.Context, in *RevokeCertificatesRequest, opts ...grpc.CallOption) (*RevokeCertificatesResponse, error)
	// An RPC to ask a target if it can generate a Certificate.
	CanGenerateCSR(ctx context.Context, in *CanGenerateCSRRequest, opts ...grpc.CallOption) (*CanGenerateCSRResponse, error)
}

type certificateManagementClient struct {
	cc *grpc.ClientConn
}

func NewCertificateManagementClient(cc *grpc.ClientConn) CertificateManagementClient {
	return &certificateManagementClient{cc}
}

func (c *certificateManagementClient) Rotate(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_RotateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CertificateManagement_serviceDesc.Streams[0], "/gnoi.certificate.CertificateManagement/Rotate", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificateManagementRotateClient{stream}
	return x, nil
}

type CertificateManagement_RotateClient interface {
	Send(*RotateCertificateRequest) error
	Recv() (*RotateCertificateResponse, error)
	grpc.ClientStream
}

type certificateManagementRotateClient struct {
	grpc.ClientStream
}

func (x *certificateManagementRotateClient) Send(m *RotateCertificateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *certificateManagementRotateClient) Recv() (*RotateCertificateResponse, error) {
	m := new(RotateCertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificateManagementClient) Install(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_InstallClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CertificateManagement_serviceDesc.Streams[1], "/gnoi.certificate.CertificateManagement/Install", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificateManagementInstallClient{stream}
	return x, nil
}

type CertificateManagement_InstallClient interface {
	Send(*InstallCertificateRequest) error
	Recv() (*InstallCertificateResponse, error)
	grpc.ClientStream
}

type certificateManagementInstallClient struct {
	grpc.ClientStream
}

func (x *certificateManagementInstallClient) Send(m *InstallCertificateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *certificateManagementInstallClient) Recv() (*InstallCertificateResponse, error) {
	m := new(InstallCertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificateManagementClient) GetCertificates(ctx context.Context, in *GetCertificatesRequest, opts ...grpc.CallOption) (*GetCertificatesResponse, error) {
	out := new(GetCertificatesResponse)
	err := c.cc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/GetCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateManagementClient) RevokeCertificates(ctx context.Context, in *RevokeCertificatesRequest, opts ...grpc.CallOption) (*RevokeCertificatesResponse, error) {
	out := new(RevokeCertificatesResponse)
	err := c.cc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/RevokeCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateManagementClient) CanGenerateCSR(ctx context.Context, in *CanGenerateCSRRequest, opts ...grpc.CallOption) (*CanGenerateCSRResponse, error) {
	out := new(CanGenerateCSRResponse)
	err := c.cc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/CanGenerateCSR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertificateManagementServer is the server API for CertificateManagement service.
type CertificateManagementServer interface {
	// Rotate will replace an existing Certificate on the target by creating a
	// new CSR request and placing the new Certificate based on the CSR on the
	// target. If the stream is broken or any steps in the process fail the
	// target must rollback to the original Certificate.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Rotate() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR.
	//
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest----> Target
	//     Client <----- GenerateCSRResponse <--- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client --> LoadCertificateRequest ----> Target
	//     Client <-- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//     This step should be to create a new connection to the target using
	//     The new certificate and validate that the certificate works.
	//     Once verfied, the client will then proceed to finalize the rotation.
	//     If the new connection cannot be completed the client will cancel the
	//     RPC thereby forcing the target to rollback the certificate.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	//
	//
	// Case 2: When Client generates the CSR.
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ----> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client ---> LoadCertificateRequest ----> Target
	//     Client <--- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	Rotate(CertificateManagement_RotateServer) error
	// Install will put a new Certificate on the target by creating a new CSR
	// request and placing the new Certificate based on the CSR on the target.The
	// new Certificate will be associated with a new Certificate Id on the target.
	// If the target has a pre existing Certificate with the given Certificate Id,
	// the operation should fail.
	// If the stream is broken or any steps in the process fail the target must
	// revert any changes in state.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Install() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR-------------------------:
	//
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest() ----> Target
	//     Client <---- GenerateCSRResponse() <---- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	// Case 2: When Client generates the CSR-------------------------:
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	Install(CertificateManagement_InstallServer) error
	// An RPC to get the certificates on the target.
	GetCertificates(context.Context, *GetCertificatesRequest) (*GetCertificatesResponse, error)
	// An RPC to revoke specific certificates.
	// If a certificate is not present on the target, the request should silently
	// succeed. Revoking a certificate should render the existing certificate
	// unusable by any endpoints.
	RevokeCertificates(context.Context, *RevokeCertificatesRequest) (*RevokeCertificatesResponse, error)
	// An RPC to ask a target if it can generate a Certificate.
	CanGenerateCSR(context.Context, *CanGenerateCSRRequest) (*CanGenerateCSRResponse, error)
}

func RegisterCertificateManagementServer(s *grpc.Server, srv CertificateManagementServer) {
	s.RegisterService(&_CertificateManagement_serviceDesc, srv)
}

func _CertificateManagement_Rotate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CertificateManagementServer).Rotate(&certificateManagementRotateServer{stream})
}

type CertificateManagement_RotateServer interface {
	Send(*RotateCertificateResponse) error
	Recv() (*RotateCertificateRequest, error)
	grpc.ServerStream
}

type certificateManagementRotateServer struct {
	grpc.ServerStream
}

func (x *certificateManagementRotateServer) Send(m *RotateCertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *certificateManagementRotateServer) Recv() (*RotateCertificateRequest, error) {
	m := new(RotateCertificateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CertificateManagement_Install_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CertificateManagementServer).Install(&certificateManagementInstallServer{stream})
}

type CertificateManagement_InstallServer interface {
	Send(*InstallCertificateResponse) error
	Recv() (*InstallCertificateRequest, error)
	grpc.ServerStream
}

type certificateManagementInstallServer struct {
	grpc.ServerStream
}

func (x *certificateManagementInstallServer) Send(m *InstallCertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *certificateManagementInstallServer) Recv() (*InstallCertificateRequest, error) {
	m := new(InstallCertificateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CertificateManagement_GetCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).GetCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/GetCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).GetCertificates(ctx, req.(*GetCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CertificateManagement_RevokeCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).RevokeCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/RevokeCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).RevokeCertificates(ctx, req.(*RevokeCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CertificateManagement_CanGenerateCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanGenerateCSRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).CanGenerateCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/CanGenerateCSR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).CanGenerateCSR(ctx, req.(*CanGenerateCSRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CertificateManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.certificate.CertificateManagement",
	HandlerType: (*CertificateManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertificates",
			Handler:    _CertificateManagement_GetCertificates_Handler,
		},
		{
			MethodName: "RevokeCertificates",
			Handler:    _CertificateManagement_RevokeCertificates_Handler,
		},
		{
			MethodName: "CanGenerateCSR",
			Handler:    _CertificateManagement_CanGenerateCSR_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Rotate",
			Handler:       _CertificateManagement_Rotate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Install",
			Handler:       _CertificateManagement_Install_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cert.proto",
}

func init() { proto.RegisterFile("cert.proto", fileDescriptor_cert_460e8e7993df797d) }

var fileDescriptor_cert_460e8e7993df797d = []byte{
	// 1207 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4d, 0x6e, 0xdb, 0x46,
	0x14, 0x36, 0x2d, 0xc5, 0x92, 0x9e, 0xfe, 0xe8, 0x71, 0xec, 0x50, 0x6a, 0x83, 0x38, 0x6c, 0x8d,
	0x38, 0x4e, 0xa0, 0x06, 0xf9, 0x01, 0xfa, 0x03, 0xa4, 0xb0, 0x65, 0x25, 0x16, 0x64, 0x2b, 0xc2,
	0x48, 0x6e, 0xbb, 0x23, 0x26, 0xd4, 0x48, 0x19, 0x58, 0x1c, 0xaa, 0x24, 0x9d, 0x42, 0x3e, 0x44,
	0x2f, 0xd0, 0x4d, 0x57, 0x3d, 0x42, 0x0f, 0xd0, 0x13, 0x74, 0x51, 0x74, 0xdd, 0x83, 0x74, 0x51,
	0x70, 0x86, 0x92, 0x48, 0x91, 0xb2, 0xd5, 0xec, 0xb2, 0xe3, 0xbc, 0xf7, 0xbd, 0x8f, 0xf3, 0xfe,
	0x49, 0x00, 0x93, 0x3a, 0x5e, 0x6d, 0xec, 0xd8, 0x9e, 0x8d, 0xd4, 0x21, 0xb7, 0x59, 0xcd, 0x17,
	0xb0, 0x01, 0x33, 0x89, 0x47, 0xf5, 0x5f, 0xd7, 0x41, 0xc3, 0xb6, 0x47, 0x3c, 0x5a, 0x9f, 0x4b,
	0x31, 0xfd, 0xf1, 0x92, 0xba, 0x1e, 0x6a, 0x42, 0x61, 0x48, 0x39, 0x75, 0x88, 0x47, 0x0d, 0xd3,
	0x75, 0x34, 0x65, 0x57, 0xd9, 0xcf, 0x3f, 0xfd, 0xbc, 0xb6, 0xc8, 0x52, 0x7b, 0x1d, 0xa0, 0xea,
	0x5d, 0x1c, 0xd8, 0x9e, 0xac, 0xe1, 0xfc, 0xd4, 0xb6, 0xee, 0x3a, 0xe8, 0x1c, 0xd4, 0x91, 0x4d,
	0xfa, 0x46, 0xc8, 0x4a, 0x5b, 0x17, 0x74, 0xfb, 0x71, 0xba, 0x53, 0x9b, 0xf4, 0xe3, 0xd7, 0x39,
	0x59, 0xc3, 0xe5, 0x51, 0x54, 0x83, 0x3a, 0xb0, 0x39, 0x60, 0x9c, 0x8c, 0xd8, 0x15, 0x35, 0x1c,
	0xdf, 0x0d, 0x66, 0x73, 0x2d, 0x25, 0x78, 0xef, 0xc7, 0x79, 0x5f, 0x05, 0xd0, 0x39, 0xa1, 0x3a,
	0xb5, 0xc6, 0x81, 0xf1, 0x91, 0x0a, 0x25, 0x41, 0x44, 0x0d, 0x47, 0xa2, 0xf4, 0xbf, 0x14, 0xa8,
	0x24, 0x84, 0xc8, 0x1d, 0xdb, 0xdc, 0xa5, 0xe8, 0x14, 0x8a, 0x53, 0x3f, 0xfb, 0xa1, 0x20, 0xed,
	0xdd, 0x10, 0x24, 0x69, 0x7d, 0xb2, 0x86, 0x67, 0x11, 0xee, 0xfb, 0x61, 0xfa, 0x6e, 0x69, 0x98,
	0x1e, 0xae, 0x10, 0xa6, 0x19, 0xe9, 0x62, 0x9c, 0x8e, 0x36, 0xa1, 0x3c, 0xf3, 0x4a, 0xa2, 0xf4,
	0x3f, 0x15, 0xa8, 0x34, 0xb9, 0xeb, 0x91, 0xd1, 0xe8, 0x63, 0x4c, 0xbd, 0xef, 0x12, 0x93, 0xd7,
	0x9f, 0x65, 0xea, 0x6f, 0x05, 0xaa, 0x49, 0x2e, 0x7d, 0x54, 0xa9, 0x42, 0xa0, 0xce, 0xfd, 0x0a,
	0x72, 0xf5, 0x13, 0xa0, 0x78, 0x9c, 0xd1, 0xd7, 0x00, 0xa6, 0xeb, 0x18, 0x63, 0xe2, 0x10, 0xcb,
	0x0d, 0x9c, 0xf9, 0x24, 0xfe, 0xee, 0x7a, 0x17, 0x77, 0x04, 0x04, 0xe7, 0x4c, 0xd7, 0x91, 0x8f,
	0x68, 0x0f, 0x4a, 0x21, 0x8c, 0xc1, 0xfa, 0xe2, 0xee, 0x39, 0x5c, 0x0c, 0x49, 0x9b, 0x7d, 0xfd,
	0xe7, 0x14, 0xe4, 0x66, 0xf6, 0xe8, 0x05, 0xa4, 0xbd, 0xc9, 0x98, 0x8a, 0x57, 0x95, 0x92, 0x1a,
	0x2c, 0xe4, 0x47, 0x6f, 0x32, 0xa6, 0x58, 0xc0, 0xd1, 0x2e, 0x14, 0x2c, 0xc6, 0x8d, 0x0b, 0x3a,
	0x31, 0x5c, 0x76, 0x25, 0xa3, 0x54, 0xc4, 0x60, 0x31, 0xde, 0xa2, 0x93, 0x2e, 0xbb, 0xa2, 0xe8,
	0x39, 0x64, 0x7d, 0xad, 0x20, 0x4f, 0x09, 0xf2, 0x4a, 0x9c, 0xbc, 0x45, 0x27, 0x82, 0x34, 0x73,
	0x21, 0x1f, 0xd0, 0x3d, 0xc8, 0x9b, 0xb6, 0x65, 0xd9, 0xdc, 0xe0, 0xc4, 0xa2, 0x5a, 0x5a, 0x38,
	0x00, 0x52, 0xd4, 0x26, 0x16, 0x45, 0x1a, 0x64, 0x4c, 0xfb, 0x92, 0x7b, 0xce, 0x44, 0xbb, 0x25,
	0x94, 0xd3, 0x23, 0xba, 0x0d, 0xb7, 0x5c, 0xbf, 0x1d, 0xb4, 0x0d, 0x21, 0x97, 0x07, 0x84, 0x20,
	0x6d, 0x32, 0x6f, 0xa2, 0x65, 0x84, 0x50, 0x3c, 0x23, 0x1d, 0x0a, 0xb6, 0x33, 0x24, 0x9c, 0x5d,
	0xc9, 0xe1, 0x92, 0x15, 0xba, 0x88, 0x0c, 0x7d, 0x01, 0x5b, 0xe1, 0x33, 0x19, 0x19, 0x97, 0x9c,
	0x79, 0x5a, 0x4e, 0x40, 0x51, 0x54, 0x75, 0xce, 0x99, 0x87, 0xee, 0x02, 0xb0, 0xb1, 0x41, 0xfa,
	0x7d, 0x87, 0xba, 0xae, 0x06, 0x02, 0x97, 0x63, 0xe3, 0x43, 0x29, 0x40, 0x15, 0xc8, 0x52, 0x8b,
	0xb0, 0x91, 0x9f, 0x96, 0xbc, 0xbc, 0xb8, 0x38, 0x37, 0xfb, 0xfa, 0x4b, 0xd8, 0x4a, 0x28, 0x4e,
	0xf4, 0x00, 0x52, 0xf3, 0x82, 0xde, 0x4e, 0xac, 0x01, 0xec, 0x23, 0xf4, 0x7f, 0x15, 0xd8, 0x49,
	0xee, 0x31, 0xf4, 0x2d, 0xe4, 0xc3, 0xb5, 0x2c, 0xb9, 0xee, 0x5e, 0x9b, 0x64, 0x1c, 0xb6, 0x98,
	0x66, 0x71, 0x4c, 0x98, 0x13, 0x74, 0x42, 0x72, 0x16, 0x3b, 0x84, 0x39, 0x22, 0x8b, 0xfe, 0x43,
	0x42, 0x25, 0xa6, 0x12, 0x2a, 0x11, 0x1d, 0x43, 0xc9, 0x24, 0x91, 0x66, 0x4b, 0xef, 0xa6, 0x6e,
	0xbe, 0x60, 0xd1, 0x24, 0xa1, 0xa3, 0x5e, 0x81, 0x3b, 0x4b, 0x5a, 0x51, 0xdf, 0x84, 0xf2, 0xc2,
	0x7e, 0xd0, 0x35, 0xd8, 0x79, 0x4d, 0xbd, 0x10, 0xd8, 0x9d, 0x6a, 0x86, 0x70, 0x27, 0xa6, 0x99,
	0x4d, 0x19, 0x35, 0xe2, 0x0f, 0x1f, 0xd8, 0x9a, 0x22, 0xae, 0x7a, 0x7d, 0xc3, 0x34, 0xf9, 0xc0,
	0xc6, 0x65, 0x33, 0x2a, 0xd0, 0xff, 0x51, 0xa0, 0xbc, 0x00, 0x4a, 0x88, 0x98, 0x92, 0x14, 0xb1,
	0x85, 0x7c, 0xae, 0xff, 0xef, 0x7c, 0x7e, 0x09, 0x39, 0xca, 0xfb, 0x63, 0x9b, 0x71, 0xcf, 0xd5,
	0x52, 0xc2, 0x85, 0x6a, 0xdc, 0xbc, 0x11, 0x40, 0xf0, 0x1c, 0x8c, 0x1e, 0xc1, 0xa6, 0x65, 0xf7,
	0x25, 0x82, 0xd9, 0xdc, 0xf0, 0x58, 0xd0, 0x9f, 0x29, 0xac, 0x86, 0x15, 0x3d, 0x66, 0x51, 0xfd,
	0x08, 0x2a, 0x98, 0xbe, 0xb7, 0x2f, 0x68, 0x42, 0xa0, 0x13, 0x7d, 0x4d, 0xc5, 0xe7, 0xd4, 0x1f,
	0x0a, 0x54, 0x93, 0x48, 0x82, 0x9c, 0x3c, 0x87, 0x1d, 0x47, 0x68, 0x23, 0xe3, 0x7a, 0xce, 0x76,
	0x3b, 0xd0, 0xd6, 0x23, 0x01, 0xe4, 0xf0, 0x69, 0x18, 0xed, 0x63, 0x02, 0x7f, 0xa8, 0xe3, 0xd8,
	0x7e, 0x8d, 0xfb, 0x21, 0x79, 0x7c, 0x7d, 0x44, 0x67, 0x46, 0x0d, 0xdf, 0x06, 0x57, 0xcd, 0xa5,
	0x3a, 0xfd, 0x1d, 0x54, 0x97, 0x5b, 0xae, 0x9a, 0xf5, 0xcf, 0xa0, 0x28, 0x6e, 0x67, 0x58, 0xd4,
	0x75, 0xc9, 0x90, 0x06, 0x73, 0xbd, 0x20, 0x84, 0x67, 0x52, 0xa6, 0xff, 0xae, 0xc0, 0x76, 0x9d,
	0xf0, 0x84, 0x9d, 0x12, 0x9e, 0xc4, 0xca, 0xca, 0x93, 0x78, 0xa1, 0xe6, 0x85, 0xf5, 0xfa, 0xaa,
	0x4b, 0x22, 0x5c, 0xf3, 0x82, 0xad, 0x22, 0xef, 0x20, 0x76, 0x45, 0x4a, 0xec, 0x0a, 0xff, 0x45,
	0xfe, 0xa2, 0xd0, 0xbf, 0x81, 0x9d, 0xc5, 0x7b, 0x07, 0x29, 0xbe, 0x0f, 0x05, 0x93, 0x70, 0x63,
	0xba, 0xa2, 0x45, 0xb5, 0x65, 0x71, 0xde, 0x9c, 0xa3, 0xf5, 0x01, 0xe4, 0xc3, 0xdf, 0x8e, 0x1f,
	0xbc, 0xcd, 0x62, 0x6d, 0x55, 0x88, 0xf4, 0x8d, 0xde, 0x86, 0x54, 0xbd, 0x8b, 0x3f, 0x94, 0x5f,
	0x95, 0xa3, 0x5c, 0xf2, 0x8a, 0x99, 0xdd, 0x84, 0x4c, 0x30, 0x35, 0xfd, 0x95, 0x37, 0x76, 0xd8,
	0x7b, 0x3f, 0xc8, 0x17, 0x74, 0x22, 0xa8, 0x0b, 0x18, 0x02, 0x51, 0x8b, 0x4e, 0xfc, 0xcd, 0x32,
	0xbe, 0x7c, 0x3b, 0x62, 0xa6, 0xd0, 0x4b, 0x92, 0x9c, 0x94, 0xb4, 0xe8, 0x44, 0xff, 0x45, 0x81,
	0xec, 0xb4, 0x61, 0xd1, 0xb3, 0xc8, 0x05, 0xef, 0x2d, 0x6f, 0xed, 0x5a, 0xe8, 0x7a, 0x55, 0xc8,
	0x4e, 0xfb, 0x3c, 0x28, 0xad, 0xd9, 0x59, 0x7f, 0x09, 0x69, 0x91, 0x40, 0x04, 0xa5, 0x46, 0xc7,
	0x38, 0x6f, 0x77, 0x3b, 0x8d, 0x7a, 0xf3, 0x55, 0xb3, 0x71, 0xac, 0xae, 0xa1, 0x2d, 0x28, 0x37,
	0x3a, 0x46, 0xb3, 0xd3, 0x6d, 0xd4, 0x8d, 0xde, 0x79, 0xbb, 0xdd, 0x38, 0x55, 0x15, 0x54, 0x84,
	0x5c, 0xa3, 0x63, 0x1c, 0x1f, 0x36, 0xce, 0xde, 0xb4, 0xd5, 0xf5, 0x83, 0x5a, 0x64, 0xd6, 0x09,
	0xaa, 0x12, 0x40, 0xbd, 0x67, 0x9c, 0xb7, 0x5b, 0xed, 0x37, 0xdf, 0xb7, 0xd5, 0x35, 0x94, 0x87,
	0x4c, 0xbd, 0x67, 0xfc, 0xf0, 0xe2, 0xc9, 0x57, 0xaa, 0x72, 0xb0, 0x27, 0x02, 0x33, 0xc5, 0xb5,
	0xc2, 0x38, 0x80, 0x8d, 0x56, 0xcf, 0xc0, 0xdd, 0x43, 0x55, 0x79, 0xfa, 0x5b, 0x1a, 0xb6, 0x43,
	0xbc, 0x67, 0x84, 0x93, 0x21, 0xb5, 0x28, 0xf7, 0x10, 0x85, 0x0d, 0xf9, 0x65, 0x8f, 0x0e, 0xe2,
	0xde, 0x2f, 0xfb, 0x2d, 0xaa, 0x3e, 0x5a, 0x09, 0x2b, 0xeb, 0x72, 0x5f, 0x79, 0xa2, 0xa0, 0x77,
	0x90, 0x09, 0x3e, 0x4b, 0x51, 0x82, 0xed, 0xd2, 0x8f, 0xf0, 0xea, 0xe3, 0xd5, 0xc0, 0xa1, 0x37,
	0x0d, 0xa0, 0xbc, 0xb0, 0x97, 0xd0, 0x7e, 0xd2, 0xe7, 0x6d, 0xd2, 0x52, 0xab, 0x3e, 0x5c, 0x01,
	0x19, 0x74, 0x9b, 0x0d, 0x28, 0x3e, 0x6e, 0x93, 0x9c, 0x5b, 0x3a, 0xd9, 0x93, 0x9c, 0xbb, 0x66,
	0x82, 0x9b, 0x50, 0x8a, 0x36, 0x3e, 0x7a, 0x90, 0xd0, 0x50, 0x49, 0x23, 0xad, 0xba, 0x7f, 0x33,
	0x50, 0xbe, 0xe4, 0xed, 0x86, 0xf8, 0x4b, 0x7e, 0xf6, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa8,
	0x84, 0x70, 0x1c, 0x33, 0x0f, 0x00, 0x00,
}
